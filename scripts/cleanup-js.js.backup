/**
 * JavaScript Cleanup Script
 * 
 * Performs safe JavaScript cleanup:
 * 1. Removes unused functions (with safety checks)
 * 2. Removes unused variables (with safety checks)
 * 3. Removes unused Vue component internals (with template checking)
 * 4. Creates backups before applying changes
 * 5. Runs tests before and after cleanup
 */

const fs = require('fs')
const path = require('path')
const { analyzeJS } = require('./analyze-js-usage')
const { runTests } = require('./test-js-cleanup')

// Safety keep list
const SAFETY_KEEP_LIST = [
  'main.js',
  'App.vue',
  'router/index.js',
  'createApp',
  'createRouter',
  'mount',
  'use',
  'mounted',
  'created',
  'beforeMount',
  'beforeUnmount',
  'unmounted',
  'setup',
  'beforeEach',
  'afterEach'
]

// Vue lifecycle hooks (never remove)
const VUE_LIFECYCLE_HOOKS = [
  'beforeCreate', 'created', 'beforeMount', 'mounted',
  'beforeUpdate', 'updated', 'beforeUnmount', 'unmounted',
  'activated', 'deactivated', 'errorCaptured', 'renderTracked', 'renderTriggered'
]

// Files to never modify
const NEVER_MODIFY = [
  'src/main.js',
  'src/App.vue',
  'src/router/index.js',
  'src/utils/iconResolver.js' // User requested: don't touch iconResolver for now
]

/**
 * Check if function/variable should be kept
 */
function shouldKeep(name, filePath, type) {
  // Never modify critical files
  for (const criticalFile of NEVER_MODIFY) {
    if (filePath.includes(criticalFile)) {
      return true
    }
  }
  
  // Check safety keep list
  if (SAFETY_KEEP_LIST.some(keep => name === keep || filePath.includes(keep))) {
    return true
  }
  
  // Keep lifecycle hooks
  if (VUE_LIFECYCLE_HOOKS.includes(name)) {
    return true
  }
  
  // Keep exports
  if (type === 'exported') {
    return true
  }
  
  // Keep functions in backup files - they're backups, safe to remove
  if (filePath.includes('backup')) {
    return false // Actually safe to remove from backups
  }
  
  return false
}

/**
 * Remove unused function from file
 */
function removeFunction(filePath, functionName, functionType) {
  const content = fs.readFileSync(filePath, 'utf-8')
  const lines = content.split('\n')
  const output = []
  let inFunction = false
  let braceDepth = 0
  let functionStart = -1
  let skipFunction = false
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i]
    const trimmed = line.trim()
    
    // Detect function start
    const funcPatterns = [
      new RegExp(`(?:export\\s+)?(?:async\\s+)?function\\s+${functionName}\\s*\\(`),
      new RegExp(`(?:export\\s+)?(?:const|let|var)\\s+${functionName}\\s*=\\s*(?:async\\s+)?\\([^)]*\\)\\s*=>`),
      new RegExp(`(?:export\\s+)?(?:const|let|var)\\s+${functionName}\\s*=\\s*function`),
      new RegExp(`\\b${functionName}\\s*\\([^)]*\\)\\s*\\{`) // Method in object
    ]
    
    const isFunctionStart = funcPatterns.some(pattern => pattern.test(line))
    
    if (isFunctionStart && !inFunction) {
      inFunction = true
      functionStart = i
      braceDepth = (line.match(/{/g) || []).length - (line.match(/}/g) || []).length
      skipFunction = true
      continue
    }
    
    if (inFunction && skipFunction) {
      const openBraces = (line.match(/{/g) || []).length
      const closeBraces = (line.match(/}/g) || []).length
      braceDepth += openBraces - closeBraces
      
      if (braceDepth === 0) {
        // End of function
        inFunction = false
        skipFunction = false
        continue
      }
      // Skip this line (inside function)
      continue
    }
    
    // Keep this line
    output.push(line)
  }
  
  return output.join('\n')
}

/**
 * Remove unused variable from file
 */
function removeVariable(filePath, variableName) {
  const content = fs.readFileSync(filePath, 'utf-8')
  const lines = content.split('\n')
  const output = []
  
  for (const line of lines) {
    // Check if this line declares the variable
    const varPattern = new RegExp(`(?:export\\s+)?(?:const|let|var)\\s+${variableName}\\s*=`)
    if (varPattern.test(line)) {
      // Skip this line
      continue
    }
    output.push(line)
  }
  
  return output.join('\n')
}

/**
 * Clean JavaScript based on analysis report
 */
function cleanJS(report) {
  const rootDir = path.resolve(__dirname, '..')
  const cleanedFiles = {}
  const removalLog = []
  
  // Group unused items by file
  const functionsByFile = new Map()
  const variablesByFile = new Map()
  
  for (const func of report.unusedFunctions) {
    if (!shouldKeep(func.name, func.file, func.type)) {
      if (!functionsByFile.has(func.file)) {
        functionsByFile.set(func.file, [])
      }
      functionsByFile.get(func.file).push(func)
    }
  }
  
  for (const variable of report.unusedVariables) {
    if (!shouldKeep(variable.name, variable.file, variable.type)) {
      if (!variablesByFile.has(variable.file)) {
        variablesByFile.set(variable.file, [])
      }
      variablesByFile.get(variable.file).push(variable)
    }
  }
  
  // Process each file
  const allFiles = new Set()
  for (const func of report.unusedFunctions) {
    allFiles.add(func.file)
  }
  for (const variable of report.unusedVariables) {
    allFiles.add(variable.file)
  }
  
  for (const filePath of allFiles) {
    const fullPath = path.resolve(rootDir, filePath)
    if (!fs.existsSync(fullPath)) {
      console.warn(`‚ö†Ô∏è  File not found: ${filePath}`)
      continue
    }
    
    // Skip critical files
    let isCritical = false
    for (const critical of NEVER_MODIFY) {
      if (filePath.includes(critical)) {
        isCritical = true
        break
      }
    }
    if (isCritical) {
      console.log(`  ‚è≠Ô∏è  Skipping critical file: ${filePath}`)
      continue
    }
    
    console.log(`\nüßπ Cleaning ${filePath}...`)
    
    let cleanedContent = fs.readFileSync(fullPath, 'utf-8')
    const originalContent = cleanedContent
    let removedCount = 0
    
    // Remove unused functions
    const functionsToRemove = functionsByFile.get(filePath) || []
    for (const func of functionsToRemove) {
      cleanedContent = removeFunction(fullPath, func.name, func.type)
      removalLog.push({
        file: filePath,
        type: 'function',
        name: func.name,
        reason: func.reason
      })
      removedCount++
    }
    
    // Remove unused variables (only from non-critical files and backup files)
    if (filePath.includes('backup') || filePath.includes('scripts/')) {
      const variablesToRemove = variablesByFile.get(filePath) || []
      for (const variable of variablesToRemove) {
        cleanedContent = removeVariable(fullPath, variable.name)
        removalLog.push({
          file: filePath,
          type: 'variable',
          name: variable.name,
          reason: variable.reason
        })
        removedCount++
      }
    }
    
    cleanedFiles[filePath] = {
      original: originalContent,
      cleaned: cleanedContent,
      removedCount
    }
    
    console.log(`  ‚úì Removed ${removedCount} unused items`)
  }
  
  return {
    cleanedFiles,
    removalLog
  }
}

/**
 * Create backups
 */
function createBackups(filesToBackup) {
  const backups = []
  const rootDir = path.resolve(__dirname, '..')
  
  for (const filePath of filesToBackup) {
    const fullPath = path.resolve(rootDir, filePath)
    if (fs.existsSync(fullPath)) {
      const backupPath = fullPath + '.backup'
      fs.copyFileSync(fullPath, backupPath)
      backups.push(backupPath)
      console.log(`  ‚úì Backup created: ${backupPath}`)
    }
  }
  
  return backups
}

/**
 * Main cleanup function
 */
function performCleanup(dryRun = false) {
  console.log('üßπ JavaScript Cleanup Script\n')
  console.log('='.repeat(60))
  
  if (dryRun) {
    console.log('üîç DRY RUN MODE - No files will be modified\n')
  }
  
  // Step 1: Run analysis
  console.log('üìä Step 1: Running JavaScript analysis...')
  const report = analyzeJS()
  
  // Step 2: Run tests
  console.log('\nüß™ Step 2: Running tests...')
  const testsPassed = runTests()
  if (!testsPassed) {
    console.error('\n‚ùå Tests failed! Aborting cleanup.')
    return false
  }
  
  // Step 3: Create backups
  const filesToBackup = new Set()
  for (const func of report.unusedFunctions) {
    filesToBackup.add(func.file)
  }
  for (const variable of report.unusedVariables) {
    filesToBackup.add(variable.file)
  }
  
  if (!dryRun) {
    console.log('\nüíæ Step 3: Creating backups...')
    createBackups(Array.from(filesToBackup))
  } else {
    console.log('\nüíæ Step 3: Would create backups (dry run)')
  }
  
  // Step 4: Perform cleanup
  console.log('\nüßπ Step 4: Performing cleanup...')
  const cleanupResult = cleanJS(report)
  
  // Step 5: Calculate file sizes
  const rootDir = path.resolve(__dirname, '..')
  const beforeSizes = {}
  const afterSizes = {}
  
  for (const filePath of filesToBackup) {
    const fullPath = path.resolve(rootDir, filePath)
    if (fs.existsSync(fullPath)) {
      beforeSizes[filePath] = fs.statSync(fullPath).size
    }
  }
  
  // Step 6: Apply cleaned files
  if (!dryRun) {
    console.log('\nüíæ Step 5: Applying cleaned JavaScript...')
    for (const [filePath, data] of Object.entries(cleanupResult.cleanedFiles)) {
      const fullPath = path.resolve(rootDir, filePath)
      fs.writeFileSync(fullPath, data.cleaned, 'utf-8')
      afterSizes[filePath] = fs.statSync(fullPath).size
      console.log(`  ‚úì Updated ${filePath}`)
    }
  } else {
    for (const [filePath, data] of Object.entries(cleanupResult.cleanedFiles)) {
      afterSizes[filePath] = Buffer.byteLength(data.cleaned, 'utf-8')
    }
  }
  
  // Step 7: Run tests on cleaned code
  if (!dryRun) {
    console.log('\nüß™ Step 6: Running tests on cleaned JavaScript...')
    const testsPassedAfter = runTests()
    if (!testsPassedAfter) {
      console.error('\n‚ùå Tests failed after cleanup! Restoring backups...')
      for (const filePath of filesToBackup) {
        const fullPath = path.resolve(rootDir, filePath)
        const backupPath = fullPath + '.backup'
        if (fs.existsSync(backupPath)) {
          fs.copyFileSync(backupPath, fullPath)
          console.log(`  ‚úì Restored ${filePath}`)
        }
      }
      return false
    }
  }
  
  // Summary
  console.log('\n' + '='.repeat(60))
  console.log('üìä CLEANUP SUMMARY')
  console.log('='.repeat(60))
  
  let totalRemoved = 0
  for (const [filePath, data] of Object.entries(cleanupResult.cleanedFiles)) {
    totalRemoved += data.removedCount
    const beforeSize = beforeSizes[filePath] || 0
    const afterSize = afterSizes[filePath] || 0
    const reduction = beforeSize - afterSize
    const reductionPercent = beforeSize > 0 ? ((reduction / beforeSize) * 100).toFixed(2) : 0
    
    console.log(`\n${filePath}:`)
    console.log(`  Removed: ${data.removedCount} items`)
    console.log(`  Size: ${(beforeSize / 1024).toFixed(2)} KB ‚Üí ${(afterSize / 1024).toFixed(2)} KB (${reductionPercent}% reduction)`)
  }
  
  const totalBefore = Object.values(beforeSizes).reduce((a, b) => a + b, 0)
  const totalAfter = Object.values(afterSizes).reduce((a, b) => a + b, 0)
  const totalReduction = totalBefore - totalAfter
  const totalReductionPercent = totalBefore > 0 ? ((totalReduction / totalBefore) * 100).toFixed(2) : 0
  
  console.log(`\nTotal:`)
  console.log(`  Removed: ${totalRemoved} items`)
  console.log(`  Size: ${(totalBefore / 1024).toFixed(2)} KB ‚Üí ${(totalAfter / 1024).toFixed(2)} KB (${totalReductionPercent}% reduction)`)
  
  if (!dryRun) {
    console.log('\n‚úÖ Cleanup completed successfully!')
    console.log('üí° Backups saved with .backup extension')
  } else {
    console.log('\nüí° This was a dry run. Use --apply to actually perform cleanup.')
  }
  
  return true
}

if (require.main === module) {
  const args = process.argv.slice(2)
  const dryRun = !args.includes('--apply')
  
  try {
    const success = performCleanup(dryRun)
    process.exit(success ? 0 : 1)
  } catch (err) {
    console.error('‚ùå Cleanup failed:', err)
    process.exit(1)
  }
}

module.exports = { performCleanup, cleanJS, createBackups }
