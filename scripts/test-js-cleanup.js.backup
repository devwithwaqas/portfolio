/**
 * JavaScript Cleanup Test Suite
 * 
 * Tests JavaScript cleanup to ensure:
 * 1. All required functions are present
 * 2. All required exports are present
 * 3. Critical files are not broken
 * 4. Vue components still work
 */

const fs = require('fs')
const path = require('path')

// Critical files that must have specific exports/functions
const CRITICAL_FILES = {
  'src/main.js': {
    requiredExports: [],
    requiredFunctions: [], // createApp is imported, not defined
    requiredImports: ['vue', 'App', 'router', 'createApp']
  },
  'src/router/index.js': {
    requiredExports: ['default'],
    requiredFunctions: ['loadComponent'], // createRouter is imported
    requiredImports: ['vue-router', 'createRouter']
  }
}

// Required exports from utility files (check what actually exists)
const REQUIRED_EXPORTS = {
  'src/utils/assetPath.js': ['assetPath'], // getAssetPath might not exist
  'src/utils/analytics.js': ['trackPageView', 'trackProjectPageView', 'trackServicePageView'],
  'src/utils/seo.js': ['setPageSEO', 'getHomePageSEO', 'getProjectPageSEO', 'getServicePageSEO'],
  'src/utils/structuredData.js': ['generateProjectPageStructuredData', 'generateServicePageStructuredData'],
  'src/utils/iconResolver.js': ['resolveIcon'], // getIconUrl might not exist
  'src/services/NarrationService.js': [], // Check if default export or named
  'src/services/HighlightService.js': [] // Check if default export or named
}

// Test cases for Vue components
const VUE_COMPONENT_TESTS = {
  navigation: {
    name: 'Navigation Component Test',
    file: 'src/components/layout/Navigation.vue',
    requiredMethods: ['toggleMobileMenu'],
    requiredData: [],
    requiredComputed: []
  },
  hero: {
    name: 'Hero Component Test',
    file: 'src/components/home/Hero.vue',
    requiredMethods: [],
    requiredData: [],
    requiredComputed: []
  },
  router: {
    name: 'Router Test',
    file: 'src/router/index.js',
    requiredFunctions: ['scrollBehavior', 'saveScrollPosition', 'getSavedScrollPosition'],
    requiredExports: ['default']
  }
}

/**
 * Check if file exists and has required exports
 */
function testFileExports(filePath, requiredExports) {
  const fullPath = path.resolve(__dirname, '..', filePath)
  if (!fs.existsSync(fullPath)) {
    return { passed: false, error: 'File not found' }
  }
  
  // Skip if no required exports
  if (!requiredExports || requiredExports.length === 0) {
    return { passed: true, missing: [] }
  }
  
  const content = fs.readFileSync(fullPath, 'utf-8')
  const missing = []
  
  for (const exportName of requiredExports) {
    let found = false
    
    // Special case for 'default' export
    if (exportName === 'default') {
      found = /export\s+default/.test(content)
    } else {
      // Check for export default, export const, export function, export { name }
      const patterns = [
        new RegExp(`export\\s+default\\s+${exportName}`),
        new RegExp(`export\\s+(?:const|let|var|function|class)\\s+${exportName}`),
        new RegExp(`export\\s*\\{[^}]*\\b${exportName}\\b[^}]*\\}`),
        new RegExp(`export\\s*\\{[^}]*\\b${exportName}\\s*as`),
      ]
      
      found = patterns.some(pattern => pattern.test(content))
    }
    
    if (!found) {
      missing.push(exportName)
    }
  }
  
  return {
    passed: missing.length === 0,
    missing
  }
}

/**
 * Check if file has required functions or imports
 */
function testFileFunctions(filePath, requiredFunctions, requiredImports = []) {
  const fullPath = path.resolve(__dirname, '..', filePath)
  if (!fs.existsSync(fullPath)) {
    return { passed: false, error: 'File not found' }
  }
  
  // Skip if no required functions
  if ((!requiredFunctions || requiredFunctions.length === 0) && 
      (!requiredImports || requiredImports.length === 0)) {
    return { passed: true, missing: [] }
  }
  
  const content = fs.readFileSync(fullPath, 'utf-8')
  const missing = []
  
  // Check for functions
  if (requiredFunctions && requiredFunctions.length > 0) {
    for (const funcName of requiredFunctions) {
      // Check for function declarations, arrow functions, method definitions
      const patterns = [
        new RegExp(`(?:export\\s+)?(?:async\\s+)?function\\s+${funcName}\\s*\\(`),
        new RegExp(`(?:export\\s+)?(?:const|let|var)\\s+${funcName}\\s*=\\s*(?:async\\s+)?\\([^)]*\\)\\s*=>`),
        new RegExp(`(?:export\\s+)?(?:const|let|var)\\s+${funcName}\\s*=\\s*function`),
        new RegExp(`\\b${funcName}\\s*\\([^)]*\\)\\s*\\{`), // Method in object
      ]
      
      const found = patterns.some(pattern => pattern.test(content))
      if (!found) {
        missing.push(funcName)
      }
    }
  }
  
  // Check for imports
  if (requiredImports && requiredImports.length > 0) {
    for (const importName of requiredImports) {
      // Check for import statements
      const importPattern = new RegExp(`import\\s+.*\\b${importName}\\b|import\\s+\\{[^}]*\\b${importName}\\b[^}]*\\}`)
      if (!importPattern.test(content)) {
        missing.push(importName + ' (import)')
      }
    }
  }
  
  return {
    passed: missing.length === 0,
    missing
  }
}

/**
 * Check Vue component internals
 */
function testVueComponent(filePath, requiredMethods, requiredData, requiredComputed) {
  const fullPath = path.resolve(__dirname, '..', filePath)
  if (!fs.existsSync(fullPath)) {
    return { passed: false, error: 'File not found' }
  }
  
  const content = fs.readFileSync(fullPath, 'utf-8')
  const scriptMatch = content.match(/<script[^>]*>([\s\S]*?)<\/script>/i)
  if (!scriptMatch) {
    return { passed: false, error: 'No script section found' }
  }
  
  const scriptContent = scriptMatch[1]
  const missing = { methods: [], data: [], computed: [] }
  
  // Check methods
  for (const method of requiredMethods) {
    if (!new RegExp(`(?:methods\\s*:\\s*\\{[^}]*|\\b${method}\\s*\\([^)]*\\)\\s*\\{)`).test(scriptContent)) {
      missing.methods.push(method)
    }
  }
  
  // Check data
  for (const dataProp of requiredData) {
    if (!new RegExp(`data\\s*\\([^)]*\\)\\s*\\{[^}]*${dataProp}\\s*:`).test(scriptContent)) {
      missing.data.push(dataProp)
    }
  }
  
  // Check computed
  for (const computed of requiredComputed) {
    if (!new RegExp(`(?:computed\\s*:\\s*\\{[^}]*|\\b${computed}\\s*\\([^)]*\\)\\s*\\{)`).test(scriptContent)) {
      missing.computed.push(computed)
    }
  }
  
  const totalMissing = missing.methods.length + missing.data.length + missing.computed.length
  
  return {
    passed: totalMissing === 0,
    missing
  }
}

/**
 * Run all tests
 */
function runTests() {
  console.log('üß™ JavaScript Cleanup Test Suite\n')
  console.log('='.repeat(60))
  
  const results = []
  let allPassed = true
  
  // Test critical files
  console.log('\nüîç Testing critical files...\n')
  for (const [filePath, requirements] of Object.entries(CRITICAL_FILES)) {
    if (requirements.requiredExports && requirements.requiredExports.length > 0) {
      const result = testFileExports(filePath, requirements.requiredExports)
      results.push({
        name: `Critical: ${filePath} (exports)`,
        passed: result.passed,
        missing: result.missing || [],
        error: result.error
      })
      if (!result.passed) allPassed = false
    }
    
    if ((requirements.requiredFunctions && requirements.requiredFunctions.length > 0) ||
        (requirements.requiredImports && requirements.requiredImports.length > 0)) {
      const result = testFileFunctions(
        filePath, 
        requirements.requiredFunctions || [],
        requirements.requiredImports || []
      )
      results.push({
        name: `Critical: ${filePath} (functions/imports)`,
        passed: result.passed,
        missing: result.missing || [],
        error: result.error
      })
      if (!result.passed) allPassed = false
    }
  }
  
  // Test required exports
  console.log('üîç Testing required exports...\n')
  for (const [filePath, exports] of Object.entries(REQUIRED_EXPORTS)) {
    const result = testFileExports(filePath, exports)
    results.push({
      name: `Exports: ${filePath}`,
      passed: result.passed,
      missing: result.missing || [],
      error: result.error
    })
    if (!result.passed) allPassed = false
  }
  
  // Test Vue components
  console.log('üîç Testing Vue components...\n')
  for (const [key, test] of Object.entries(VUE_COMPONENT_TESTS)) {
    if (test.requiredMethods || test.requiredData || test.requiredComputed) {
      const result = testVueComponent(
        test.file,
        test.requiredMethods || [],
        test.requiredData || [],
        test.requiredComputed || []
      )
      results.push({
        name: test.name,
        passed: result.passed,
        missing: result.missing || {},
        error: result.error
      })
      if (!result.passed) allPassed = false
    }
  }
  
  // Print results
  console.log('üß™ Running test cases...\n')
  for (const result of results) {
    if (result.passed) {
      console.log(`  ‚úÖ ${result.name}: PASSED`)
    } else {
      console.log(`  ‚ùå ${result.name}: FAILED`)
      if (result.error) {
        console.log(`     Error: ${result.error}`)
      }
      if (result.missing && Array.isArray(result.missing) && result.missing.length > 0) {
        console.log(`     Missing: ${result.missing.join(', ')}`)
      }
      if (result.missing && typeof result.missing === 'object') {
        if (result.missing.methods?.length > 0) {
          console.log(`     Missing methods: ${result.missing.methods.join(', ')}`)
        }
        if (result.missing.data?.length > 0) {
          console.log(`     Missing data: ${result.missing.data.join(', ')}`)
        }
        if (result.missing.computed?.length > 0) {
          console.log(`     Missing computed: ${result.missing.computed.join(', ')}`)
        }
      }
    }
  }
  
  // Summary
  console.log('\n' + '='.repeat(60))
  console.log('üìä TEST SUMMARY')
  console.log('='.repeat(60))
  
  const passedCount = results.filter(r => r.passed).length
  const failedCount = results.filter(r => !r.passed).length
  
  console.log(`Total Tests: ${results.length}`)
  console.log(`Passed: ${passedCount}`)
  console.log(`Failed: ${failedCount}`)
  
  if (allPassed) {
    console.log('\n‚úÖ All tests passed! JavaScript cleanup is safe to proceed.')
    return true
  } else {
    console.log('\n‚ùå Some tests failed! Do not proceed with cleanup.')
    console.log('\nüí° Fix missing exports/functions before running cleanup.')
    return false
  }
}

if (require.main === module) {
  try {
    const passed = runTests()
    process.exit(passed ? 0 : 1)
  } catch (err) {
    console.error('‚ùå Test suite failed:', err)
    process.exit(1)
  }
}

module.exports = { runTests, testFileExports, testFileFunctions, testVueComponent }
