/**
 * Blog article: azure-cloud-architecture-patterns
 * Auto-generated by scripts/split-blog-articles.js. Do not edit the content here by hand if you run the split script again.
 */

export default {
  slug: "azure-cloud-architecture-patterns",
  title: "Azure Cloud Architecture Patterns for Scalable Apps",
  excerpt: "In-depth Azure cloud architecture: compute (App Service vs AKS vs Container Apps vs Functions), storage (Azure SQL vs Cosmos DB vs Blob), messaging (Service Bus, Event Grid, Event Hubs), security, networking, deployment (Bicep), monitoring, decision framework, HA/DR, and cost discipline. From real enterprise migrations and greenfield builds.",
  date: "2024-03-17",
  topic: "Cloud",
  keywords: ["Azure Cloud Architecture Patterns for Scalable Apps", "Azure Cloud Architecture Patterns", "Azure Cloud Architecture Patterns best practices", "how to azure cloud architecture patterns", "azure cloud architecture patterns in .NET", "azure cloud architecture patterns guide", "azure cloud architecture patterns for enterprise", "azure cloud architecture patterns patterns", "when to use azure cloud architecture patterns", "azure cloud architecture patterns tutorial", "azure cloud architecture patterns examples", "azure cloud architecture patterns in C#", "azure cloud architecture patterns overview", "azure cloud architecture patterns implementation", "understanding azure cloud architecture patterns", "azure cloud architecture patterns for developers", "azure cloud architecture patterns checklist", "azure cloud architecture patterns tips", "azure cloud architecture patterns deep dive", "azure cloud architecture patterns comparison", "azure cloud architecture patterns vs alternatives", "azure cloud architecture patterns .NET Core", "azure cloud architecture patterns Azure", "azure cloud architecture patterns explained", "azure cloud architecture patterns when to use", "azure cloud architecture patterns enterprise", "azure cloud architecture patterns .NET", "what is azure cloud architecture patterns", "azure cloud architecture patterns summary", "azure cloud architecture patterns introduction", "azure cloud architecture patterns fundamentals", "azure cloud architecture patterns step by step", "azure cloud architecture patterns complete guide", "azure cloud architecture patterns for beginners", "azure cloud architecture patterns advanced", "azure cloud architecture patterns production", "azure cloud architecture patterns real world", "azure cloud architecture patterns example code", "azure cloud architecture patterns C# example", "azure cloud architecture patterns .NET example", "learn azure cloud architecture patterns", "azure cloud architecture patterns learn", "azure cloud architecture patterns reference", "azure cloud architecture patterns cheat sheet", "azure cloud architecture patterns pitfalls", "azure cloud architecture patterns common mistakes", "azure cloud architecture patterns performance", "azure cloud architecture patterns optimization", "azure cloud architecture patterns security", "azure cloud architecture patterns testing", "azure cloud architecture patterns unit test", "azure cloud architecture patterns integration", "azure cloud architecture patterns migration", "azure cloud architecture patterns from scratch", "azure cloud architecture patterns 2024", "azure cloud architecture patterns 2025", "best azure cloud architecture patterns", "azure cloud architecture patterns best", "pro azure cloud architecture patterns", "azure cloud architecture patterns expert", "azure cloud architecture patterns consultant", "azure cloud architecture patterns services", "azure cloud architecture patterns course", "azure cloud architecture patterns workshop", "azure cloud architecture patterns webinar", "azure cloud architecture patterns blog", "azure cloud architecture patterns article", "azure cloud architecture patterns post", "why azure cloud architecture patterns", "when azure cloud architecture patterns", "where azure cloud architecture patterns", "azure cloud architecture patterns in .NET 6", "azure cloud architecture patterns in .NET 7", "azure cloud architecture patterns in .NET 8", "azure cloud architecture patterns for C#", "azure cloud architecture patterns for Angular", "azure cloud architecture patterns for Vue", "azure cloud architecture patterns for React", "azure cloud architecture patterns for Azure", "azure cloud architecture patterns for microservices", "azure cloud architecture patterns for API", "azure cloud architecture patterns for database", "azure cloud architecture patterns for testing", "azure cloud architecture patterns for DevOps", "azure cloud architecture patterns for senior developers", "azure cloud architecture patterns for team", "azure cloud architecture patterns for production", "azure cloud architecture patterns for scale", "azure cloud architecture patterns for refactoring", "azure cloud architecture patterns for enterprise applications", "azure cloud architecture patterns for startup", "azure cloud architecture patterns in 2024", "azure cloud architecture patterns in 2025", "azure cloud architecture patterns in 2026", "azure cloud architecture patterns code sample", "azure cloud architecture patterns code example", "azure cloud architecture patterns sample code", "azure cloud architecture patterns full example", "azure cloud architecture patterns working example", "azure cloud architecture patterns practical azure cloud architecture patterns", "azure cloud architecture patterns real world example", "azure cloud architecture patterns use case", "azure cloud architecture patterns use cases", "azure cloud architecture patterns scenario", "azure cloud architecture patterns scenarios", "azure cloud architecture patterns pattern", "azure cloud architecture patterns approach", "azure cloud architecture patterns approaches", "azure cloud architecture patterns strategy", "azure cloud architecture patterns strategies", "azure cloud architecture patterns technique", "azure cloud architecture patterns techniques", "azure cloud architecture patterns method", "azure cloud architecture patterns methods", "azure cloud architecture patterns solution", "azure cloud architecture patterns solutions", "azure cloud architecture patterns implementation guide", "azure cloud architecture patterns getting started", "azure cloud architecture patterns quick start", "azure cloud architecture patterns overview guide", "azure cloud architecture patterns comprehensive guide", "azure cloud architecture patterns detailed guide", "azure cloud architecture patterns practical guide", "azure cloud architecture patterns developer guide", "azure cloud architecture patterns engineer guide", "azure cloud architecture patterns architect guide", "azure cloud architecture patterns for architects", "azure cloud architecture patterns for backend", "azure cloud architecture patterns for tech leads", "azure cloud architecture patterns for senior devs", "benefits of azure cloud architecture patterns", "advantages of azure cloud architecture patterns", "alternatives to azure cloud architecture patterns", "compared to azure cloud architecture patterns", "intro to azure cloud architecture patterns", "basics of azure cloud architecture patterns", "azure cloud architecture patterns tips and tricks", "azure cloud architecture patterns production-ready", "azure cloud architecture patterns enterprise-grade", "azure cloud architecture patterns with Docker", "azure cloud architecture patterns with Kubernetes", "azure cloud architecture patterns in ASP.NET Core", "azure cloud architecture patterns with Entity Framework", "azure cloud architecture patterns with EF Core", "azure cloud architecture patterns modern", "azure cloud architecture patterns updated", "azure cloud architecture patterns latest", "azure cloud architecture patterns walkthrough", "azure cloud architecture patterns hands-on", "azure cloud architecture patterns practical examples", "azure cloud architecture patterns real-world examples", "azure cloud architecture patterns common pitfalls", "azure cloud architecture patterns gotchas", "azure cloud architecture patterns FAQ", "azure cloud architecture patterns FAQs", "azure cloud architecture patterns Q&A", "azure cloud architecture patterns interview questions", "azure cloud architecture patterns interview", "azure cloud architecture patterns certification", "azure cloud architecture patterns training", "azure cloud architecture patterns video", "azure cloud architecture patterns series", "azure cloud architecture patterns part 1", "azure cloud architecture patterns core concepts", "azure cloud architecture patterns key concepts", "azure cloud architecture patterns recap", "azure cloud architecture patterns takeaways", "azure cloud architecture patterns conclusion", "azure cloud architecture patterns next steps", "azure cloud architecture patterns further reading", "azure cloud architecture patterns resources", "azure cloud architecture patterns tools", "azure cloud architecture patterns libraries", "azure cloud architecture patterns frameworks", "azure cloud architecture patterns NuGet", "azure cloud architecture patterns package", "azure cloud architecture patterns GitHub", "azure cloud architecture patterns open source", "azure cloud architecture patterns community", "azure cloud architecture patterns Microsoft docs", "azure cloud architecture patterns documentation", "azure cloud architecture patterns official guide", "azure cloud architecture patterns official tutorial", "azure cloud architecture patterns on Azure", "Azure azure cloud architecture patterns", "azure cloud architecture patterns Azure cloud", "Azure azure cloud architecture patterns pattern", "Azure", "Azure guide", "Azure tutorial", "Azure best practices", "Azure in .NET", "Azure in C#", "Azure for developers", "Azure examples", "Azure patterns", "Azure overview", "Azure introduction", "Azure deep dive", "Azure explained", "Azure how to", "Azure what is", "Azure when to use", "Azure for enterprise", "Azure .NET Core", "Azure Azure", "Azure C#", "Azure with .NET", "Azure with C#", "Azure with Azure", "Azure with Angular", "Azure with Vue", "Azure with React", "Azure with Entity Framework", "Azure with SQL Server", "Azure step by step", "Azure complete guide", "Azure from scratch", "Azure 2024", "Azure 2025", "Azure 2026", "Azure code example", "Azure sample code", "Azure implementation", "Azure real world", "Azure production", "Azure for beginners", "Azure advanced", "Azure for architects", "Azure for backend", "Azure for API", "Azure in ASP.NET Core", "Azure with EF Core", "Azure tutorial 2024", "Azure guide 2025", "Azure best practices 2024", "Azure C# examples", "Azure .NET examples", "Azure implementation guide", "Azure how to implement", "Azure benefits", "Azure advantages", "Azure pitfalls", "Azure alternatives", "Azure compared", "Azure intro", "Azure basics", "Azure tips and tricks", "Azure production-ready", "Azure enterprise-grade", "Azure maintainable", "Azure testable", "Azure refactoring", "Azure modern", "Azure updated", "Azure latest", "Azure for tech leads", "Azure for senior devs", "Azure with Docker", "Azure with Kubernetes", "Azure in .NET 8", "Azure in .NET 7", "Azure in .NET 6", "Azure Cloud", "Azure Cloud guide", "Azure Cloud tutorial", "Azure Cloud best practices", "Azure Cloud in .NET", "Azure Cloud in C#", "Azure Cloud for developers", "Azure Cloud examples", "Azure Cloud patterns", "Azure Cloud overview", "Azure Cloud introduction", "Azure Cloud deep dive", "Azure Cloud explained", "Azure Cloud how to", "Azure Cloud what is", "Azure Cloud when to use", "Azure Cloud for enterprise", "Azure Cloud .NET Core", "Azure Cloud Azure", "Azure Cloud C#", "Azure Cloud with .NET", "Azure Cloud with C#", "Azure Cloud with Azure", "Azure Cloud with Angular", "Azure Cloud with Vue", "Azure Cloud with React", "Azure Cloud with Entity Framework", "Azure Cloud with SQL Server", "Azure Cloud step by step", "Azure Cloud complete guide", "Azure Cloud from scratch", "Azure Cloud 2024", "Azure Cloud 2025", "Azure Cloud 2026", "Azure Cloud code example", "Azure Cloud sample code", "Azure Cloud implementation", "Azure Cloud real world", "Azure Cloud production", "Azure Cloud for beginners", "Azure Cloud advanced", "Azure Cloud for architects", "Azure Cloud for backend", "Azure Cloud for API", "Azure Cloud in ASP.NET Core", "Azure Cloud with EF Core", "Azure Cloud tutorial 2024", "Azure Cloud guide 2025", "Azure Cloud best practices 2024", "Azure Cloud C# examples", "Azure Cloud .NET examples", "Azure Cloud implementation guide", "Azure Cloud how to implement", "Azure Cloud benefits", "Azure Cloud advantages", "Azure Cloud pitfalls", "Azure Cloud alternatives", "Azure Cloud compared", "Azure Cloud intro", "Azure Cloud basics", "Azure Cloud tips and tricks", "Azure Cloud production-ready", "Azure Cloud enterprise-grade", "Azure Cloud maintainable", "Azure Cloud testable", "Azure Cloud refactoring", "Azure Cloud modern", "Azure Cloud updated", "Azure Cloud latest", "Azure Cloud for tech leads", "Azure Cloud for senior devs", "Azure Cloud with Docker", "Azure Cloud with Kubernetes", "Azure Cloud in .NET 8", "Azure Cloud in .NET 7", "Azure Cloud in .NET 6", "Azure Cloud Architecture", "Azure Cloud Architecture guide", "Azure Cloud Architecture tutorial", "Azure Cloud Architecture best practices", "Azure Cloud Architecture in .NET", "Azure Cloud Architecture in C#", "Azure Cloud Architecture for developers", "Azure Cloud Architecture examples", "Azure Cloud Architecture overview", "Azure Cloud Architecture introduction", "Azure Cloud Architecture deep dive", "Azure Cloud Architecture explained", "Azure Cloud Architecture how to", "Azure Cloud Architecture what is", "Azure Cloud Architecture when to use", "Azure Cloud Architecture for enterprise", "Azure Cloud Architecture .NET Core", "Azure Cloud Architecture Azure", "Azure Cloud Architecture C#", "Azure Cloud Architecture with .NET", "Azure Cloud Architecture with C#", "Azure Cloud Architecture with Azure", "Azure Cloud Architecture with Angular", "Azure Cloud Architecture with Vue", "Azure Cloud Architecture with React", "Azure Cloud Architecture with Entity Framework", "Azure Cloud Architecture with SQL Server", "Azure Cloud Architecture step by step", "Azure Cloud Architecture complete guide", "Azure Cloud Architecture from scratch", "Azure Cloud Architecture 2024", "Azure Cloud Architecture 2025", "Azure Cloud Architecture 2026", "Azure Cloud Architecture code example", "Azure Cloud Architecture sample code", "Azure Cloud Architecture implementation", "Azure Cloud Architecture real world", "Azure Cloud Architecture production", "Azure Cloud Architecture for beginners", "Azure Cloud Architecture advanced", "Azure Cloud Architecture for architects", "Azure Cloud Architecture for backend", "Azure Cloud Architecture for API", "Azure Cloud Architecture in ASP.NET Core", "Azure Cloud Architecture with EF Core", "Azure Cloud Architecture tutorial 2024", "Azure Cloud Architecture guide 2025", "Azure Cloud Architecture best practices 2024", "Azure Cloud Architecture C# examples", "Azure Cloud Architecture .NET examples", "Azure Cloud Architecture implementation guide", "Azure Cloud Architecture how to implement", "Azure Cloud Architecture benefits", "Azure Cloud Architecture advantages", "Azure Cloud Architecture pitfalls", "Azure Cloud Architecture alternatives", "Azure Cloud Architecture compared", "Azure Cloud Architecture intro", "Azure Cloud Architecture basics", "Azure Cloud Architecture tips and tricks", "Azure Cloud Architecture production-ready", "Azure Cloud Architecture enterprise-grade", "Azure Cloud Architecture maintainable", "Azure Cloud Architecture testable", "Azure Cloud Architecture refactoring", "Azure Cloud Architecture modern", "Azure Cloud Architecture updated", "Azure Cloud Architecture latest", "Azure Cloud Architecture for tech leads", "Azure Cloud Architecture for senior devs", "Azure Cloud Architecture with Docker", "Azure Cloud Architecture with Kubernetes", "Azure Cloud Architecture in .NET 8", "Azure Cloud Architecture in .NET 7", "Azure Cloud Architecture in .NET 6", "Azure Cloud Architecture Patterns how to", "Azure Cloud Architecture Patterns what is", "Azure Cloud Architecture Patterns C#", "Azure Cloud Architecture Patterns with .NET", "Azure Cloud Architecture Patterns with C#", "Azure Cloud Architecture Patterns with Azure", "Azure Cloud Architecture Patterns with Angular", "Azure Cloud Architecture Patterns with Vue", "Azure Cloud Architecture Patterns with React", "Azure Cloud Architecture Patterns with SQL Server", "Azure Cloud Architecture Patterns 2026", "Azure Cloud Architecture Patterns tutorial 2024", "Azure Cloud Architecture Patterns guide 2025", "Azure Cloud Architecture Patterns best practices 2024", "Azure Cloud Architecture Patterns C# examples", "Azure Cloud Architecture Patterns .NET examples", "Azure Cloud Architecture Patterns how to implement", "Azure Cloud Architecture Patterns benefits", "Azure Cloud Architecture Patterns advantages", "Azure Cloud Architecture Patterns alternatives", "Azure Cloud Architecture Patterns compared", "Azure Cloud Architecture Patterns intro", "Azure Cloud Architecture Patterns basics", "Azure Cloud Architecture Patterns maintainable", "Azure Cloud Architecture Patterns testable", "Azure Cloud Architecture Patterns refactoring", "Cloud", "Cloud guide", "Cloud tutorial", "Cloud best practices", "Cloud in .NET", "Cloud in C#", "Cloud for developers", "Cloud examples", "Cloud patterns", "Cloud overview", "Cloud introduction", "Cloud deep dive", "Cloud explained", "Cloud how to", "Cloud what is", "Cloud when to use", "Cloud for enterprise", "Cloud .NET Core", "Cloud Azure", "Cloud C#", "Cloud with .NET", "Cloud with C#", "Cloud with Azure", "Cloud with Angular", "Cloud with Vue", "Cloud with React", "Cloud with Entity Framework", "Cloud with SQL Server", "Cloud step by step", "Cloud complete guide", "Cloud from scratch", "Cloud 2024", "Cloud 2025", "Cloud 2026", "Cloud code example", "Cloud sample code", "Cloud implementation", "Cloud real world", "Cloud production", "Cloud for beginners", "Cloud advanced", "Cloud for architects", "Cloud for backend", "Cloud for API", "Cloud in ASP.NET Core", "Cloud with EF Core", "Cloud tutorial 2024", "Cloud guide 2025", "Cloud best practices 2024", "Cloud C# examples", "Cloud .NET examples", "Cloud implementation guide", "Cloud how to implement", "Cloud benefits", "Cloud advantages", "Cloud pitfalls", "Cloud alternatives", "Cloud compared", "Cloud intro", "Cloud basics", "Cloud tips and tricks", "Cloud production-ready", "Cloud enterprise-grade", "Cloud maintainable", "Cloud testable", "Cloud refactoring", "Cloud modern", "Cloud updated", "Cloud latest", "Cloud for tech leads", "Cloud for senior devs", "Cloud with Docker", "Cloud with Kubernetes", "Cloud in .NET 8", "Cloud in .NET 7", "Cloud in .NET 6", "Cloud Architecture", "Cloud Architecture guide", "Cloud Architecture tutorial", "Cloud Architecture best practices", "Cloud Architecture in .NET", "Cloud Architecture in C#", "Cloud Architecture for developers", "Cloud Architecture examples", "Cloud Architecture patterns", "Cloud Architecture overview", "Cloud Architecture introduction", "Cloud Architecture deep dive", "Cloud Architecture explained", "Cloud Architecture how to", "Cloud Architecture what is", "Cloud Architecture when to use", "Cloud Architecture for enterprise", "Cloud Architecture .NET Core", "Cloud Architecture Azure", "Cloud Architecture C#", "Cloud Architecture with .NET", "Cloud Architecture with C#", "Cloud Architecture with Azure", "Cloud Architecture with Angular", "Cloud Architecture with Vue", "Cloud Architecture with React", "Cloud Architecture with Entity Framework", "Cloud Architecture with SQL Server", "Cloud Architecture step by step", "Cloud Architecture complete guide", "Cloud Architecture from scratch", "Cloud Architecture 2024", "Cloud Architecture 2025", "Cloud Architecture 2026", "Cloud Architecture code example", "Cloud Architecture sample code", "Cloud Architecture implementation", "Cloud Architecture real world", "Cloud Architecture production", "Cloud Architecture for beginners", "Cloud Architecture advanced", "Cloud Architecture for architects", "Cloud Architecture for backend", "Cloud Architecture for API", "Cloud Architecture in ASP.NET Core", "Cloud Architecture with EF Core", "Cloud Architecture tutorial 2024", "Cloud Architecture guide 2025", "Cloud Architecture best practices 2024", "Cloud Architecture C# examples", "Cloud Architecture .NET examples", "Cloud Architecture implementation guide", "Cloud Architecture how to implement", "Cloud Architecture benefits", "Cloud Architecture advantages", "Cloud Architecture pitfalls", "Cloud Architecture alternatives", "Cloud Architecture compared", "Cloud Architecture intro", "Cloud Architecture basics", "Cloud Architecture tips and tricks", "Cloud Architecture production-ready", "Cloud Architecture enterprise-grade", "Cloud Architecture maintainable", "Cloud Architecture testable", "Cloud Architecture refactoring", "Cloud Architecture modern", "Cloud Architecture updated", "Cloud Architecture latest", "Cloud Architecture for tech leads", "Cloud Architecture for senior devs", "Cloud Architecture with Docker", "Cloud Architecture with Kubernetes", "Cloud Architecture in .NET 8", "Cloud Architecture in .NET 7", "Cloud Architecture in .NET 6", "Cloud Architecture Patterns guide", "Cloud Architecture Patterns tutorial", "Cloud Architecture Patterns best practices", "Cloud Architecture Patterns in .NET", "Cloud Architecture Patterns in C#", "Cloud Architecture Patterns for developers", "Cloud Architecture Patterns examples", "Cloud Architecture Patterns patterns", "Cloud Architecture Patterns overview", "Cloud Architecture Patterns introduction", "Cloud Architecture Patterns deep dive", "Cloud Architecture Patterns explained", "Cloud Architecture Patterns how to", "Cloud Architecture Patterns what is", "Cloud Architecture Patterns when to use", "Cloud Architecture Patterns for enterprise", "Cloud Architecture Patterns .NET Core", "Cloud Architecture Patterns Azure", "Cloud Architecture Patterns C#", "Cloud Architecture Patterns with .NET", "Cloud Architecture Patterns with C#", "Cloud Architecture Patterns with Azure", "Cloud Architecture Patterns with Angular", "Cloud Architecture Patterns with Vue", "Cloud Architecture Patterns with React", "Cloud Architecture Patterns with Entity Framework", "Cloud Architecture Patterns with SQL Server", "Cloud Architecture Patterns step by step", "Cloud Architecture Patterns complete guide", "Cloud Architecture Patterns from scratch", "Cloud Architecture Patterns 2024", "Cloud Architecture Patterns 2025", "Cloud Architecture Patterns 2026", "Cloud Architecture Patterns code example", "Cloud Architecture Patterns sample code", "Cloud Architecture Patterns implementation", "Cloud Architecture Patterns real world"],
  relatedServices: ["azure-cloud-architecture","microservices-architecture"],
  relatedProjects: ["heat-exchanger","pj-smart-city"],
  relatedArticleSlugs: ["azure-microservices-best-practices","event-driven-architecture-azure","ci-cd-azure-devops"],
  author: "Waqas Ahmad",
  content: `## Introduction

This guidance is relevant when the topic of this article applies to your system or design choices; it breaks down when constraints or context differ. I've applied it in real projects and refined the takeaways over time (as of 2026).

Microsoft **Azure** offers a broad set of building blocks for **compute**, **storage**, **networking**, and **messaging**. Choosing the right combination affects **cost**, **scalability**, and **operational complexity**. In enterprise migrations and greenfield builds—from heat exchanger platforms to smart city and microservices workloads—I have seen teams **over-provision** with containers when App Service would suffice, and **under-plan** storage when global scale was around the corner. This article is a **full, in-depth** guide to **Azure cloud architecture patterns** that fit common scenarios: **when to use App Service vs containers**, **how to choose between Azure SQL and Cosmos DB**, **when serverless (Functions, Logic Apps) makes sense**, and how to **deploy**, **secure**, and **right-size** your workloads.

The goal is not to memorise every Azure service, but to build a **mental model**: match the service to the workload, plan for growth without over-engineering, and keep operational cost under control. We cover **compute**, **storage**, **messaging**, **security**, **networking**, **deployment** (with Bicep samples), **monitoring**, **decision frameworks**, **high availability**, and **cost discipline**. If you are new to Azure or to cloud architecture, we start with what cloud architecture is and what the main building blocks are, then go through each area in depth with tables, diagrams, and code where it helps.

If you are new to Azure cloud architecture, start with [Topics covered](#topics-covered) and [Azure cloud architecture at a glance](#azure-cloud-architecture-at-a-glance). We explain **App Service**, **AKS**, **Container Apps**, **Functions**, **Azure SQL**, **Cosmos DB**, **Blob**, **Service Bus**, **Event Grid**, **Event Hubs**, and **security** with concrete detail.

## Topics covered

- [Decision Context](#decision-context)
- [What is Azure cloud architecture and why it matters](#what-is-azure-cloud-architecture-and-why-it-matters)
- [What is App Service vs containers vs serverless?](#what-is-app-service-vs-containers-vs-serverless)
- [Azure cloud architecture at a glance](#azure-cloud-architecture-at-a-glance)
- [Compute: App Service vs AKS vs Container Apps vs Functions](#compute-app-service-vs-aks-vs-container-apps-vs-functions)
- [Data stores: Azure SQL vs Cosmos DB vs Blob](#data-stores-azure-sql-vs-cosmos-db-vs-blob)
- [Class structure: how the pieces fit together](#class-structure-how-the-pieces-fit-together)
- [Messaging and integration: Service Bus, Event Grid, Event Hubs](#messaging-and-integration-service-bus-event-grid-event-hubs)
- [Security and identity: Azure AD, Managed Identity, Key Vault](#security-and-identity-azure-ad-managed-identity-key-vault)
- [Networking: VNet, private endpoints, Front Door](#networking-vnet-private-endpoints-front-door)
- [Deployment and DevOps: slots, Bicep, pipelines](#deployment-and-devops-slots-bicep-pipelines)
- [Monitoring and observability](#monitoring-and-observability)
- [Decision framework: when to choose what](#decision-framework-when-to-choose-what)
- [Right-sizing and cost discipline](#right-sizing-and-cost-discipline)
- [High availability and disaster recovery](#high-availability-and-disaster-recovery)
- [Common issues and challenges](#common-issues-and-challenges)
- [Best practices and pitfalls](#best-practices-and-pitfalls)
- [Summary](#summary)
- [Position & Rationale](#position--rationale)
- [Trade-Offs & Failure Modes](#trade-offs--failure-modes)
- [What Most Guides Miss](#what-most-guides-miss)
- [Decision Framework](#decision-framework)
- [Key Takeaways](#key-takeaways)
- [When I Would Use This Again — and When I Wouldn't](#when-i-would-use-this-again--and-when-i-wouldnt)
- [Frequently Asked Questions](#frequently-asked-questions)

------

## Decision Context

- **System scale:** From single App Service + SQL to multi-region AKS + Cosmos + Event Hubs; the patterns apply when you're choosing compute, storage, messaging, and security on Azure for scalable apps.
- **Team size:** One to several teams; platform or architecture often owns the initial choices (App Service vs AKS, SQL vs Cosmos); delivery teams own the apps that run on them.
- **Time / budget pressure:** Fits greenfield and migration; breaks down when "we'll just use the same as last time" without matching workload—then you over- or under-provision.
- **Technical constraints:** Azure (App Service, AKS, Container Apps, Functions, SQL, Cosmos, Blob, Service Bus, Event Grid, Event Hubs, Key Vault, etc.); .NET where relevant.
- **Non-goals:** This article does not optimize for AWS or GCP, for minimal cost at any cost, or for "one size fits all"; it optimises for right-sized Azure architecture and cost discipline.


## What is Azure cloud architecture and why it matters

**Cloud architecture** is how you combine **compute**, **storage**, **networking**, and **identity** so that your application is **scalable**, **secure**, and **cost-effective**. On **Azure**, that means choosing the right mix of **App Service**, **containers** (AKS, Container Apps), **serverless** (Functions, Logic Apps), **databases** (Azure SQL, Cosmos DB, Blob), and **messaging** (Service Bus, Event Grid, Event Hubs). There is **no single "right" architecture**—it depends on your **workload**, **team size**, and how much **operational overhead** you can absorb.

A small **line-of-business app** might sit entirely on **App Service** and **Azure SQL**; a **global, event-driven platform** might use **AKS**, **Cosmos DB**, and **Event Hubs**. The patterns in this article help you decide **when** to use **what**, so you do not over-provision (e.g. AKS for a single API) or under-plan (e.g. Azure SQL for a globally distributed document store). I have seen teams spend months migrating to Kubernetes when App Service would have done the job, and others hit scaling walls because they chose the wrong storage tier from day one.

**Why it matters:** The wrong choice costs **time**, **money**, and **complexity**. Right-sizing from the start—and knowing when to move to the next tier—keeps delivery fast and cost under control. We go through **compute**, **storage**, **messaging**, **security**, **networking**, **deployment**, and **monitoring** in turn, then tie it together with a **decision framework** and **real-world lessons**.

---

## What is App Service vs containers vs serverless?

Before diving into the full at-a-glance table, here is a short **build-up** so you know what each compute option **is** and **when** it fits.

**Azure App Service** is **platform-as-a-service (PaaS)** for web apps and APIs: you deploy your code (or a container); Microsoft runs the VMs, patching, and load balancing. You choose a plan (Basic, Standard, Premium) and **scale out** by adding instances. **Deployment slots** let you stage a new version and swap it with production with minimal downtime. Use App Service when your app is a **traditional web or API** (e.g. ASP.NET Core, Node, Python), you do **not** need to run multiple services in one place, and you are happy with Azure as the sole host. It suits **internal tools**, **marketing sites**, and many **line-of-business APIs**. Cost is predictable and operations are minimal.

**Azure Kubernetes Service (AKS)** and **Azure Container Apps** are for when you need **orchestration**: **multiple services**, **rolling updates**, **service mesh**, or **portability** to another cloud or on-prem. **AKS** gives you **full Kubernetes**: you describe what you want (e.g. "run three replicas of my API") in YAML or Helm charts, and the control plane keeps the cluster in that state. AKS is Microsoft's **managed Kubernetes**: they run the control plane; you get a cluster and add **node pools** (the VMs that run your pods). You get **portability**—the same manifests can run on another cloud or on-prem—and a large ecosystem (Helm, Kustomize, GitOps). The trade-off is **operational complexity**: you own the nodes, networking, and upgrades unless you use a fully managed option. **Container Apps** sits **between** App Service and AKS: you run **containers**, but scaling and networking are simpler; you can **scale to zero** and trigger on HTTP or events (e.g. Service Bus messages). Good fit when you have a **handful of microservices** and do not need full Kubernetes APIs.

**Azure Functions** (and **Logic Apps** for low-code workflows) are for **event-driven, short-lived work**: reacting to blob uploads, queue messages, or HTTP webhooks. Use **Functions** for small, focused pieces of logic that **scale independently**; avoid long-running or stateful processes unless you use **Durable Functions**. Serverless **reduces idle cost** but adds **cold-start** and **timeout** constraints—suit it to the workload. Functions run in a **consumption plan** (pay per execution, scale to zero) or a **premium plan** (always-on, no cold start, VNet integration). For an API that must respond in under 100 ms, consumption-plan cold starts can be a problem; for a nightly batch job or a webhook that processes queue messages, they are usually fine.

---

## Azure cloud architecture at a glance

| Area | Service | What it is | When to use |
|------|---------|------------|-------------|
| **Compute** | **App Service** | PaaS for web/API; managed hosting, slots, scaling | Single web app or API; no multi-service orchestration |
| **Compute** | **AKS** | Managed Kubernetes; full K8s APIs | Many services, rolling updates, portability, service mesh |
| **Compute** | **Container Apps** | Serverless-style containers; scale to zero, event-driven | Handful of microservices; less ops than AKS |
| **Compute** | **Functions** | Serverless; event-driven, short-lived | Blob/queue/HTTP triggers; batch, webhooks |
| **Storage** | **Azure SQL** | Relational; ACID, JOINs | Transactional, relational workloads |
| **Storage** | **Cosmos DB** | Global NoSQL; tunable consistency | Global distribution, low latency at scale, document/key-value |
| **Storage** | **Blob** | Unstructured; files, backups, data lake | Large binaries; no query; analytics with Data Lake/Synapse |
| **Messaging** | **Service Bus** | Queues and topics; reliable, ordered | Work between your services; dead-letter, sessions |
| **Messaging** | **Event Grid** | Event routing; push, high throughput | Fan-out, Azure resource events |
| **Messaging** | **Event Hubs** | High-throughput ingestion | Telemetry, logs, stream processing |
| **Identity** | **Azure AD** | Identity and auth | Users, apps; tokens for APIs |
| **Secrets** | **Key Vault** | Secrets, keys, certs | Connection strings, API keys; reference from app |
| **Edge** | **Front Door / APIM** | Global load balancing, WAF, caching | Edge routing, security, CDN |

\`\`\`mermaid
flowchart TB
  subgraph Compute
    App[App Service]
    AKS[AKS / Container Apps]
    Func[Functions]
  end
  subgraph Storage
    SQL[Azure SQL]
    Cosmos[Cosmos DB]
    Blob[Blob]
  end
  subgraph Messaging
    SB[Service Bus]
    EG[Event Grid]
    EH[Event Hubs]
  end
  Web[Web / API] --> App
  Micro[Microservices] --> AKS
  Event[Events / Webhooks] --> Func
  App --> SQL
  App --> Blob
  AKS --> Cosmos
  App --> SB
  AKS --> EG
  Func --> EH
  style App fill:#2563eb,color:#fff
  style AKS fill:#7c3aed,color:#fff
  style SQL fill:#059669,color:#fff
  style Cosmos fill:#b91c1c,color:#fff
\`\`\`

---

## Compute: App Service vs AKS vs Container Apps vs Functions

**Azure App Service** is the fastest path to production for many web applications. You get managed hosting, scaling (manual or autoscale), deployment slots, and integration with Azure AD and Key Vault. Use App Service when your app is a traditional web or API, you do not need to run multiple services in one place, and you are happy with Azure as the sole host. It suits internal tools, marketing sites, and many line-of-business APIs. Cost is predictable and operations are minimal.

**AKS** or **Container Apps** fit when you need **orchestration**: multiple services, rolling updates, service mesh, or portability to other clouds or on-prem. Choose **AKS** when your team already knows Kubernetes and you need advanced networking or stateful workloads; choose **Container Apps** when you want less operational overhead and event-driven or HTTP scaling.

**Azure Functions** (and **Logic Apps** for low-code workflows) are ideal for **event-driven, short-lived work**: reacting to blob uploads, queue messages, or HTTP webhooks. Use Functions for small, focused pieces of logic that scale independently; avoid long-running or stateful processes unless you use Durable Functions.

\`\`\`mermaid
graph TB
  subgraph Compute
    App[App Service]
    AKS[AKS / Container Apps]
    Func[Functions]
  end
  Web[Web / API] --> App
  Micro[Microservices] --> AKS
  Event[Events / Webhooks] --> Func
\`\`\`

---

## Data stores: Azure SQL vs Cosmos DB vs Blob

**Azure SQL Database** is the default for **relational** workloads: transactional consistency, JOINs, and existing tooling (EF Core, Dapper). Use it when your data model is relational and you need ACID guarantees. Choose the right tier (e.g. DTU or vCore) based on throughput and storage; scale up when needed and consider **read replicas** for read-heavy scenarios.

**Azure Cosmos DB** is a globally distributed **NoSQL** service with **tunable consistency** (strong to eventual). Use it when you need **global distribution**, **low latency** at scale, or a document/key-value model that does not fit SQL. It is more expensive per GB than Azure SQL; use it when multi-region write or single-digit-millisecond latency is a requirement. Model your data for the API you choose (SQL, MongoDB, etc.) and design **partition keys** for even distribution.

**Azure Blob Storage** is for **unstructured data**: files, backups, static assets, and data lakes. Use it for large binary objects and when you do not need query capability; combine with **Azure Data Lake Storage** or **Synapse** if you need analytics on top.

**Example: Azure SQL + EF Core**

\`\`\`csharp
// Example: choosing storage in configuration
// Azure SQL: connection string in Key Vault, EF Core
// MyApp.Infrastructure/OrderRepository.cs
public class OrderRepository : IOrderRepository
{
    private readonly AppDbContext _context;
    public OrderRepository(AppDbContext context) => _context = context;

    public async Task<Order> GetByIdAsync(int id, CancellationToken ct)
        => await _context.Orders.Include(o => o.Lines).FirstOrDefaultAsync(o => o.Id == id, ct);
}
\`\`\`

**Example: Cosmos DB with partition key**

\`\`\`csharp
// Cosmos: endpoint + key, SDK with partition key
// MyApp.Infrastructure/CosmosOrderRepository.cs
public class CosmosOrderRepository
{
    private readonly Container _container;
    public CosmosOrderRepository(CosmosClient client, string db, string containerName)
        => _container = client.GetContainer(db, containerName);

    public async Task<OrderDocument> GetByIdAsync(string id, string partitionKey, CancellationToken ct)
    {
        var response = await _container.ReadItemAsync<OrderDocument>(id, new PartitionKey(partitionKey), cancellationToken: ct);
        return response.Resource;
    }
}
\`\`\`

For **Cosmos DB**, the **partition key** determines how data is distributed; choose one that spreads load evenly (e.g. tenant ID or a high-cardinality field). Avoid a partition key that causes **hot partitions** (e.g. "status" when 90% of documents have status "active").

---

## Class structure: how the pieces fit together

A typical Azure solution involves an **edge** (Front Door or API Management), **compute** (App Service or AKS), **storage abstractions**, and **health/observability**. Keeping **interfaces** for storage and messaging lets you swap implementations (e.g. Azure SQL vs Cosmos, Service Bus vs Event Grid) without changing business logic.

\`\`\`mermaid
classDiagram
  class FrontDoor {
    +Route(request)
    +Cache()
    +WAF()
  }
  class WebApp {
    -IOrderRepository _repo
    -IBlobStore _blob
    +GetOrder(id)
    +UploadDocument(file)
  }
  class IOrderRepository {
    <<interface>>
    +GetByIdAsync(id)
    +SaveAsync(order)
  }
  class IBlobStore {
    <<interface>>
    +UploadAsync(path, stream)
    +GetUrlAsync(path)
  }
  class SqlOrderRepository {
    +GetByIdAsync(id)
    +SaveAsync(order)
  }
  class HealthCheck {
    -IOrderRepository _repo
    +CheckHealthAsync()
  }
  FrontDoor --> WebApp : routes to
  WebApp --> IOrderRepository : uses
  WebApp --> IBlobStore : uses
  SqlOrderRepository ..|> IOrderRepository : implements
  WebApp --> HealthCheck : registers
\`\`\`

**Front Door** (or API Management) sits at the edge: routing, caching, and optional WAF. **WebApp** is your ASP.NET Core app running on App Service or in AKS; it depends on **IOrderRepository** and **IBlobStore** so that you can test with mocks and swap Azure SQL for Cosmos, or Blob for local storage in dev. **HealthCheck** verifies that dependencies (e.g. database, Blob) are reachable so the orchestrator can take unhealthy instances out of rotation.

---

## Messaging and integration: Service Bus, Event Grid, Event Hubs

For **queues and topics** between your own services, **Azure Service Bus** is the workhorse: **reliable**, **ordered**, and integrated with .NET. Use **Event Grid** for **event routing** at scale—high throughput, push/subscribe, and deep Azure integration (e.g. blob created, resource changed). Use **Event Hubs** for **high-throughput ingestion** (telemetry, logs) and stream processing. Do **not** use Event Hubs as a general-purpose queue; use Service Bus or Storage Queues for that.

| Service | Use case | Delivery | Throughput |
|---------|----------|----------|------------|
| **Service Bus** | Reliable work between your services; dead-letter, sessions | At-least-once, ordered (with sessions) | High but not millions/sec |
| **Event Grid** | Fan-out, Azure resource events | At-least-once; push | Very high |
| **Event Hubs** | Ingestion, stream processing | At-least-once; consumer groups | Millions/sec |

---

## Security and identity: Azure AD, Managed Identity, Key Vault

Use **Azure AD** (or Entra ID) for **identity** and **Managed Identity** for **service-to-service auth** so that **no secrets** are stored in code. Put connection strings and keys in **Key Vault** and reference them from App Service, AKS, or Functions. Enable **networking** controls: VNet integration, private endpoints, and firewall rules so that only authorised traffic reaches your resources.

In practice: every App Service or Function that talks to SQL or Service Bus should use **Managed Identity** to get a token; connection strings live in Key Vault and are **referenced by name**, not copied into config. For human users, Azure AD (or B2C for consumer apps) issues tokens; your API validates them with the standard JWT middleware. Do not skip **VNet integration** for apps that only need to call other Azure services—**private endpoints** keep traffic off the public internet and satisfy many compliance requirements.

---

## Networking: VNet, private endpoints, Front Door

**VNet integration** lets your App Service or Function App reach resources in a **virtual network** (e.g. Azure SQL, Service Bus) without exposing those resources to the public internet. **Private endpoints** attach a private IP from your VNet to an Azure service (e.g. SQL, Storage, Key Vault) so that traffic stays on the Microsoft backbone. Use them when **compliance** or **security** requires no public endpoint.

**Azure Front Door** (or **API Management**) sits at the **edge**: **global load balancing**, **WAF**, **caching**, and **routing** to your backends. Use Front Door when you need **geo-routing**, **DDoS protection**, or **unified entry** for multiple backends. **CDN** (often combined with Front Door) reduces latency and egress by caching responses at the edge.

---

## Deployment and DevOps: slots, Bicep, pipelines

For **App Service**, use **deployment slots** to stage a new version and **swap** it with production; that gives zero-downtime deployments and a quick rollback (swap back). For **AKS**, use **rolling updates** so that new pods are brought up before old ones are terminated; pair that with **readiness probes** so traffic only goes to pods that can serve. For **Functions**, deploy via **ARM**, **Bicep**, or **Terraform** so that infrastructure and code are in one place; use **application settings** and **Key Vault references** so that secrets are not in the deployment package.

**Example: minimal Bicep for App Service + Azure SQL**

\`\`\`bicep
// main.bicep – minimal App Service + SQL for illustration
param location string = resourceGroup().location
param appName string = 'myapp'
param sqlServerName string = 'myapp-sql'
param sqlDbName string = 'MyAppDb'

resource sqlServer 'Microsoft.Sql/servers@2023-05-01-preview' = {
  name: sqlServerName
  location: location
  properties: {
    administratorLogin: 'sqladmin'
    administratorLoginPassword: 'CHANGE_ME_USE_KEY_VAULT'
  }
}

resource sqlDb 'Microsoft.Sql/servers/databases@2023-05-01-preview' = {
  parent: sqlServer
  name: sqlDbName
  location: location
  sku: { name: 'Basic' }
}

resource appServicePlan 'Microsoft.Web/serverfarms@2022-09-01' = {
  name: '\${appName}-plan'
  location: location
  sku: { name: 'B1', tier: 'Basic' }
}

resource webApp 'Microsoft.Web/sites@2022-09-01' = {
  name: appName
  location: location
  identity: { type: 'SystemAssigned' }
  properties: {
    serverFarmId: appServicePlan.id
    siteConfig: {
      netFrameworkVersion: 'v8.0'
    }
  }
}
\`\`\`

**What this Bicep does:** It creates a **SQL server** and **database**, an **App Service plan**, and a **Web App** with **system-assigned Managed Identity**. In production, store the SQL admin password in **Key Vault** and reference it; do not put it in the Bicep file. A single **pipeline** that builds, tests, and deploys to dev then staging then production (with **approval gates** for prod) keeps everyone on the same page.

---

## Monitoring and observability

You cannot right-size or fix what you do not measure. **Azure Monitor** and **Application Insights** give you **logs**, **metrics**, and (with the right SDK) **distributed tracing**. Enable **Application Insights** on every App Service, Function App, and AKS workload so that requests, dependencies, and exceptions are captured. Set **alerts** on error rate, latency (e.g. p95 above a threshold), and dependency failures. For AKS, use **container insights**; for Cosmos DB, watch **RU consumption** and throttle rate. A simple dashboard that shows request count, error rate, and dependency latency for your main API is a good starting point. Do not skip logging and metrics because "we will add them later"—adding instrumentation to a live system is harder than building it in from day one.

---

## Decision framework: when to choose what

Before adding a service, run through a short checklist.

**Compute:** Is it a single web app or API with no need for multi-service orchestration? → **App Service**. Do you need to run many services, rolling updates, or portability to another cloud? → **AKS** or **Container Apps**. Is it event-driven, short-lived logic (e.g. react to blob upload, process queue message)? → **Functions**.

**Storage:** Relational data, JOINs, and ACID? → **Azure SQL**. Global distribution, very high throughput, or document/key-value at scale? → **Cosmos DB**. Files, backups, or data lake? → **Blob** (and optionally Data Lake Storage).

**Messaging:** Reliable, ordered work between your own services? → **Service Bus**. Fan-out events or reaction to Azure resource events? → **Event Grid**. High-throughput ingestion or stream processing? → **Event Hubs**.

Document these choices in an **ADR (Architecture Decision Record)** so that when someone asks "why Cosmos and not SQL?" you have a clear answer.

---

## Right-sizing and cost discipline

Right-sizing starts with **measurement**. Use **Azure Monitor** to see CPU, memory, and throughput for your App Service plan, SQL DTUs/vCores, and Cosmos RUs. Start with the **minimum tier** that meets your SLA; scale up when you see sustained pressure (e.g. CPU consistently above 70%, or throttling in Cosmos). For development and staging, use **auto-shutdown** (App Service, VMs) and the **smallest SKUs**—no need for production-sized databases in dev. **Reserved capacity** (one or three years) can cut compute cost significantly for baseline workloads. **Tag** every resource with team, project, and environment so that **Cost Management** can show spend by area.

Practical rules: if your App Service plan is at 5% CPU most of the time, downsize the plan or reduce instance count. If Cosmos is throttling (429s), increase RUs or optimise queries and partition key design. **Egress** (data leaving Azure) is often forgotten until the bill arrives; keep data in-region where possible and use CDN or Front Door cache to reduce repeated fetches. **Budget alerts** in Cost Management are free and take five minutes to set up; set one at 80% of your expected spend so you get a warning before the month ends.

---

## High availability and disaster recovery

**High availability (HA):** For **App Service**, use **multiple instances** (scale out) and **deployment slots** for zero-downtime swaps. For **AKS**, run **multiple replicas** per deployment and spread pods across **availability zones** (if your region supports them). For **Azure SQL**, use **zone-redundant** configuration or **failover groups** for automatic failover. For **Cosmos DB**, enable **multi-region write** or **multi-region read** depending on your consistency and latency requirements.

**Disaster recovery (DR):** Define **RTO** (recovery time objective) and **RPO** (recovery point objective). For **Azure SQL**, **geo-replication** and **failover groups** provide DR to another region. For **Cosmos DB**, add a **secondary region** and configure **failover priority**. For **Blob**, **RA-GRS** (read-access geo-redundant storage) replicates to a secondary region. For **App Service** and **AKS**, replicate your deployment to a **secondary region** and use **Traffic Manager** or **Front Door** for failover. Test **failover** and **rollback** regularly so that when a real disaster happens, you are not debugging the runbook for the first time.

---

## Common issues and challenges

**Over-provisioning compute:** Using AKS or containers when App Service would suffice increases cost and operational complexity. **Match the service to the workload**: start with App Service for web/API; move to AKS or Container Apps only when you need orchestration, multi-service deployment, or portability. I have seen a team run a single .NET API on a 10-node AKS cluster for a year before someone asked why; they moved it to App Service and cut the bill by two-thirds.

**Wrong storage choice:** Using Cosmos DB for simple relational workloads or Azure SQL for global, low-latency NoSQL leads to cost and complexity. **Choose by data model and scale**: Azure SQL for relational; Cosmos DB for global NoSQL; Blob for files. A classic mistake is "we might go global someday" and picking Cosmos for a purely relational app; you pay more and get no benefit until you actually need multi-region write.

**Serverless cold starts:** Azure Functions can have noticeable cold-start latency. For latency-sensitive APIs, use **premium plan** or **always-on** App Service; use Functions for event-driven, batch, or background work where a few hundred ms delay is acceptable.

**Cost explosion:** Leaving resources running, over-provisioning, or ignoring egress can spiral cost. Use **Cost Management** and **tags**; **auto-pause** and **right-size**; prefer **reserved capacity** for baseline workloads. Staging environments that run 24/7 "in case we need to test" are a common leak; auto-shutdown outside business hours or scale to zero where the platform supports it.

**Security misconfiguration:** Exposing resources without private endpoints, storing secrets in code, or weak identity. Use **Managed Identity**, **Key Vault**, and **networking** controls so that only authorised traffic and identities reach your resources. Private endpoints and VNet integration remove the server from the public internet entirely—required for many compliance frameworks.

---

## Best practices and pitfalls

**Do:**

- Match **compute** to the workload: App Service for simple web/API, AKS or Container Apps for microservices, Functions for event-driven logic.
- Choose **storage** by **data model** and **scale**: Azure SQL for relational, Cosmos DB for global NoSQL, Blob for files.
- Use **Managed Identity** and **Key Vault** for secrets; never store connection strings in code or config.
- Enable **Application Insights** and **alerts** from day one; right-size using **Azure Monitor** data.
- **Tag** every resource (team, project, environment) for cost attribution and governance.
- Document **architecture decisions** in ADRs; use **Bicep** or **Terraform** for repeatable deployments.

**Don't:**

- Don't use AKS for a single API when App Service would suffice.
- Don't use Cosmos DB for purely relational workloads "in case we go global."
- Don't use Event Hubs as a general-purpose queue; use Service Bus or Storage Queues.
- Don't skip **private endpoints** or **VNet integration** when compliance or security requires it.
- Don't leave dev/staging resources running 24/7 without auto-shutdown or scale-to-zero.

---
---

## Position & Rationale

I use **App Service** first for most web APIs and SPAs; I add **AKS or Container Apps** when I need multi-container, orchestration, or portability. I use **Azure SQL** for relational, **Cosmos DB** for global distribution or document shape, **Blob** for files and cold data. I avoid **Functions** for long-running or stateful work; I use **Service Bus** for ordered queues, **Event Grid** for event fan-out, **Event Hubs** for high-throughput ingestion. I always plan **Managed Identity** and **Key Vault** so secrets stay out of code; I right-size from day one and review cost regularly.

---

## Trade-Offs & Failure Modes

- **What this sacrifices:** Some flexibility—you're committed to Azure and to the chosen compute/storage mix; migrating later has cost. You also accept operational overhead (monitoring, patching, cost alerts).
- **Where it degrades:** When teams choose AKS "because we might need it" and then don't use orchestration; or when Cosmos is chosen for a single-region relational workload. It also degrades when cost is not reviewed and sprawl grows.
- **How it fails when misapplied:** App Service for a 100-node batch job; or Azure SQL for a globally distributed document store. Another failure: no Private Endpoints or Key Vault so secrets and data are exposed.
- **Early warning signs:** "We're on AKS but we only run one app"; "our Azure bill doubled and we don't know why"; "we're not using Managed Identity."

---

## What Most Guides Miss

Most guides list services. The hard part is **right-sizing**: start with the smallest fit (App Service + SQL), then move to containers or Cosmos when you hit a real limit—not in advance. The other gap: **cost discipline**—tag resources, set budgets and alerts, and review quarterly; I've seen teams over-provision and only notice when finance asks. Finally: **HA/DR**—multi-region and failover are not automatic; you need to design for them (e.g. Cosmos multi-region, SQL geo-replication, Front Door) and test failover.

---

## Decision Framework

- **If you need a web API or SPA** → Start with App Service + Azure SQL (or Cosmos if document model); add slots for staging.
- **If you need containers or multi-service orchestration** → Container Apps for simpler, AKS for full Kubernetes; don't choose AKS for a single app.
- **If you need event-driven or messaging** → Service Bus for queues, Event Grid for fan-out, Event Hubs for high-throughput ingestion; match the guarantee (at-least-once, ordering) to the workload.
- **If you're storing secrets or keys** → Key Vault and Managed Identity from day one; never in config or code.
- **If cost is a concern** → Right-size; set budgets and alerts; review and downscale unused resources.

---

## Key Takeaways

- Match compute to workload: App Service first, containers when you need orchestration or portability; avoid AKS for a single app.
- Match storage to data model and scale: SQL for relational, Cosmos for global or document, Blob for files; plan for growth but don't over-provision day one.
- Use Managed Identity and Key Vault; Private Endpoints where sensitive; plan HA/DR if you need it and test failover.
- Right-size and set cost alerts; review quarterly so sprawl doesn't surprise you.
- Service Bus (queues), Event Grid (events), Event Hubs (ingestion)—choose by guarantee and throughput.

## Summary

- **Compute:** App Service for simple web/API, AKS or Container Apps for microservices, Functions for event-driven logic. Match the service to the workload.
- **Storage:** Azure SQL for relational, Cosmos DB for global NoSQL, Blob for files. Right-size and monitor cost.
- **Messaging:** Service Bus for queues and topics, Event Grid for event routing, Event Hubs for ingestion. Don't use Event Hubs as a general-purpose queue.
- **Security:** Azure AD and Managed Identity; Key Vault for secrets; VNet integration and private endpoints where required.
- **Deployment:** Slots for App Service, rolling updates for AKS, Bicep/ARM for infrastructure; approval gates for production.
- **Cost:** Measure, tag, right-size, reserved capacity for baseline, budget alerts. Avoid over-provisioning and idle dev resources.

---

## When I Would Use This Again — and When I Wouldn't

I would use these Azure patterns again when I'm designing or migrating scalable apps on Azure and need to choose compute, storage, messaging, and security. I wouldn't use them when the target is AWS or GCP—then the mental model applies but services differ. I also wouldn't over-provision (e.g. AKS, Cosmos) for a small LOB app; start with App Service + SQL and move when you hit a real limit. Alternative: for tiny side projects, a single App Service plan and SQL database may be enough; add complexity only when required.


---

## Frequently Asked Questions

### When should I use App Service vs AKS vs Container Apps?

Use **App Service** for simple web/API when you do not need multi-service orchestration or portability. Use **AKS** when you need full Kubernetes (service mesh, advanced networking, multi-cloud). Use **Container Apps** when you want serverless-style containers with scale-to-zero and less operational overhead than AKS.

### When should I use Azure SQL vs Cosmos DB?

Use **Azure SQL** when your data is **relational** and you need ACID and JOINs. Use **Cosmos DB** when you need **global distribution**, **tunable consistency**, or a **document/key-value** model at scale. Cosmos is more expensive per GB; use it when multi-region or single-digit-ms latency is a requirement.

### What are the main cost drivers in Azure?

**Compute** (App Service, AKS nodes, Functions), **storage** (SQL, Cosmos, Blob), **messaging** (Service Bus, Event Grid, Event Hubs), and **egress**. Use **reserved capacity** for baseline; **auto-pause** and **right-size**; **tag** resources so that you can attribute cost by team and environment.

### How do I choose between Service Bus, Event Grid, and Event Hubs?

**Service Bus**: queues and topics for reliable, ordered messaging between your services. **Event Grid**: high-throughput event routing and Azure integration (e.g. blob created). **Event Hubs**: high-throughput ingestion and stream processing. Do not use Event Hubs as a general-purpose queue.

### What is Managed Identity and why use it?

**Managed Identity** lets Azure resources (App Service, AKS, Functions) authenticate to other Azure services (Key Vault, SQL, Service Bus) **without storing secrets**. Use it for service-to-service auth so that no connection strings or keys are in code or config.

### How do I right-size Azure resources?

**Measure** usage (CPU, memory, throughput) with **Azure Monitor**; start with the **minimum tier** that meets SLA. Scale up when metrics justify it; use **auto-scale** for variable load. For dev/staging, use **auto-shutdown** and smaller SKUs.

### When should I use Azure Container Apps vs AKS?

Use **Container Apps** when you want serverless-style containers (scale to zero, event-driven or HTTP scaling) with less operational overhead than Kubernetes. Use **AKS** when you need full Kubernetes: multiple node pools, service mesh, advanced networking, or workloads that require K8s APIs. Container Apps is often enough for 2–5 microservices; AKS fits when you have many services or need portability to another K8s cluster.

### How do I reduce Azure egress cost?

Keep data and traffic in the same region where possible. Use **private endpoints** and **VNet integration** so that traffic between your app and Azure services (SQL, Storage, Service Bus) stays on the backbone. Cache responses at the edge (e.g. Front Door, CDN) to reduce repeated fetches. For cross-region, use Azure backbone and consider **Traffic Manager** or **Front Door** for geo-routing instead of duplicating data everywhere.

### What is the difference between DTU and vCore for Azure SQL?

**DTU (Database Transaction Unit)** is a blended measure of CPU, memory, and I/O; simpler to reason about and good for small to medium workloads. **vCore** gives you explicit control over CPU and memory and supports higher limits and features like read replicas. For most apps, start with DTU; move to vCore when you need more control or higher scale.

### When should I use Logic Apps vs Azure Functions?

Use **Logic Apps** when you need a **low-code** workflow (e.g. "when email arrives, parse and write to SQL") with connectors and a visual designer; good for integration scenarios and non-developers. Use **Functions** when you need **code-first** logic, complex branching, or .NET/Node/Python. Functions give you full control; Logic Apps are faster to build for simple, connector-based flows.

### How do I secure App Service and AKS?

For **App Service**: enable **Managed Identity**, use **Key Vault** references for secrets, turn on **HTTPS only**, and use **VNet integration** or **private endpoints** so the app is not exposed unnecessarily. For **AKS**: use **Azure AD integration** for cluster access, **RBAC** for in-cluster permissions, **network policies** to restrict pod traffic, and **private cluster** if you do not need public API server access. Never store secrets in config or environment variables; use Key Vault and Managed Identity.

### What is Azure Cost Management and how do I use it?

**Cost Management** (in the Azure portal) shows spend by resource, resource group, tag, and service. Use **tags** (e.g. Team=Orders, Env=Prod) on every resource so you can slice cost by team or environment. Set **budgets** and **alerts** so that unexpected spikes (e.g. a runaway Function or a new Cosmos container) trigger a notification. Review **recommendations** (e.g. reserved capacity, right-sizing) regularly.

### When should I use read replicas for Azure SQL?

Use **read replicas** when you have **read-heavy** workloads and want to offload queries from the primary. The replica is eventually consistent; use it for reporting, dashboards, or read-only API paths. Do not use it for transactional reads that must see the latest write—use the primary for that. Replicas add cost; only add them when the primary is under sustained read pressure.

### How do I choose between Event Grid and Service Bus for events?

Use **Event Grid** when you need **high-throughput**, **push-based** delivery to many subscribers, or reaction to **Azure resource events** (blob created, resource changed). Use **Service Bus** when you need **reliable**, **ordered** processing with at-least-once delivery, dead-letter, and sessions. Event Grid is fire-and-forget at scale; Service Bus is for work that must be processed exactly once (or with explicit retries).

### What is the minimum I need for production on Azure?

At least: **compute** (App Service or AKS) with **Managed Identity**; **storage** (Azure SQL or Cosmos) with **Key Vault** for connection strings; **HTTPS** and **Azure AD** (or B2C) for auth; **Azure Monitor** (or Application Insights) for logs and metrics; **backup** and **disaster recovery** per your RTO/RPO. Add **private endpoints** and **VNet** if compliance requires it. Do not skip monitoring and backup—they are not optional for production.

### When should I use private endpoints?

Use **private endpoints** when you want traffic between your app and an Azure service (SQL, Storage, Key Vault, Service Bus) to stay on the **Microsoft backbone** and not cross the public internet. Required for many **compliance** frameworks (e.g. no public SQL endpoint). Combine with **VNet integration** on App Service or Functions so that outbound calls use the VNet and hit the private endpoint.

### How do I deploy App Service with Bicep?

Use the **Microsoft.Web/serverfarms** and **Microsoft.Web/sites** resources in Bicep. Enable **system-assigned Managed Identity** on the site; reference **Key Vault** secrets for connection strings. Use **deployment slots** for staging. Store the Bicep in your repo and run it from a pipeline (Azure DevOps, GitHub Actions) with approval gates for production.

### What is the difference between Front Door and API Management?

**Front Door** is a **global load balancer** and **CDN** with optional **WAF**; it routes traffic to your backends (App Service, AKS, etc.) and can cache responses. **API Management (APIM)** is an **API gateway** that sits in front of your APIs: rate limiting, authentication, transformation, and developer portal. Use **Front Door** for global routing and caching; use **APIM** when you need API-level policies, versioning, or a developer portal. You can use both: Front Door at the edge, APIM behind it for API-specific logic.

### How do I design for high availability on Azure?

Use **multiple instances** (App Service scale out, AKS replicas), **availability zones** where supported, **health checks** and **readiness probes**, and **deployment slots** or **rolling updates** for zero-downtime deploys. For **Azure SQL**, use zone-redundant or failover groups; for **Cosmos DB**, enable multi-region. Define **RTO** and **RPO** and test **failover** and **rollback** regularly.`,
  faqs: [
  {
    "question": "When should I use App Service vs AKS vs Container Apps?",
    "answer": "Use App Service for simple web/API when you do not need multi-service orchestration or portability. Use AKS when you need full Kubernetes (service mesh, advanced networking, multi-cloud). Use Container Apps when you want serverless-style containers with scale-to-zero and less operational overhead than AKS."
  },
  {
    "question": "When should I use Azure SQL vs Cosmos DB?",
    "answer": "Use Azure SQL when your data is relational and you need ACID and JOINs. Use Cosmos DB when you need global distribution, tunable consistency, or a document/key-value model at scale. Cosmos is more expensive per GB; use it when multi-region or single-digit-ms latency is a requirement."
  },
  {
    "question": "What are the main cost drivers in Azure?",
    "answer": "Compute (App Service, AKS nodes, Functions), storage (SQL, Cosmos, Blob), messaging (Service Bus, Event Grid, Event Hubs), and egress. Use reserved capacity for baseline; auto-pause and right-size; tag resources so that you can attribute cost by team and environment."
  },
  {
    "question": "How do I choose between Service Bus, Event Grid, and Event Hubs?",
    "answer": "Service Bus: queues and topics for reliable, ordered messaging between your services. Event Grid: high-throughput event routing and Azure integration (e.g. blob created). Event Hubs: high-throughput ingestion and stream processing. Do not use Event Hubs as a general-purpose queue."
  },
  {
    "question": "What is Managed Identity and why use it?",
    "answer": "Managed Identity lets Azure resources (App Service, AKS, Functions) authenticate to other Azure services (Key Vault, SQL, Service Bus) without storing secrets. Use it for service-to-service auth so that no connection strings or keys are in code or config."
  },
  {
    "question": "How do I right-size Azure resources?",
    "answer": "Measure usage (CPU, memory, throughput) with Azure Monitor; start with the minimum tier that meets SLA. Scale up when metrics justify it; use auto-scale for variable load. For dev/staging, use auto-shutdown and smaller SKUs."
  },
  {
    "question": "When should I use Azure Container Apps vs AKS?",
    "answer": "Use Container Apps when you want serverless-style containers (scale to zero, event-driven or HTTP scaling) with less operational overhead than Kubernetes. Use AKS when you need full Kubernetes: multiple node pools, service mesh, advanced networking, or workloads that require K8s APIs."
  },
  {
    "question": "How do I reduce Azure egress cost?",
    "answer": "Keep data and traffic in the same region where possible. Use private endpoints and VNet integration so that traffic between your app and Azure services stays on the backbone. Cache at the edge (Front Door, CDN) to reduce repeated fetches."
  },
  {
    "question": "What is the difference between DTU and vCore for Azure SQL?",
    "answer": "DTU is a blended measure of CPU, memory, and I/O; simpler for small to medium workloads. vCore gives explicit control over CPU and memory and supports higher limits and read replicas. Start with DTU; move to vCore when you need more control or scale."
  },
  {
    "question": "When should I use Logic Apps vs Azure Functions?",
    "answer": "Use Logic Apps for low-code workflows with connectors and a visual designer; good for integration scenarios. Use Functions for code-first logic, complex branching, or .NET/Node/Python. Functions give full control; Logic Apps are faster for simple, connector-based flows."
  },
  {
    "question": "How do I secure App Service and AKS?",
    "answer": "App Service: Managed Identity, Key Vault references, HTTPS only, VNet integration or private endpoints. AKS: Azure AD integration, RBAC, network policies, private cluster. Never store secrets in config; use Key Vault and Managed Identity."
  },
  {
    "question": "What is Azure Cost Management and how do I use it?",
    "answer": "Cost Management shows spend by resource, group, tag, and service. Use tags on every resource; set budgets and alerts so that unexpected spikes trigger a notification. Review recommendations (reserved capacity, right-sizing) regularly."
  },
  {
    "question": "When should I use read replicas for Azure SQL?",
    "answer": "Use read replicas for read-heavy workloads (reporting, dashboards). Replicas are eventually consistent; use the primary for transactional reads that must see the latest write. Replicas add cost; add them when the primary is under sustained read pressure."
  },
  {
    "question": "How do I choose between Event Grid and Service Bus for events?",
    "answer": "Use Event Grid for high-throughput, push-based delivery and Azure resource events. Use Service Bus for reliable, ordered processing with dead-letter and sessions. Event Grid is fire-and-forget at scale; Service Bus is for work that must be processed exactly once or with explicit retries."
  },
  {
    "question": "What is the minimum I need for production on Azure?",
    "answer": "Compute with Managed Identity, storage with Key Vault, HTTPS and Azure AD, Azure Monitor, backup and DR. Add private endpoints and VNet if compliance requires it. Do not skip monitoring and backup."
  },
  {
    "question": "When should I use private endpoints?",
    "answer": "Use private endpoints when you want traffic between your app and an Azure service (SQL, Storage, Key Vault, Service Bus) to stay on the Microsoft backbone and not cross the public internet. Required for many compliance frameworks."
  },
  {
    "question": "How do I deploy App Service with Bicep?",
    "answer": "Use Microsoft.Web/serverfarms and Microsoft.Web/sites in Bicep. Enable system-assigned Managed Identity on the site; reference Key Vault secrets for connection strings. Use deployment slots for staging. Run Bicep from a pipeline with approval gates for production."
  },
  {
    "question": "What is the difference between Front Door and API Management?",
    "answer": "Front Door is a global load balancer and CDN with optional WAF; it routes traffic to your backends. API Management (APIM) is an API gateway: rate limiting, authentication, transformation, developer portal. Use Front Door for global routing and caching; use APIM when you need API-level policies, versioning, or a developer portal."
  },
  {
    "question": "How do I design for high availability on Azure?",
    "answer": "Use multiple instances (App Service scale out, AKS replicas), availability zones where supported, health checks and readiness probes, and deployment slots or rolling updates for zero-downtime deploys. For Azure SQL use zone-redundant or failover groups; for Cosmos DB enable multi-region. Define RTO and RPO and test failover and rollback regularly."
  }
]
}
