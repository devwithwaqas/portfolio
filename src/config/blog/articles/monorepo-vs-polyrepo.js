/**
 * Blog article: monorepo-vs-polyrepo
 * Auto-generated by scripts/split-blog-articles.js. Do not edit the content here by hand if you run the split script again.
 */

export default {
  slug: "monorepo-vs-polyrepo",
  title: "Monorepo vs Polyrepo: Trade-offs for .NET and Microservices",
  excerpt: "Single repo vs many repos: build speed, ownership, and refactoring. When monorepo pays off and when to split.",
  date: "2025-05-12",
  topic: "Architecture",
  keywords: ["Monorepo vs Polyrepo: Trade-offs for .NET and Microservices", "Monorepo Vs Polyrepo", "Monorepo Vs Polyrepo best practices", "how to monorepo vs polyrepo", "monorepo vs polyrepo in .NET", "monorepo vs polyrepo guide", "monorepo vs polyrepo for enterprise", "monorepo vs polyrepo patterns", "when to use monorepo vs polyrepo", "monorepo vs polyrepo tutorial", "monorepo vs polyrepo examples", "monorepo vs polyrepo in C#", "monorepo vs polyrepo overview", "monorepo vs polyrepo implementation", "understanding monorepo vs polyrepo", "monorepo vs polyrepo for developers", "monorepo vs polyrepo checklist", "monorepo vs polyrepo tips", "monorepo vs polyrepo deep dive", "monorepo vs polyrepo comparison", "monorepo vs polyrepo vs alternatives", "monorepo vs polyrepo .NET Core", "monorepo vs polyrepo Azure", "monorepo vs polyrepo explained", "monorepo vs polyrepo when to use", "monorepo vs polyrepo enterprise", "monorepo vs polyrepo .NET", "what is monorepo vs polyrepo", "monorepo vs polyrepo summary", "monorepo vs polyrepo introduction", "monorepo vs polyrepo fundamentals", "monorepo vs polyrepo step by step", "monorepo vs polyrepo complete guide", "monorepo vs polyrepo for beginners", "monorepo vs polyrepo advanced", "monorepo vs polyrepo production", "monorepo vs polyrepo real world", "monorepo vs polyrepo example code", "monorepo vs polyrepo C# example", "monorepo vs polyrepo .NET example", "learn monorepo vs polyrepo", "monorepo vs polyrepo learn", "monorepo vs polyrepo reference", "monorepo vs polyrepo cheat sheet", "monorepo vs polyrepo pitfalls", "monorepo vs polyrepo common mistakes", "monorepo vs polyrepo performance", "monorepo vs polyrepo optimization", "monorepo vs polyrepo security", "monorepo vs polyrepo testing", "monorepo vs polyrepo unit test", "monorepo vs polyrepo integration", "monorepo vs polyrepo migration", "monorepo vs polyrepo from scratch", "monorepo vs polyrepo 2024", "monorepo vs polyrepo 2025", "best monorepo vs polyrepo", "monorepo vs polyrepo best", "pro monorepo vs polyrepo", "monorepo vs polyrepo expert", "monorepo vs polyrepo consultant", "monorepo vs polyrepo services", "monorepo vs polyrepo course", "monorepo vs polyrepo workshop", "monorepo vs polyrepo webinar", "monorepo vs polyrepo blog", "monorepo vs polyrepo article", "monorepo vs polyrepo post", "why monorepo vs polyrepo", "when monorepo vs polyrepo", "where monorepo vs polyrepo", "monorepo vs polyrepo in .NET 6", "monorepo vs polyrepo in .NET 7", "monorepo vs polyrepo in .NET 8", "monorepo vs polyrepo for C#", "monorepo vs polyrepo for Angular", "monorepo vs polyrepo for Vue", "monorepo vs polyrepo for React", "monorepo vs polyrepo for Azure", "monorepo vs polyrepo for microservices", "monorepo vs polyrepo for API", "monorepo vs polyrepo for database", "monorepo vs polyrepo for testing", "monorepo vs polyrepo for DevOps", "monorepo vs polyrepo for senior developers", "monorepo vs polyrepo for team", "monorepo vs polyrepo for production", "monorepo vs polyrepo for scale", "monorepo vs polyrepo for refactoring", "monorepo vs polyrepo for enterprise applications", "monorepo vs polyrepo for startup", "monorepo vs polyrepo in 2024", "monorepo vs polyrepo in 2025", "monorepo vs polyrepo in 2026", "monorepo vs polyrepo code sample", "monorepo vs polyrepo code example", "monorepo vs polyrepo sample code", "monorepo vs polyrepo full example", "monorepo vs polyrepo working example", "monorepo vs polyrepo practical monorepo vs polyrepo", "monorepo vs polyrepo real world example", "monorepo vs polyrepo use case", "monorepo vs polyrepo use cases", "monorepo vs polyrepo scenario", "monorepo vs polyrepo scenarios", "monorepo vs polyrepo pattern", "monorepo vs polyrepo approach", "monorepo vs polyrepo approaches", "monorepo vs polyrepo strategy", "monorepo vs polyrepo strategies", "monorepo vs polyrepo technique", "monorepo vs polyrepo techniques", "monorepo vs polyrepo method", "monorepo vs polyrepo methods", "monorepo vs polyrepo solution", "monorepo vs polyrepo solutions", "monorepo vs polyrepo implementation guide", "monorepo vs polyrepo getting started", "monorepo vs polyrepo quick start", "monorepo vs polyrepo overview guide", "monorepo vs polyrepo comprehensive guide", "monorepo vs polyrepo detailed guide", "monorepo vs polyrepo practical guide", "monorepo vs polyrepo developer guide", "monorepo vs polyrepo engineer guide", "monorepo vs polyrepo architect guide", "monorepo vs polyrepo for architects", "monorepo vs polyrepo for backend", "monorepo vs polyrepo for tech leads", "monorepo vs polyrepo for senior devs", "benefits of monorepo vs polyrepo", "advantages of monorepo vs polyrepo", "alternatives to monorepo vs polyrepo", "compared to monorepo vs polyrepo", "intro to monorepo vs polyrepo", "basics of monorepo vs polyrepo", "monorepo vs polyrepo tips and tricks", "monorepo vs polyrepo production-ready", "monorepo vs polyrepo enterprise-grade", "monorepo vs polyrepo with Docker", "monorepo vs polyrepo with Kubernetes", "monorepo vs polyrepo in ASP.NET Core", "monorepo vs polyrepo with Entity Framework", "monorepo vs polyrepo with EF Core", "monorepo vs polyrepo modern", "monorepo vs polyrepo updated", "monorepo vs polyrepo latest", "monorepo vs polyrepo walkthrough", "monorepo vs polyrepo hands-on", "monorepo vs polyrepo practical examples", "monorepo vs polyrepo real-world examples", "monorepo vs polyrepo common pitfalls", "monorepo vs polyrepo gotchas", "monorepo vs polyrepo FAQ", "monorepo vs polyrepo FAQs", "monorepo vs polyrepo Q&A", "monorepo vs polyrepo interview questions", "monorepo vs polyrepo interview", "monorepo vs polyrepo certification", "monorepo vs polyrepo training", "monorepo vs polyrepo video", "monorepo vs polyrepo series", "monorepo vs polyrepo part 1", "monorepo vs polyrepo core concepts", "monorepo vs polyrepo key concepts", "monorepo vs polyrepo recap", "monorepo vs polyrepo takeaways", "monorepo vs polyrepo conclusion", "monorepo vs polyrepo next steps", "monorepo vs polyrepo further reading", "monorepo vs polyrepo resources", "monorepo vs polyrepo tools", "monorepo vs polyrepo libraries", "monorepo vs polyrepo frameworks", "monorepo vs polyrepo NuGet", "monorepo vs polyrepo package", "monorepo vs polyrepo GitHub", "monorepo vs polyrepo open source", "monorepo vs polyrepo community", "monorepo vs polyrepo Microsoft docs", "monorepo vs polyrepo documentation", "monorepo vs polyrepo official guide", "monorepo vs polyrepo official tutorial", "Monorepo", "Monorepo guide", "Monorepo tutorial", "Monorepo best practices", "Monorepo in .NET", "Monorepo in C#", "Monorepo for developers", "Monorepo examples", "Monorepo patterns", "Monorepo overview", "Monorepo introduction", "Monorepo deep dive", "Monorepo explained", "Monorepo how to", "Monorepo what is", "Monorepo when to use", "Monorepo for enterprise", "Monorepo .NET Core", "Monorepo Azure", "Monorepo C#", "Monorepo with .NET", "Monorepo with C#", "Monorepo with Azure", "Monorepo with Angular", "Monorepo with Vue", "Monorepo with React", "Monorepo with Entity Framework", "Monorepo with SQL Server", "Monorepo step by step", "Monorepo complete guide", "Monorepo from scratch", "Monorepo 2024", "Monorepo 2025", "Monorepo 2026", "Monorepo code example", "Monorepo sample code", "Monorepo implementation", "Monorepo real world", "Monorepo production", "Monorepo for beginners", "Monorepo advanced", "Monorepo for architects", "Monorepo for backend", "Monorepo for API", "Monorepo in ASP.NET Core", "Monorepo with EF Core", "Monorepo tutorial 2024", "Monorepo guide 2025", "Monorepo best practices 2024", "Monorepo C# examples", "Monorepo .NET examples", "Monorepo implementation guide", "Monorepo how to implement", "Monorepo benefits", "Monorepo advantages", "Monorepo pitfalls", "Monorepo alternatives", "Monorepo compared", "Monorepo intro", "Monorepo basics", "Monorepo tips and tricks", "Monorepo production-ready", "Monorepo enterprise-grade", "Monorepo maintainable", "Monorepo testable", "Monorepo refactoring", "Monorepo modern", "Monorepo updated", "Monorepo latest", "Monorepo for tech leads", "Monorepo for senior devs", "Monorepo with Docker", "Monorepo with Kubernetes", "Monorepo in .NET 8", "Monorepo in .NET 7", "Monorepo in .NET 6", "Monorepo Vs", "Monorepo Vs guide", "Monorepo Vs tutorial", "Monorepo Vs best practices", "Monorepo Vs in .NET", "Monorepo Vs in C#", "Monorepo Vs for developers", "Monorepo Vs examples", "Monorepo Vs patterns", "Monorepo Vs overview", "Monorepo Vs introduction", "Monorepo Vs deep dive", "Monorepo Vs explained", "Monorepo Vs how to", "Monorepo Vs what is", "Monorepo Vs when to use", "Monorepo Vs for enterprise", "Monorepo Vs .NET Core", "Monorepo Vs Azure", "Monorepo Vs C#", "Monorepo Vs with .NET", "Monorepo Vs with C#", "Monorepo Vs with Azure", "Monorepo Vs with Angular", "Monorepo Vs with Vue", "Monorepo Vs with React", "Monorepo Vs with Entity Framework", "Monorepo Vs with SQL Server", "Monorepo Vs step by step", "Monorepo Vs complete guide", "Monorepo Vs from scratch", "Monorepo Vs 2024", "Monorepo Vs 2025", "Monorepo Vs 2026", "Monorepo Vs code example", "Monorepo Vs sample code", "Monorepo Vs implementation", "Monorepo Vs real world", "Monorepo Vs production", "Monorepo Vs for beginners", "Monorepo Vs advanced", "Monorepo Vs for architects", "Monorepo Vs for backend", "Monorepo Vs for API", "Monorepo Vs in ASP.NET Core", "Monorepo Vs with EF Core", "Monorepo Vs tutorial 2024", "Monorepo Vs guide 2025", "Monorepo Vs best practices 2024", "Monorepo Vs C# examples", "Monorepo Vs .NET examples", "Monorepo Vs implementation guide", "Monorepo Vs how to implement", "Monorepo Vs benefits", "Monorepo Vs advantages", "Monorepo Vs pitfalls", "Monorepo Vs alternatives", "Monorepo Vs compared", "Monorepo Vs intro", "Monorepo Vs basics", "Monorepo Vs tips and tricks", "Monorepo Vs production-ready", "Monorepo Vs enterprise-grade", "Monorepo Vs maintainable", "Monorepo Vs testable", "Monorepo Vs refactoring", "Monorepo Vs modern", "Monorepo Vs updated", "Monorepo Vs latest", "Monorepo Vs for tech leads", "Monorepo Vs for senior devs", "Monorepo Vs with Docker", "Monorepo Vs with Kubernetes", "Monorepo Vs in .NET 8", "Monorepo Vs in .NET 7", "Monorepo Vs in .NET 6", "Monorepo Vs Polyrepo how to", "Monorepo Vs Polyrepo what is", "Monorepo Vs Polyrepo C#", "Monorepo Vs Polyrepo with .NET", "Monorepo Vs Polyrepo with C#", "Monorepo Vs Polyrepo with Azure", "Monorepo Vs Polyrepo with Angular", "Monorepo Vs Polyrepo with Vue", "Monorepo Vs Polyrepo with React"],
  relatedServices: ["technical-leadership","microservices-architecture"],
  relatedProjects: ["bat-inhouse-app"],
  relatedArticleSlugs: ["azure-microservices-best-practices","ci-cd-azure-devops"],
  author: "Waqas Ahmad",
  content: `## Introduction

This guidance is relevant when the topic of this article applies to your system or design choices; it breaks down when constraints or context differ. I've applied it in real projects and refined the takeaways over time (as of 2026).

**Monorepo** and **polyrepo** describe how you organise source code across repositories. The choice affects collaboration, build speed, cross-service refactors, and CI/CD. This article explains what each is, when to use which, tooling that keeps monorepos fast, and how to scale without chaos—including in enterprise setups.

## Topics covered

- [Decision Context](#decision-context)
- [What is a monorepo?](#what-is-a-monorepo)
- [What is a polyrepo?](#what-is-a-polyrepo)
- [Monorepo vs polyrepo: side-by-side](#monorepo-vs-polyrepo-side-by-side)
- [When to choose a monorepo](#when-to-choose-a-monorepo)
- [When to choose a polyrepo](#when-to-choose-a-polyrepo)
- [Hybrid: monorepo per product, polyrepo across products](#hybrid-monorepo-for-one-product-polyrepo-across-products)
- [Tooling for monorepos](#tooling-for-monorepos-net-and-frontend)
- [Enterprise best practices](#enterprise-best-practices)
- [Common issues and challenges](#common-issues-and-challenges)
- [Summary](#summary)
- [Position & Rationale](#position--rationale)
- [Trade-Offs & Failure Modes](#trade-offs--failure-modes)
- [What Most Guides Miss](#what-most-guides-miss)
- [Decision Framework](#decision-framework)
- [Key Takeaways](#key-takeaways)
- [When I Would Use This Again — and When I Wouldn't](#when-i-would-use-this-again--and-when-i-wouldnt)
- [Frequently Asked Questions](#frequently-asked-questions)

## Decision Context

- **System scale:** One product (many projects) to many products; from a single team to many teams. Applies when you're deciding how to organise repos and shared code.
- **Team size:** One to many teams; someone must own repo structure, CI (path filters or per-repo), and shared package versioning if polyrepo. Works when the team can agree on ownership and release boundaries.
- **Time / budget pressure:** Fits greenfield and "we refactor across services often"; breaks down when there's no tooling for monorepo (affected builds, path filters)—then polyrepo or hybrid is safer.
- **Technical constraints:** Git; .NET (solutions, projects) and/or front-end (Nx, Turborepo); CI that supports path filters or per-repo builds. Assumes you can invest in build and permission tooling if monorepo.
- **Non-goals:** This article does not optimise for a single tiny repo; it focuses on monorepo vs polyrepo (and hybrid) for multi-project or multi-service setups.

## What is a monorepo?

A **monorepo** (single repository) is one **version-controlled repository** that holds **multiple projects, apps, or services**—often the whole product or a large part of it. For example, one repo might contain: a .NET Web API, several Azure Functions, a shared class library, a Vue or React frontend, and maybe mobile apps or scripts. Everyone on the team clones the **same repo**; the entire codebase lives in one place with one history.

**Why use one?** **Atomicity** and **shared code**. Rename an API or change a shared contract in one commit and one PR: API, clients, and tests update together. No "release library v2.3 then update every consumer repo"—change the library and every project that references it sees the change immediately. Refactoring and cross-service changes get simpler. For .NET, a monorepo is often one solution (\`.sln\`) with many projects: \`MyCompany.Api\`, \`MyCompany.Functions\`, \`MyCompany.Contracts\`, \`MyCompany.Frontend\`. Build and CI run against the same repo; use **path filters** or **affected build** (Nx, Turborepo, Azure Pipelines) so only changed projects build.

**Downsides.** Repo size (long clone, slow \`git status\`). Permissions are coarse unless you add \`CODEOWNERS\`, branch protection per path, or similar. Builds can be slow without incremental/affected tooling; merge conflicts can rise with many people in one repo—small PRs and good branching help.

## What is a polyrepo?

**Polyrepo** means **each service, app, or product has its own repo**: e.g. \`orders-api\`, \`billing-service\`, \`frontend\`, and shared code as **NuGet** or **npm** packages. Teams own their repo; CI/CD runs per repo—push to \`orders-api\` builds only the orders API.

**Why use it?** **Clear ownership** and **independent release cycles**. Team A owns \`orders-api\`, Team B \`billing-service\`; they release on different schedules and can use different stacks. Clones and builds are smaller and faster. Permissions are natural: repo access = team access. Fits many teams and loosely coupled domains.

**Downsides.** Cross-repo refactors are painful: release a new package version, then PRs in every consumer repo to bump and adapt. Shared code needs **NuGet**/npm (or internal feeds) and versioning. Discoverability: new joiners hunt across repos; docs and ADRs can be scattered.

## Monorepo vs polyrepo: side-by-side

| Aspect | Monorepo | Polyrepo |
|--------|----------|----------|
| **Repos** | One repo, many projects | One repo per service/app |
| **Refactors** | Atomic across codebase | Multiple PRs, version bumps |
| **Shared code** | Same repo, project references | Packages (NuGet, npm), versioning |
| **CI/CD** | One pipeline or path-filtered builds | One pipeline per repo |
| **Ownership** | Often coarse (whole repo) | Clear per repo |
| **Clone size** | Large (whole product) | Small (one service) |
| **Permissions** | Tooling needed for fine-grained | Natural (repo = boundary) |
| **Best fits** | Small/medium teams, heavy shared code | Many teams, independent domains |

## When to choose a monorepo

Choose a **monorepo** when:

- You have a **small or medium** number of services (e.g. one product: API, frontend, a few functions) and **shared libraries or contracts** change often. One repo keeps everything in sync and makes refactors atomic.
- You want a **single source of truth**: one place to run tests, lint, and see the full dependency graph. Tools like **Nx** or **Turborepo** can run only **affected** projects, so CI stays fast.
- Your **team** is one or a few squads that work across the stack. You do not need strict "team A never sees team B's code" boundaries.
- You are **greenfield** or consolidating: starting one repo is simpler than managing many repos and package versions from day one.

**Example structure (monorepo):**

\`\`\`
MyProduct/
  src/
    Api/           # ASP.NET Core Web API
    Functions/     # Azure Functions
    Contracts/     # Shared DTOs, interfaces
    Frontend/      # Vue or React app
  tests/
    Api.Tests/
    Contracts.Tests/
  .github/workflows/  # or Azure Pipelines; path filters for affected
\`\`\`

**Tooling:** Use **Nx** (with \`nx-dotnet\` or custom), **Turborepo**, or **Azure Pipelines** with path filters (e.g. only build \`src/Api\` when \`src/Api\` or \`src/Contracts\` change). This keeps build and test time under control.

## When to choose a polyrepo

Choose **polyrepo** when:

- You have **many teams** with **clear ownership** (e.g. team per service). Each team wants its own repo, release cadence, and possibly tech stack.
- **Domains** are **loosely coupled**: orders and billing do not share much code; they communicate via APIs and events. Shared code is minimal or published as versioned packages.
- You need **strict permissions**: only the billing team sees the billing repo. Monorepo would require extra tooling (e.g. CODEOWNERS, branch rules per path) to get the same effect.
- You are **integrating** with external or partner teams that contribute to specific repos; polyrepo gives a clear boundary per repo.

**Example:** \`orders-api\` repo (Team A), \`billing-service\` repo (Team B), \`shared-contracts\` repo published to NuGet; each repo has its own pipeline and release cycle.

## Hybrid: monorepo for one product, polyrepo across products

A common **hybrid** is: **one monorepo per product** (e.g. "Customer Portal" = API + frontend + shared libs in one repo), and **separate repos** for other products or shared platforms. That way you get atomic refactors and simple shared code **within** the product, and clear boundaries **between** products or teams. For .NET and microservices, this often means: monorepo for the "main" app and its services; polyrepo for internal tools, separate business units, or open-source libraries.

## Tooling for monorepos (.NET and frontend)

- **Nx:** Affected builds and caching; plugins for .NET and Node. Run only what changed: \`nx affected:build\`.
- **Turborepo:** Same idea for JavaScript/TypeScript; can sit alongside .NET in the same repo.
- **Azure Pipelines:** Use \`paths\` in the trigger so the pipeline runs only when certain folders change. Example: \`paths: include: ['src/Api/**', 'src/Contracts/**']\` so the API pipeline runs only when those change.
- **Git sparse checkout:** Clone only part of the repo to cut size (advanced).

## Enterprise best practices

- **Decide per product or domain.** One monorepo per product (e.g. Customer Portal = API + frontend + shared libs) and polyrepo for other products or shared platforms is a common enterprise pattern. Avoid "one monorepo for the whole company" unless you have Google-scale tooling and culture.
- **Permissions in a monorepo.** Use \`CODEOWNERS\` and branch protection so only the right people can merge to sensitive paths. Document who owns what; without it, everyone with repo access sees everything.
- **CI/CD.** In monorepos use path filters or affected builds so every push does not build the whole solution. In polyrepo, one pipeline per repo; shared packages go to an internal NuGet/npm feed with a clear versioning and release process.
- **Onboarding.** In a monorepo, point new joiners at one repo and a single README or doc that describes the layout. In polyrepo, maintain a **repo index** (list of repos, owners, and what each contains) so people know where to look.
- **Refactors.** In monorepo, do cross-service renames and contract changes in one PR. In polyrepo, plan a version bump of the shared package and coordinate PRs in consumer repos; use a runbook so teams know the steps.

## Common issues and challenges

**Monorepo too big.** Clone and \`git status\` slow; CI runs forever. Fix: affected/incremental builds (Nx, Turborepo, path filters), sparse checkout if needed, and trim dead code.

**Polyrepo refactor hell.** Changing a shared API means many PRs and version bumps. Fix: version shared packages clearly (semver), document the "bump and consume" process, and consider a monorepo for the set of services that change together often.

**Permissions.** Monorepo: everyone sees everything unless you add \`CODEOWNERS\` and branch rules. Polyrepo: natural per-repo access but more repos to manage. Choose the model that matches how you want to segment access.

**Merge conflicts.** More people in one repo = more conflicts. Keep PRs small, branch from main often, and use short-lived feature branches. If it becomes unmanageable, consider splitting into a few repos (hybrid) rather than one giant monorepo.

## Summary

**Monorepo** = one repo, many projects; best for atomic refactors, shared code in one place, and one pipeline with path filters. **Polyrepo** = one repo per service/app; best for many teams, independent releases, and clear ownership. In enterprise, hybrid is common: one monorepo per product, polyrepo across products. Use the FAQs below for quick reference.

## Position & Rationale

I use **monorepo** when we have a small or medium set of services and shared code that changes together often—one product, one or a few teams, and we want atomic refactors and a single source of truth. I use **polyrepo** when teams own distinct products or services and need independent release cycles and clear repo-level ownership. I prefer **hybrid** (one monorepo per product, polyrepo across products) when the organisation has multiple products but each product is a coherent set of services and front ends. I avoid monorepo without **affected build** or path filters—otherwise every push builds everything and CI slows down. I don’t choose monorepo “because Google does it” if we don’t have the tooling or discipline for large-repo workflow.

## Trade-Offs & Failure Modes

**Monorepo** sacrifices per-repo isolation and fine-grained permissions; you gain atomic changes and shared code in one place. **Polyrepo** sacrifices cross-repo refactors and forces package versioning for shared code; you gain independent releases and clear ownership. **Hybrid** adds two models to explain but can match “one product = one repo, many products = many repos.” Failure modes: monorepo without path filters (slow CI); polyrepo with shared libs that change often (version hell); merge conflicts in monorepo when PRs are large and long-lived.

## What Most Guides Miss

Most guides compare pros/cons but don’t stress that **affected build** (or path filters) is non-negotiable for monorepo—without it, CI becomes the bottleneck. Another gap: **hybrid** is underplayed; many enterprises end up with “monorepo for product A, polyrepo for the rest” and that’s a valid outcome. **Permissions** in monorepo (CODEOWNERS, branch protection per path) are often omitted; without them everyone can change everything.

## Decision Framework

- **If one product, shared code changes often, one or a few teams** → Monorepo; use path filters or affected build in CI.
- **If many teams, independent releases, clear per-service ownership** → Polyrepo; version shared packages (NuGet, npm).
- **If multiple products, each with many services** → Hybrid: one monorepo per product, polyrepo across products.
- **For monorepo** → Invest in incremental/affected builds and permissions (CODEOWNERS); keep PRs small.
- **For polyrepo** → Document shared package versioning and “bump and consume”; consider monorepo for the subset that changes together.

## Key Takeaways

- **Monorepo** = atomic refactors, shared code; need path filters or affected build. **Polyrepo** = independent releases, clear ownership; need package versioning for shared code.
- **Hybrid** (monorepo per product, polyrepo across products) is common in enterprise.
- Don’t adopt monorepo without CI that only builds what changed.
- Permissions and CODEOWNERS matter in monorepo; document release and versioning in polyrepo.

## When I Would Use This Again — and When I Wouldn't

I’d use **monorepo** again for a single product with multiple services and shared code that we refactor often, and when we have path filters or affected build in CI. I’d use **polyrepo** again when teams own distinct services and need independent releases. I’d use **hybrid** when the org has several products and each product is a natural monorepo. I wouldn’t choose monorepo without tooling for incremental builds—full rebuilds on every push don’t scale. I also wouldn’t force one model on the whole company if different products have different needs.

## Frequently Asked Questions

### What is a monorepo?

A monorepo is a single version-controlled repository that contains multiple projects, apps, or services (e.g. API, frontend, shared libs). It enables atomic refactors and shared code in one place; it requires tooling for incremental or **affected** builds (e.g. **Nx**, **Turborepo**, path filters) and often for permissions (\`CODEOWNERS\`).

### What is a polyrepo?

Polyrepo means each service or application has its own repository. It enables clear ownership and independent release cycles; cross-repo refactors and shared code require package versioning (**NuGet**, **npm**) and coordination.

### When should I use a monorepo?

Use a monorepo when you have a small or medium number of services, shared code that changes often, and one or a few teams working across the stack. It pays off when you want atomic refactors and a single source of truth.

### When should I use a polyrepo?

Use polyrepo when you have many teams with clear ownership, loosely coupled domains, and a need for independent release cycles or strict per-repo permissions.

### How do I keep monorepo builds fast?

Use **affected** or **incremental** builds: only build and test what changed. Tooling: **Nx** (\`nx affected:build\`), **Turborepo**, or **Azure Pipelines** with \`paths\` filters. Avoid building the entire solution on every commit.

### How do I share code in a polyrepo?

Publish shared code as **packages** (**NuGet** for .NET, **npm** for frontend) to a feed or registry. Consumer repos depend on package versions and bump them when needed. Use **semantic versioning** and a clear release process.

### What is a hybrid monorepo/polyrepo?

Use one monorepo **per product** (e.g. API + frontend + shared libs in one repo) and separate repos for other products or teams. You get atomic refactors within the product and clear boundaries between products.

### Does .NET work well in a monorepo?

Yes. One solution (\`.sln\`) with many projects; use **project references** for shared code. Combine with **Nx**, **Turborepo**, or **Azure Pipelines** path filters so only affected projects build. Standard .NET tooling works; you add CI logic for affected builds.

### How do I do path filtering in Azure Pipelines for a monorepo?

Use \`paths\` in the trigger or in a condition so the pipeline runs only when certain folders change. Example: \`paths: include: ['src/Api/**', 'src/Contracts/**']\` so the API pipeline runs only when those folders change.

### What are Nx and Turborepo?

**Nx** and **Turborepo** add **affected** builds and **caching** to monorepos: they compute which projects depend on changed files and run only those. Nx has .NET support; Turborepo is popular for JavaScript/TypeScript.

### How do I handle permissions in a monorepo?

Use \`CODEOWNERS\`, branch protection rules per path, or tooling (e.g. Nx boundaries) to restrict who can change which folders. Without this, everyone with repo access sees everything.

### What if we already have many repos and want to consolidate?

Plan migration (move projects into one repo, fix paths, set up new CI), communicate with teams, and consider doing it incrementally (e.g. one product at a time). Keep history (e.g. \`git subtree\` / \`git filter-repo\`) if you need it.

### Can I use both monorepo and polyrepo in the same company?

Yes. Many companies use a monorepo for one product and polyrepo for others (hybrid). Choose per product or team based on coupling and ownership.

### What are enterprise best practices for monorepo vs polyrepo?

Decide **per product or domain**: one monorepo per product, polyrepo for other products or shared platforms. Use \`CODEOWNERS\` and path-based branch protection in monorepos. In polyrepo, maintain a **repo index** (list of repos, owners, what each contains) for onboarding. Use path filters or affected builds in CI so monorepo builds stay fast.

### How do I onboard new joiners in a polyrepo?

Maintain a **repo index** (list of repos, owners, and what each repo contains) and point new joiners at it. Document the "bump and consume" process for shared packages so they know how to update dependencies across repos.`,
  faqs: [
  {
    "question": "What is a monorepo?",
    "answer": "A monorepo is a single version-controlled repository that contains multiple projects, apps, or services. It enables atomic refactors and shared code in one place; it requires tooling for incremental or affected builds and often for permissions."
  },
  {
    "question": "What is a polyrepo?",
    "answer": "Polyrepo means each service or application has its own repository. It enables clear ownership and independent release cycles; cross-repo refactors and shared code require package versioning (e.g. NuGet, npm) and coordination."
  },
  {
    "question": "When should I use a monorepo?",
    "answer": "Use a monorepo when you have a small or medium number of services, shared code that changes often, and one or a few teams working across the stack. It pays off when you want atomic refactors and a single source of truth."
  },
  {
    "question": "When should I use a polyrepo?",
    "answer": "Use polyrepo when you have many teams with clear ownership, loosely coupled domains, and a need for independent release cycles or strict per-repo permissions."
  },
  {
    "question": "How do I keep monorepo builds fast?",
    "answer": "Use affected or incremental builds: only build and test what changed. Tooling: Nx, Turborepo, or Azure Pipelines with path filters. Avoid building the entire solution on every commit."
  },
  {
    "question": "How do I share code in a polyrepo?",
    "answer": "Publish shared code as packages (NuGet for .NET, npm for frontend) to a feed or registry. Consumer repos depend on package versions and bump them when needed. Use semantic versioning and a clear release process."
  },
  {
    "question": "What is a hybrid monorepo/polyrepo?",
    "answer": "Use one monorepo per product (e.g. API + frontend + shared libs in one repo) and separate repos for other products or teams. You get atomic refactors within the product and clear boundaries between products."
  },
  {
    "question": "Does .NET work well in a monorepo?",
    "answer": "Yes. One solution (.sln) with many projects; use project references for shared code. Combine with Nx, Turborepo, or Azure Pipelines path filters so only affected projects build."
  },
  {
    "question": "How do I do path filtering in Azure Pipelines for a monorepo?",
    "answer": "Use paths in the trigger or in a condition so the pipeline runs only when certain folders change. Example: paths include ['src/Api/**', 'src/Contracts/**'] so the API pipeline runs only when those folders change."
  },
  {
    "question": "What are Nx and Turborepo?",
    "answer": "Nx and Turborepo are tools that add affected builds and caching to monorepos: they compute which projects depend on changed files and run only those projects. Nx has .NET support; Turborepo is popular for JavaScript/TypeScript."
  },
  {
    "question": "How do I handle permissions in a monorepo?",
    "answer": "Use CODEOWNERS, branch protection rules per path, or tooling (e.g. Nx boundaries) to restrict who can change which folders. Without this, everyone with repo access sees everything."
  },
  {
    "question": "What if we already have many repos and want to consolidate?",
    "answer": "Consolidation is a big change: plan migration (move projects into one repo, fix paths, set up new CI), communicate with teams, and consider doing it incrementally (e.g. one product at a time)."
  },
  {
    "question": "Can I use both monorepo and polyrepo in the same company?",
    "answer": "Yes. Many companies use a monorepo for one product and polyrepo for others (hybrid). Choose per product or team based on coupling and ownership."
  },
  {
    "question": "What are enterprise best practices for monorepo vs polyrepo?",
    "answer": "Decide per product or domain: one monorepo per product, polyrepo for other products or shared platforms. Use CODEOWNERS and path-based branch protection in monorepos. In polyrepo, maintain a repo index (list of repos, owners, what each contains) for onboarding. Use path filters or affected builds in CI so monorepo builds stay fast."
  },
  {
    "question": "How do I onboard new joiners in a polyrepo?",
    "answer": "Maintain a repo index (list of repos, owners, and what each repo contains) and point new joiners at it. Document the bump-and-consume process for shared packages so they know how to update dependencies across repos."
  }
]
}
