/**
 * Blog article: testing-strategies-unit-integration-e2e
 * Auto-generated by scripts/split-blog-articles.js. Do not edit the content here by hand if you run the split script again.
 */

export default {
  slug: "testing-strategies-unit-integration-e2e",
  title: "Testing Strategies: Unit, Integration, and E2E In-Depth",
  excerpt: "In-depth look at testing strategies: unit, integration, and e2e tests; when to use which and how to structure tests in .NET.",
  date: "2025-11-19",
  topic: "Full-Stack",
  keywords: ["Testing Strategies: Unit, Integration, and E2E In-Depth", "Testing Strategies Unit Integration E2e", "Testing Strategies Unit Integration E2e best practices", "how to testing strategies unit integration e2e", "testing strategies unit integration e2e in .NET", "testing strategies unit integration e2e guide", "testing strategies unit integration e2e for enterprise", "testing strategies unit integration e2e patterns", "when to use testing strategies unit integration e2e", "testing strategies unit integration e2e tutorial", "testing strategies unit integration e2e examples", "testing strategies unit integration e2e in C#", "testing strategies unit integration e2e overview", "testing strategies unit integration e2e implementation", "understanding testing strategies unit integration e2e", "testing strategies unit integration e2e for developers", "testing strategies unit integration e2e checklist", "testing strategies unit integration e2e tips", "testing strategies unit integration e2e deep dive", "testing strategies unit integration e2e comparison", "testing strategies unit integration e2e vs alternatives", "testing strategies unit integration e2e .NET Core", "testing strategies unit integration e2e Azure", "testing strategies unit integration e2e explained", "testing strategies unit integration e2e when to use", "testing strategies unit integration e2e enterprise", "testing strategies unit integration e2e .NET", "what is testing strategies unit integration e2e", "testing strategies unit integration e2e summary", "testing strategies unit integration e2e introduction", "testing strategies unit integration e2e fundamentals", "testing strategies unit integration e2e step by step", "testing strategies unit integration e2e complete guide", "testing strategies unit integration e2e for beginners", "testing strategies unit integration e2e advanced", "testing strategies unit integration e2e production", "testing strategies unit integration e2e real world", "testing strategies unit integration e2e example code", "testing strategies unit integration e2e C# example", "testing strategies unit integration e2e .NET example", "learn testing strategies unit integration e2e", "testing strategies unit integration e2e learn", "testing strategies unit integration e2e reference", "testing strategies unit integration e2e cheat sheet", "testing strategies unit integration e2e pitfalls", "testing strategies unit integration e2e common mistakes", "testing strategies unit integration e2e performance", "testing strategies unit integration e2e optimization", "testing strategies unit integration e2e security", "testing strategies unit integration e2e testing", "testing strategies unit integration e2e unit test", "testing strategies unit integration e2e integration", "testing strategies unit integration e2e migration", "testing strategies unit integration e2e from scratch", "testing strategies unit integration e2e 2024", "testing strategies unit integration e2e 2025", "best testing strategies unit integration e2e", "testing strategies unit integration e2e best", "pro testing strategies unit integration e2e", "testing strategies unit integration e2e expert", "testing strategies unit integration e2e consultant", "testing strategies unit integration e2e services", "testing strategies unit integration e2e course", "testing strategies unit integration e2e workshop", "testing strategies unit integration e2e webinar", "testing strategies unit integration e2e blog", "testing strategies unit integration e2e article", "testing strategies unit integration e2e post", "why testing strategies unit integration e2e", "when testing strategies unit integration e2e", "where testing strategies unit integration e2e", "testing strategies unit integration e2e in .NET 6", "testing strategies unit integration e2e in .NET 7", "testing strategies unit integration e2e in .NET 8", "testing strategies unit integration e2e for C#", "testing strategies unit integration e2e for Angular", "testing strategies unit integration e2e for Vue", "testing strategies unit integration e2e for React", "testing strategies unit integration e2e for Azure", "testing strategies unit integration e2e for microservices", "testing strategies unit integration e2e for API", "testing strategies unit integration e2e for database", "testing strategies unit integration e2e for testing", "testing strategies unit integration e2e for DevOps", "testing strategies unit integration e2e for senior developers", "testing strategies unit integration e2e for team", "testing strategies unit integration e2e for production", "testing strategies unit integration e2e for scale", "testing strategies unit integration e2e for refactoring", "testing strategies unit integration e2e for enterprise applications", "testing strategies unit integration e2e for startup", "testing strategies unit integration e2e in 2024", "testing strategies unit integration e2e in 2025", "testing strategies unit integration e2e in 2026", "testing strategies unit integration e2e code sample", "testing strategies unit integration e2e code example", "testing strategies unit integration e2e sample code", "testing strategies unit integration e2e full example", "testing strategies unit integration e2e working example", "testing strategies unit integration e2e practical testing strategies unit integration e2e", "testing strategies unit integration e2e real world example", "testing strategies unit integration e2e use case", "testing strategies unit integration e2e use cases", "testing strategies unit integration e2e scenario", "testing strategies unit integration e2e scenarios", "testing strategies unit integration e2e pattern", "testing strategies unit integration e2e approach", "testing strategies unit integration e2e approaches", "testing strategies unit integration e2e strategy", "testing strategies unit integration e2e strategies", "testing strategies unit integration e2e technique", "testing strategies unit integration e2e techniques", "testing strategies unit integration e2e method", "testing strategies unit integration e2e methods", "testing strategies unit integration e2e solution", "testing strategies unit integration e2e solutions", "testing strategies unit integration e2e implementation guide", "testing strategies unit integration e2e getting started", "testing strategies unit integration e2e quick start", "testing strategies unit integration e2e overview guide", "testing strategies unit integration e2e comprehensive guide", "testing strategies unit integration e2e detailed guide", "testing strategies unit integration e2e practical guide", "testing strategies unit integration e2e developer guide", "testing strategies unit integration e2e engineer guide", "testing strategies unit integration e2e architect guide", "testing strategies unit integration e2e for architects", "testing strategies unit integration e2e for backend", "testing strategies unit integration e2e for tech leads", "testing strategies unit integration e2e for senior devs", "benefits of testing strategies unit integration e2e", "advantages of testing strategies unit integration e2e", "alternatives to testing strategies unit integration e2e", "compared to testing strategies unit integration e2e", "intro to testing strategies unit integration e2e", "basics of testing strategies unit integration e2e", "testing strategies unit integration e2e tips and tricks", "testing strategies unit integration e2e production-ready", "testing strategies unit integration e2e enterprise-grade", "testing strategies unit integration e2e with Docker", "testing strategies unit integration e2e with Kubernetes", "testing strategies unit integration e2e in ASP.NET Core", "testing strategies unit integration e2e with Entity Framework", "testing strategies unit integration e2e with EF Core", "testing strategies unit integration e2e modern", "testing strategies unit integration e2e updated", "testing strategies unit integration e2e latest", "testing strategies unit integration e2e walkthrough", "testing strategies unit integration e2e hands-on", "testing strategies unit integration e2e practical examples", "testing strategies unit integration e2e real-world examples", "testing strategies unit integration e2e common pitfalls", "testing strategies unit integration e2e gotchas", "testing strategies unit integration e2e FAQ", "testing strategies unit integration e2e FAQs", "testing strategies unit integration e2e Q&A", "testing strategies unit integration e2e interview questions", "testing strategies unit integration e2e interview", "testing strategies unit integration e2e certification", "testing strategies unit integration e2e training", "testing strategies unit integration e2e video", "testing strategies unit integration e2e series", "testing strategies unit integration e2e part 1", "testing strategies unit integration e2e core concepts", "testing strategies unit integration e2e key concepts", "testing strategies unit integration e2e recap", "testing strategies unit integration e2e takeaways", "testing strategies unit integration e2e conclusion", "testing strategies unit integration e2e next steps", "testing strategies unit integration e2e further reading", "testing strategies unit integration e2e resources", "testing strategies unit integration e2e tools", "testing strategies unit integration e2e libraries", "testing strategies unit integration e2e frameworks", "testing strategies unit integration e2e NuGet", "testing strategies unit integration e2e package", "testing strategies unit integration e2e GitHub", "testing strategies unit integration e2e open source", "testing strategies unit integration e2e community", "testing strategies unit integration e2e Microsoft docs", "testing strategies unit integration e2e documentation", "testing strategies unit integration e2e official guide", "testing strategies unit integration e2e official tutorial", "Testing", "Testing guide", "Testing tutorial", "Testing best practices", "Testing in .NET", "Testing in C#", "Testing for developers", "Testing examples", "Testing patterns", "Testing overview", "Testing introduction", "Testing deep dive", "Testing explained", "Testing how to", "Testing what is", "Testing when to use", "Testing for enterprise"],
  relatedServices: ["full-stack-development","technical-leadership"],
  relatedProjects: ["bat-inhouse-app"],
  relatedArticleSlugs: ["full-stack-net-angular-enterprise","ci-cd-azure-devops"],
  author: "Waqas Ahmad",
  content: `## Introduction

This guidance is relevant when the topic of this article applies to your system or design choices; it breaks down when constraints or context differ. I've applied it in real projects and refined the takeaways over time (as of 2026).

Testing is essential for confidence in your code. But what kind of tests should you write? How many? The answer depends on what you are testing and what feedback you need.

This article covers the three main testing strategies: **unit tests** (fast, isolated), **integration tests** (components together), and **end-to-end tests** (full user flows). We focus on .NET with examples using xUnit, but the concepts apply to any stack.

## Topics covered

- [Decision Context](#decision-context)
- [The testing pyramid](#the-testing-pyramid)
- [Unit tests](#unit-tests)
- [Integration tests](#integration-tests)
- [End-to-end tests](#end-to-end-tests)
- [What to test at each level](#what-to-test-at-each-level)
- [Test organization](#test-organization)
- [Mocking and test doubles](#mocking-and-test-doubles)
- [Enterprise best practices](#enterprise-best-practices)
- [Common issues](#common-issues)
- [Summary](#summary)
- [Position & Rationale](#position--rationale)
- [Trade-Offs & Failure Modes](#trade-offs--failure-modes)
- [What Most Guides Miss](#what-most-guides-miss)
- [Decision Framework](#decision-framework)
- [Key Takeaways](#key-takeaways)
- [When I Would Use This Again — and When I Wouldn't](#when-i-would-use-this-again--and-when-i-wouldnt)
- [Frequently Asked Questions](#frequently-asked-questions)

## Decision Context

- **System scale:** Any application that needs reliable behaviour; from a single service to many. Applies when you’re defining or refining a testing strategy (unit, integration, E2E).
- **Team size:** Developers (and sometimes QA); someone must own test coverage, CI runs, and flakiness. Works when the team can run unit tests on every commit and integration/E2E on PR or main.
- **Time / budget pressure:** Fits when you can invest in fast unit tests and selective integration/E2E; breaks down when everything is E2E and the suite takes hours—then rebalance toward the pyramid.
- **Technical constraints:** .NET (xUnit, NUnit); in-memory or real DB for integration; real or mocked external services. Assumes you can run tests in CI and isolate flaky tests.
- **Non-goals:** This article does not optimise for a specific framework only; it focuses on the pyramid and when to use unit vs integration vs E2E.

## The testing pyramid

| Level | Speed | Scope | Count |
|-------|-------|-------|-------|
| **Unit** | Fast (ms) | Single class/method | Many |
| **Integration** | Medium (seconds) | Multiple components | Some |
| **E2E** | Slow (seconds-minutes) | Full system | Few |

**Pyramid shape:** Many unit tests at the base, fewer integration in the middle, fewest E2E at the top. Fast feedback from unit; confidence from integration and E2E.

## Unit tests

**Unit tests** verify a single unit (class, method) in isolation. Dependencies are mocked.

**Characteristics:**
- Fast (milliseconds)
- No external dependencies (DB, network, file system)
- Test business logic and edge cases
- Run on every commit

**Example: testing a discount calculator**

\`\`\`csharp
public class PercentageDiscount : IDiscountStrategy
{
    private readonly decimal _percentage;
    public PercentageDiscount(decimal percentage) => _percentage = percentage;
    public decimal Apply(decimal amount) => amount * (1 - _percentage / 100);
}

// Unit test
public class PercentageDiscountTests
{
    [Fact]
    public void Apply_TenPercent_ReturnsNinetyPercentOfAmount()
    {
        var discount = new PercentageDiscount(10);
        var result = discount.Apply(100m);
        Assert.Equal(90m, result);
    }

    [Theory]
    [InlineData(0, 100, 100)]
    [InlineData(50, 100, 50)]
    [InlineData(100, 100, 0)]
    public void Apply_VariousPercentages_ReturnsExpected(decimal pct, decimal amount, decimal expected)
    {
        var discount = new PercentageDiscount(pct);
        Assert.Equal(expected, discount.Apply(amount));
    }
}
\`\`\`

## Integration tests

**Integration tests** verify multiple components together: API + database, service + repository, etc.

**Characteristics:**
- Slower (seconds)
- Use real or test database (in-memory, container)
- Test API endpoints, repositories, message handlers
- Run in CI; may run on PR or main branch

**Example: testing an API endpoint**

\`\`\`csharp
public class OrdersControllerTests : IClassFixture<WebApplicationFactory<Program>>
{
    private readonly HttpClient _client;

    public OrdersControllerTests(WebApplicationFactory<Program> factory)
    {
        _client = factory.CreateClient();
    }

    [Fact]
    public async Task GetOrder_ExistingId_ReturnsOk()
    {
        // Arrange: seed data in test setup
        
        // Act
        var response = await _client.GetAsync("/api/orders/1");
        
        // Assert
        response.EnsureSuccessStatusCode();
        var order = await response.Content.ReadFromJsonAsync<OrderDto>();
        Assert.NotNull(order);
        Assert.Equal("1", order.Id);
    }

    [Fact]
    public async Task GetOrder_NonExistingId_ReturnsNotFound()
    {
        var response = await _client.GetAsync("/api/orders/999999");
        Assert.Equal(HttpStatusCode.NotFound, response.StatusCode);
    }
}
\`\`\`

**Using Testcontainers for real DB:**

\`\`\`csharp
public class DatabaseFixture : IAsyncLifetime
{
    private readonly MsSqlContainer _container = new MsSqlBuilder().Build();
    
    public string ConnectionString => _container.GetConnectionString();

    public async Task InitializeAsync() => await _container.StartAsync();
    public async Task DisposeAsync() => await _container.DisposeAsync();
}
\`\`\`

## End-to-end tests

**E2E tests** verify full user flows: browser → API → database.

**Characteristics:**
- Slowest (seconds to minutes)
- Full system running
- Test critical user journeys
- Keep few and stable; run nightly or on main

**Example: Playwright test**

\`\`\`csharp
public class CheckoutFlowTests : PageTest
{
    [Test]
    public async Task User_CanCompleteCheckout()
    {
        await Page.GotoAsync("https://myapp.local/");
        await Page.ClickAsync("text=Add to Cart");
        await Page.ClickAsync("text=Checkout");
        await Page.FillAsync("#email", "test@example.com");
        await Page.ClickAsync("text=Place Order");
        await Expect(Page.Locator(".order-confirmation")).ToBeVisibleAsync();
    }
}
\`\`\`

## What to test at each level

| Level | What to test |
|-------|--------------|
| **Unit** | Business logic, calculations, edge cases, validation |
| **Integration** | API contracts, DB queries, message handlers |
| **E2E** | Critical user journeys (login, checkout, signup) |

**Do not test everything at every level.** Unit tests for logic; integration for wiring; E2E for flows.

## Test organization

**Folder structure:**

\`\`\`
tests/
  MyApp.UnitTests/
    Services/
      DiscountCalculatorTests.cs
    Domain/
      OrderTests.cs
  MyApp.IntegrationTests/
    Api/
      OrdersControllerTests.cs
    Repositories/
      OrderRepositoryTests.cs
  MyApp.E2ETests/
    Flows/
      CheckoutFlowTests.cs
\`\`\`

**Naming:**
- \`MethodName_Scenario_ExpectedResult\`
- \`Should_DoSomething_When_Condition\`

## Mocking and test doubles

| Type | Description | Use |
|------|-------------|-----|
| **Mock** | Verifies calls were made | Check interactions |
| **Stub** | Returns canned responses | Provide data |
| **Fake** | Working implementation (in-memory) | Simplify tests |

**Example with Moq:**

\`\`\`csharp
[Fact]
public async Task PlaceOrder_ValidOrder_SavesAndPublishes()
{
    // Arrange
    var mockRepo = new Mock<IOrderRepository>();
    var mockPublisher = new Mock<IEventPublisher>();
    var service = new OrderService(mockRepo.Object, mockPublisher.Object);

    // Act
    await service.PlaceOrderAsync(new PlaceOrderCommand("cust-1", new List<OrderLine>()));

    // Assert
    mockRepo.Verify(r => r.AddAsync(It.IsAny<Order>(), default), Times.Once);
    mockPublisher.Verify(p => p.PublishAsync(It.IsAny<OrderPlaced>()), Times.Once);
}
\`\`\`

## Enterprise best practices

**1. Follow the pyramid.** Many unit, some integration, few E2E.

**2. Run unit tests on every commit.** Fast feedback.

**3. Run integration tests on PR.** Catch wiring issues before merge.

**4. Run E2E tests nightly or on main.** Slower but catch regressions.

**5. Use test containers for real DB.** More realistic than in-memory.

**6. Keep tests independent.** No shared state between tests.

**7. Name tests clearly.** Intent should be obvious from name.

**8. Test behavior, not implementation.** Do not over-mock; test outcomes.

## Common issues

| Issue | Cause | Fix |
|-------|-------|-----|
| **Slow tests** | Too many E2E, slow setup | More unit tests; parallelize |
| **Flaky tests** | Timing, shared state | Isolate; use deterministic data |
| **Over-mocking** | Testing mocks, not code | Test behavior; fewer mocks |
| **No tests** | Not prioritized | Start with critical paths |
| **Tests pass, bugs in prod** | Wrong level of testing | Add integration tests |
| **Hard to maintain** | Brittle assertions | Test outcomes, not implementation |

## Summary

Unit tests are fast and many; test business logic. Integration tests verify components together; test API contracts and DB queries. E2E tests are slow and few; test critical user journeys. Follow the pyramid; get fast feedback from unit, confidence from integration and E2E.

## Position & Rationale

I use **unit tests** for business logic and pure functions—fast, many, run on every commit; I mock external dependencies so we’re testing one unit. I use **integration tests** for API + DB, service + repository, or any combination that must work together; I run them on PR or main, not on every commit, and I use a real or in-memory DB so we catch contract and query issues. I use **E2E tests** sparingly for the few critical user journeys (e.g. login, checkout); they’re slow and brittle, so I keep the set small and stable. I avoid **over-mocking** in unit tests—if the test only verifies that a mock was called, we’re not testing behaviour. I don’t put everything in E2E; the pyramid exists so we get fast feedback from unit and integration and use E2E for confidence, not coverage.

## Trade-Offs & Failure Modes

**Unit tests** are fast but can miss integration bugs; **integration tests** catch more but are slower and need DB or services; **E2E tests** give confidence but are slow and flaky. **Too many E2E** and the suite takes too long; **too many mocks** and we test the wrong thing. Failure modes: flaky tests (timing, shared state)—isolate and use deterministic data; tests that pass but production fails (wrong level of testing)—add integration tests for the path that broke; brittle tests (implementation-coupled)—test outcomes, not internals.

## What Most Guides Miss

Most guides describe the pyramid but don’t stress that **integration tests** are where many bugs are caught—unit tests with mocks can pass while the real DB or API contract fails. Another gap: **what to test at each level**—unit = business rules and pure logic; integration = “does this API + DB work?”; E2E = “can the user complete this flow?” **Flakiness** is often attributed to E2E only, but shared state or timing in integration tests can cause flakiness too; isolate tests and avoid order-dependent state.

## Decision Framework

- **If testing business logic** → Unit test with mocks; keep dependencies minimal so the unit is real logic.
- **If testing that components work together** (API + DB, service + repo) → Integration test with real or in-memory dependencies.
- **If testing a critical user journey** → E2E, but keep the set small; run on PR or nightly.
- **For flakiness** → Isolate tests (no shared state); use deterministic data; fix or quarantine flaky tests quickly.
- **For coverage** → Prefer many unit tests, enough integration to cover main paths, few E2E for critical flows.

## Key Takeaways

- **Unit** = fast, many, business logic; **integration** = API + DB, contracts; **E2E** = few, critical journeys.
- Follow the **pyramid**: more unit, some integration, few E2E.
- Avoid over-mocking (testing mocks, not behaviour); add integration tests for paths that matter.
- Isolate tests and fix flakiness; test outcomes, not implementation.

## When I Would Use This Again — and When I Wouldn't

I’d use **unit tests** again for all non-trivial business logic—fast feedback on every commit. I’d use **integration tests** again for API and DB and for any boundary where the contract matters. I’d use **E2E** again only for the few critical flows that must not break. I wouldn’t rely only on unit tests with heavy mocks and no integration tests; real integration bugs will slip through. I also wouldn’t grow the E2E suite without bound; keep it small and stable so it stays runnable and meaningful.

## Frequently Asked Questions

### What is a unit test?

**Unit test** verifies a single class or method in isolation with mocked dependencies. Fast, runs on every commit.

### What is an integration test?

**Integration test** verifies multiple components together (API + DB, service + repository). Slower, runs on PR or main.

### What is an E2E test?

**E2E test** verifies full user flow (browser → API → DB). Slowest, tests critical journeys, runs nightly.

### How many tests at each level?

**Pyramid:** Many unit, some integration, few E2E. Fast feedback from unit; confidence from higher levels.

### What should I test with unit tests?

Business logic, calculations, validation, edge cases. Anything that does not need external systems.

### What should I test with integration tests?

API endpoints, database queries, message handlers. Components working together.

### What should I test with E2E?

Critical user journeys: login, checkout, signup. The paths users actually take.

### How do I mock dependencies?

Use **Moq**, **NSubstitute**, or similar. Create fake implementations for complex dependencies.

### Should I use in-memory DB or real DB?

**Real DB (via containers)** is more realistic. In-memory is faster but may miss issues.

### How do I organize tests?

Separate projects: UnitTests, IntegrationTests, E2ETests. Mirror source structure.

### What is a flaky test?

Test that passes sometimes, fails sometimes. Caused by timing, shared state, or external dependencies.

### How do I fix flaky tests?

Isolate tests, use deterministic data, avoid timing dependencies, parallelize carefully.

### Should I mock the database?

For unit tests, mock repository interface. For integration tests, use real or test DB.

### What is test coverage?

Percentage of code executed by tests. Useful metric but do not chase 100%; focus on critical paths.

### How do I test async code?

Use \`async Task\` test methods. Await the code under test. xUnit and NUnit support async.`,
  faqs: [
  {
    "question": "What is a unit test?",
    "answer": "Verifies single class/method in isolation with mocks. Fast, runs on every commit."
  },
  {
    "question": "What is an integration test?",
    "answer": "Verifies multiple components together (API + DB). Slower, runs on PR or main."
  },
  {
    "question": "What is an E2E test?",
    "answer": "Verifies full user flow (browser → API → DB). Slowest, tests critical journeys."
  },
  {
    "question": "How many tests at each level?",
    "answer": "Pyramid: many unit, some integration, few E2E."
  },
  {
    "question": "What test with unit?",
    "answer": "Business logic, calculations, validation, edge cases."
  },
  {
    "question": "What test with integration?",
    "answer": "API endpoints, DB queries, message handlers."
  },
  {
    "question": "What test with E2E?",
    "answer": "Critical user journeys: login, checkout, signup."
  },
  {
    "question": "How mock dependencies?",
    "answer": "Use Moq, NSubstitute. Create fakes for complex dependencies."
  },
  {
    "question": "In-memory or real DB?",
    "answer": "Real DB (containers) is more realistic. In-memory is faster but may miss issues."
  },
  {
    "question": "How organize tests?",
    "answer": "Separate projects: UnitTests, IntegrationTests, E2ETests."
  },
  {
    "question": "What is flaky test?",
    "answer": "Passes sometimes, fails sometimes. Caused by timing or shared state."
  },
  {
    "question": "How fix flaky tests?",
    "answer": "Isolate, deterministic data, avoid timing dependencies."
  },
  {
    "question": "Mock the database?",
    "answer": "Unit: mock repo interface. Integration: use real or test DB."
  },
  {
    "question": "What is test coverage?",
    "answer": "Percentage of code executed by tests. Focus on critical paths, not 100%."
  },
  {
    "question": "How test async code?",
    "answer": "Use async Task methods. Await code under test. xUnit supports async."
  }
]
}
