/**
 * Blog article: solid-principles-in-practice
 * Auto-generated by scripts/split-blog-articles.js. Do not edit the content here by hand if you run the split script again.
 */

export default {
  slug: "solid-principles-in-practice",
  title: "SOLID Principles in Practice: .NET Examples",
  excerpt: "In-depth look at SOLID with .NET: Single Responsibility, Open/Closed, Liskov, Interface Segregation, Dependency Inversion—what each is, when to use it, before/after code, enterprise practices, and FAQs.",
  date: "2025-09-29",
  topic: "Architecture",
  keywords: ["SOLID Principles in Practice: .NET Examples", "Solid Principles In Practice", "Solid Principles In Practice best practices", "how to solid principles in practice", "solid principles in practice in .NET", "solid principles in practice guide", "solid principles in practice for enterprise", "solid principles in practice patterns", "when to use solid principles in practice", "solid principles in practice tutorial", "solid principles in practice examples", "solid principles in practice in C#", "solid principles in practice overview", "solid principles in practice implementation", "understanding solid principles in practice", "solid principles in practice for developers", "solid principles in practice checklist", "solid principles in practice tips", "solid principles in practice deep dive", "solid principles in practice comparison", "solid principles in practice vs alternatives", "solid principles in practice .NET Core", "solid principles in practice Azure", "solid principles in practice explained", "solid principles in practice when to use", "solid principles in practice enterprise", "solid principles in practice .NET", "what is solid principles in practice", "solid principles in practice summary", "solid principles in practice introduction", "solid principles in practice fundamentals", "solid principles in practice step by step", "solid principles in practice complete guide", "solid principles in practice for beginners", "solid principles in practice advanced", "solid principles in practice production", "solid principles in practice real world", "solid principles in practice example code", "solid principles in practice C# example", "solid principles in practice .NET example", "learn solid principles in practice", "solid principles in practice learn", "solid principles in practice reference", "solid principles in practice cheat sheet", "solid principles in practice pitfalls", "solid principles in practice common mistakes", "solid principles in practice performance", "solid principles in practice optimization", "solid principles in practice security", "solid principles in practice testing", "solid principles in practice unit test", "solid principles in practice integration", "solid principles in practice migration", "solid principles in practice from scratch", "solid principles in practice 2024", "solid principles in practice 2025", "best solid principles in practice", "solid principles in practice best", "pro solid principles in practice", "solid principles in practice expert", "solid principles in practice consultant", "solid principles in practice services", "solid principles in practice course", "solid principles in practice workshop", "solid principles in practice webinar", "solid principles in practice blog", "solid principles in practice article", "solid principles in practice post", "why solid principles in practice", "when solid principles in practice", "where solid principles in practice", "solid principles in practice in .NET 6", "solid principles in practice in .NET 7", "solid principles in practice in .NET 8", "solid principles in practice for C#", "solid principles in practice for Angular", "solid principles in practice for Vue", "solid principles in practice for React", "solid principles in practice for Azure", "solid principles in practice for microservices", "solid principles in practice for API", "solid principles in practice for database", "solid principles in practice for testing", "solid principles in practice for DevOps", "solid principles in practice for senior developers", "solid principles in practice for team", "solid principles in practice for production", "solid principles in practice for scale", "solid principles in practice for refactoring", "solid principles in practice for enterprise applications", "solid principles in practice for startup", "solid principles in practice in 2024", "solid principles in practice in 2025", "solid principles in practice in 2026", "solid principles in practice code sample", "solid principles in practice code example", "solid principles in practice sample code", "solid principles in practice full example", "solid principles in practice working example", "solid principles in practice practical solid principles in practice", "solid principles in practice real world example", "solid principles in practice use case", "solid principles in practice use cases", "solid principles in practice scenario", "solid principles in practice scenarios", "solid principles in practice pattern", "solid principles in practice approach", "solid principles in practice approaches", "solid principles in practice strategy", "solid principles in practice strategies", "solid principles in practice technique", "solid principles in practice techniques", "solid principles in practice method", "solid principles in practice methods", "solid principles in practice solution", "solid principles in practice solutions", "solid principles in practice implementation guide", "solid principles in practice getting started", "solid principles in practice quick start", "solid principles in practice overview guide", "solid principles in practice comprehensive guide", "solid principles in practice detailed guide", "solid principles in practice practical guide", "solid principles in practice developer guide", "solid principles in practice engineer guide", "solid principles in practice architect guide", "solid principles in practice for architects", "solid principles in practice for backend", "solid principles in practice for tech leads", "solid principles in practice for senior devs", "benefits of solid principles in practice", "advantages of solid principles in practice", "alternatives to solid principles in practice", "compared to solid principles in practice", "intro to solid principles in practice", "basics of solid principles in practice", "solid principles in practice tips and tricks", "solid principles in practice production-ready", "solid principles in practice enterprise-grade", "solid principles in practice with Docker", "solid principles in practice with Kubernetes", "solid principles in practice in ASP.NET Core", "solid principles in practice with Entity Framework", "solid principles in practice with EF Core", "solid principles in practice modern", "solid principles in practice updated", "solid principles in practice latest", "solid principles in practice walkthrough", "solid principles in practice hands-on", "solid principles in practice practical examples", "solid principles in practice real-world examples", "solid principles in practice common pitfalls", "solid principles in practice gotchas", "solid principles in practice FAQ", "solid principles in practice FAQs", "solid principles in practice Q&A", "solid principles in practice interview questions", "solid principles in practice interview", "solid principles in practice certification", "solid principles in practice training", "solid principles in practice video", "solid principles in practice series", "solid principles in practice part 1", "solid principles in practice core concepts", "solid principles in practice key concepts", "solid principles in practice recap", "solid principles in practice takeaways", "solid principles in practice conclusion", "solid principles in practice next steps", "solid principles in practice further reading", "solid principles in practice resources", "solid principles in practice tools", "solid principles in practice libraries", "solid principles in practice frameworks", "solid principles in practice NuGet", "solid principles in practice package", "solid principles in practice GitHub", "solid principles in practice open source", "solid principles in practice community", "solid principles in practice Microsoft docs", "solid principles in practice documentation", "solid principles in practice official guide", "solid principles in practice official tutorial", "Solid", "Solid guide", "Solid tutorial", "Solid best practices", "Solid in .NET", "Solid in C#", "Solid for developers", "Solid examples", "Solid patterns", "Solid overview", "Solid introduction", "Solid deep dive", "Solid explained", "Solid how to", "Solid what is", "Solid when to use", "Solid for enterprise", "Solid .NET Core", "Solid Azure", "Solid C#", "Solid with .NET", "Solid with C#", "Solid with Azure", "Solid with Angular", "Solid with Vue", "Solid with React", "Solid with Entity Framework", "Solid with SQL Server", "Solid step by step", "Solid complete guide", "Solid from scratch", "Solid 2024", "Solid 2025", "Solid 2026", "Solid code example", "Solid sample code", "Solid implementation", "Solid real world", "Solid production", "Solid for beginners", "Solid advanced", "Solid for architects", "Solid for backend", "Solid for API", "Solid in ASP.NET Core", "Solid with EF Core", "Solid tutorial 2024", "Solid guide 2025", "Solid best practices 2024", "Solid C# examples", "Solid .NET examples", "Solid implementation guide", "Solid how to implement", "Solid benefits", "Solid advantages", "Solid pitfalls", "Solid alternatives", "Solid compared", "Solid intro", "Solid basics", "Solid tips and tricks", "Solid production-ready", "Solid enterprise-grade", "Solid maintainable", "Solid testable", "Solid refactoring", "Solid modern", "Solid updated", "Solid latest", "Solid for tech leads", "Solid for senior devs", "Solid with Docker", "Solid with Kubernetes", "Solid in .NET 8", "Solid in .NET 7", "Solid in .NET 6", "Solid Principles", "Solid Principles guide", "Solid Principles tutorial", "Solid Principles best practices", "Solid Principles in .NET", "Solid Principles in C#", "Solid Principles for developers", "Solid Principles examples", "Solid Principles patterns", "Solid Principles overview", "Solid Principles introduction", "Solid Principles deep dive", "Solid Principles explained", "Solid Principles how to", "Solid Principles what is", "Solid Principles when to use", "Solid Principles for enterprise", "Solid Principles .NET Core", "Solid Principles Azure", "Solid Principles C#", "Solid Principles with .NET", "Solid Principles with C#", "Solid Principles with Azure", "Solid Principles with Angular", "Solid Principles with Vue", "Solid Principles with React", "Solid Principles with Entity Framework", "Solid Principles with SQL Server", "Solid Principles step by step", "Solid Principles complete guide", "Solid Principles from scratch", "Solid Principles 2024", "Solid Principles 2025", "Solid Principles 2026", "Solid Principles code example", "Solid Principles sample code", "Solid Principles implementation", "Solid Principles real world", "Solid Principles production", "Solid Principles for beginners", "Solid Principles advanced", "Solid Principles for architects", "Solid Principles for backend", "Solid Principles for API", "Solid Principles in ASP.NET Core", "Solid Principles with EF Core", "Solid Principles tutorial 2024", "Solid Principles guide 2025", "Solid Principles best practices 2024", "Solid Principles C# examples", "Solid Principles .NET examples", "Solid Principles implementation guide", "Solid Principles how to implement", "Solid Principles benefits", "Solid Principles advantages", "Solid Principles pitfalls", "Solid Principles alternatives", "Solid Principles compared", "Solid Principles intro", "Solid Principles basics", "Solid Principles tips and tricks", "Solid Principles production-ready", "Solid Principles enterprise-grade", "Solid Principles maintainable", "Solid Principles testable", "Solid Principles refactoring", "Solid Principles modern", "Solid Principles updated", "Solid Principles latest", "Solid Principles for tech leads", "Solid Principles for senior devs", "Solid Principles with Docker", "Solid Principles with Kubernetes", "Solid Principles in .NET 8", "Solid Principles in .NET 7", "Solid Principles in .NET 6", "Solid Principles In", "Solid Principles In guide", "Solid Principles In tutorial", "Solid Principles In best practices", "Solid Principles In in .NET", "Solid Principles In in C#", "Solid Principles In for developers", "Solid Principles In examples", "Solid Principles In patterns", "Solid Principles In overview", "Solid Principles In introduction", "Solid Principles In deep dive", "Solid Principles In explained", "Solid Principles In how to", "Solid Principles In what is", "Solid Principles In when to use", "Solid Principles In for enterprise", "Solid Principles In .NET Core", "Solid Principles In Azure", "Solid Principles In with .NET", "Solid Principles In with C#", "Solid Principles In with Azure", "Solid Principles In with Angular", "Solid Principles In with Vue", "Solid Principles In with React", "Solid Principles In with Entity Framework", "Solid Principles In with SQL Server", "Solid Principles In step by step", "Solid Principles In complete guide", "Solid Principles In from scratch", "Solid Principles In 2024", "Solid Principles In 2025", "Solid Principles In 2026", "Solid Principles In code example", "Solid Principles In sample code", "Solid Principles In implementation", "Solid Principles In real world", "Solid Principles In production", "Solid Principles In for beginners", "Solid Principles In advanced", "Solid Principles In for architects", "Solid Principles In for backend", "Solid Principles In for API", "Solid Principles In in ASP.NET Core"],
  relatedServices: ["full-stack-development","technical-leadership"],
  relatedProjects: ["bat-inhouse-app"],
  relatedArticleSlugs: ["clean-architecture-dotnet","full-stack-net-angular-enterprise"],
  author: "Waqas Ahmad",
  content: `## Introduction

This guidance is relevant when you are designing or refactoring object-oriented code in .NET and care about testability, change isolation, and clear dependencies. It breaks down when the codebase is procedural, short-lived, or when the team has no appetite for interfaces and DI. I've applied SOLID in contexts where multiple developers touch the same domain, where tests and swapping implementations matter, and where the code is expected to evolve (as of 2026).

**SOLID** is five principles for **object-oriented design** that help you write **maintainable**, **testable**, and **resilient** code. They are: **S**ingle Responsibility, **O**pen/Closed, **L**iskov Substitution, **I**nterface Segregation, and **D**ependency Inversion. Applied well, they reduce coupling, make extension easier, and keep each class focused. This article covers **each principle in depth** with **.NET** examples: what it is, when to use it, **before and after** code, **step-by-step** refactors, and how it fits into real applications. Each section follows a clear sequence: definition, why it matters, then implementation with full C# examples.

If you are new to SOLID, start with [Topics covered](#topics-covered) and [SOLID at a glance](#solid-at-a-glance).

## Topics covered

- [Decision Context](#decision-context)
- [What is SOLID and why it matters](#what-is-solid-and-why-it-matters)
- [SOLID at a glance](#solid-at-a-glance)
- [Single Responsibility (SRP)](#single-responsibility-srp)
- [Open/Closed (OCP)](#open-closed-ocp)
- [Liskov Substitution (LSP)](#liskov-substitution-lsp)
- [Interface Segregation (ISP)](#interface-segregation-isp)
- [Dependency Inversion (DIP)](#dependency-inversion-dip)
- [Enterprise practices](#enterprise-practices)
- [When to relax SOLID](#when-to-relax-solid)
- [Position & Rationale](#position--rationale)
- [Trade-Offs & Failure Modes](#trade-offs--failure-modes)
- [What Most Guides Miss](#what-most-guides-miss)
- [Decision Framework](#decision-framework)
- [Key Takeaways](#key-takeaways)
- [Summary](#summary)
- [When I Would Use This Again — and When I Wouldn't](#when-i-would-use-this-again--and-when-i-wouldnt)
- [Frequently Asked Questions](#frequently-asked-questions)

---

## Decision Context

- **System scale:** Codebases from a few thousand to hundreds of thousands of lines; multiple services or modules. SOLID pays off when multiple people change the same area.
- **Team size:** One developer can benefit; the gains multiply when several developers work on the same domain and need clear boundaries and test doubles.
- **Time / budget pressure:** Applying SOLID in greenfield is easier than retrofitting; refactors take time. I've introduced SOLID gradually (DIP and SRP first) when under delivery pressure.
- **Technical constraints:** .NET and C#; DI container and interface-based design. Not tied to a specific framework version (as of 2026, .NET 6+ is the typical baseline).
- **Non-goals:** Not optimizing for minimal lines of code or for one-off scripts; not claiming SOLID is always the right choice for every class.

---

## What is SOLID and why it matters

**SOLID** is a set of five design principles introduced by Robert C. Martin (Uncle Bob). They guide how you **structure classes and dependencies** so that:

- **Change** is local (one reason to change per class).
- **Extension** happens by adding new code, not by editing existing code.
- **Subtypes** can replace base types without breaking callers.
- **Clients** depend only on what they use (small interfaces).
- **High-level** code does not depend on low-level details (abstractions).

**Why it matters:** Code that follows SOLID is easier to **test** (small, focused units; injectable dependencies), **extend** (new behavior via new types), and **maintain** (changes are isolated). Violations often lead to large, brittle classes and tight coupling.

---

## SOLID at a glance

| Principle | One-line idea | .NET approach |
|-----------|----------------|----------------|
| **S**ingle Responsibility | One reason to change per class | Split validation, persistence, notification into separate classes |
| **O**pen/Closed | Open for extension, closed for modification | Use interfaces and new implementations; avoid switch on type |
| **L**iskov Substitution | Subtypes substitutable for base | Do not weaken preconditions or strengthen postconditions; no surprise throws |
| **I**nterface Segregation | Clients do not depend on unused methods | Small interfaces: IReadOrders, IWriteOrders instead of one fat interface |
| **D**ependency Inversion | Depend on abstractions | Depend on IOrderRepository; inject implementation via DI |

---

## Single Responsibility (SRP)

### What it is and why it matters

**Single Responsibility:** A class should have **one reason to change**. If one class does both "validate order" and "send confirmation email", then a change in validation rules or in email logic forces you to touch the same class. That increases the risk of regressions and makes testing harder. **Split** so that each class has one clear responsibility: one for validation, one for persistence, one for notification.

### Before (multiple responsibilities)

\`\`\`csharp
public class OrderService
{
    public void PlaceOrder(Order order)
    {
        if (order.Total <= 0) throw new ArgumentException("Invalid total");
        if (order.Items.Count == 0) throw new ArgumentException("No items");
        _db.Orders.Add(order);
        _db.SaveChanges();
        _smtp.Send(order.CustomerEmail, "Order confirmed", $"Order {order.Id} placed.");
    }
}
\`\`\`

**Problems:** Validation, persistence, and notification are in one class. Changing validation rules, DB access, or email logic all touch \`OrderService\`.

### After (single responsibility)

\`\`\`csharp
public class OrderValidator
{
    public void Validate(Order order)
    {
        if (order.Total <= 0) throw new ArgumentException("Invalid total");
        if (order.Items.Count == 0) throw new ArgumentException("No items");
    }
}

public class OrderRepository : IOrderRepository
{
    public void Add(Order order) { /* persist */ }
}

public class OrderNotificationService : IOrderNotificationService
{
    public void SendConfirmation(Order order) { /* email */ }
}

public class OrderService
{
    private readonly IOrderValidator _validator;
    private readonly IOrderRepository _repo;
    private readonly IOrderNotificationService _notification;

    public OrderService(IOrderValidator v, IOrderRepository r, IOrderNotificationService n)
    {
        _validator = v; _repo = r; _notification = n;
    }

    public void PlaceOrder(Order order)
    {
        _validator.Validate(order);
        _repo.Add(order);
        _notification.SendConfirmation(order);
    }
}
\`\`\`

**How this fits together:** \`OrderService\` **orchestrates**; it has one job (place order flow). Validation, persistence, and notification each live in their own class with one reason to change. You can test \`OrderValidator\` in isolation, swap email for SMS by replacing \`IOrderNotificationService\`, and change persistence without touching validation.

---

## Open/Closed (OCP)

### What it is and why it matters

**Open/Closed:** Software should be **open for extension** (add new behavior) but **closed for modification** (avoid changing existing code). Add new behavior by **adding new code** (e.g. new class, new strategy) rather than editing existing classes. Use **interfaces** and **dependency injection** so new implementations can be plugged in without changing callers.

### Before (modification required for each new type)

\`\`\`csharp
public decimal GetDiscount(Order order)
{
    if (order.CustomerType == "Standard") return order.Total * 0m;
    if (order.CustomerType == "Premium") return order.Total * 0.1m;
    if (order.CustomerType == "Gold") return order.Total * 0.2m;
    throw new NotSupportedException();
}
\`\`\`

**Problems:** Adding a new customer type (e.g. "Platinum") forces you to **modify** this method and retest all branches.

### After (extension via new implementations)

\`\`\`csharp
public interface IDiscountStrategy
{
    decimal GetDiscount(Order order);
}

public class StandardDiscountStrategy : IDiscountStrategy
{
    public decimal GetDiscount(Order order) => 0m;
}

public class PremiumDiscountStrategy : IDiscountStrategy
{
    public decimal GetDiscount(Order order) => order.Total * 0.1m;
}

public class GoldDiscountStrategy : IDiscountStrategy
{
    public decimal GetDiscount(Order order) => order.Total * 0.2m;
}

// New type: add new class, register in DI; no change to existing code
public class PlatinumDiscountStrategy : IDiscountStrategy
{
    public decimal GetDiscount(Order order) => order.Total * 0.25m;
}

public class OrderDiscountService
{
    private readonly IReadOnlyDictionary<string, IDiscountStrategy> _strategies;
    public OrderDiscountService(IEnumerable<IDiscountStrategy> strategies) { /* build map by type */ }
    public decimal GetDiscount(Order order) => _strategies[order.CustomerType].GetDiscount(order);
}
\`\`\`

**How this fits together:** New behavior = **new class** implementing \`IDiscountStrategy\` and registered in DI. Existing \`OrderDiscountService\` and existing strategies are **unchanged**. You are **extending** by adding code, not **modifying** existing code.

---

## Liskov Substitution (LSP)

### What it is and why it matters

**Liskov Substitution:** Subtypes must be **substitutable** for their base types. If \`B\` extends \`A\`, any code that expects \`A\` should work with \`B\` without knowing the difference. Do not **weaken preconditions** (require more from callers) or **strengthen postconditions** (guarantee less). Do not **throw** in cases the base type does not (or change semantics so callers break).

### Violation example (Rectangle and Square)

\`\`\`csharp
public class Rectangle
{
    public virtual int Width { get; set; }
    public virtual int Height { get; set; }
    public int Area => Width * Height;
}

public class Square : Rectangle
{
    public override int Width { set { base.Width = value; base.Height = value; } }
    public override int Height { set { base.Height = value; base.Width = value; } }
}
\`\`\`

**Problem:** Code that expects \`Rectangle\` might set \`Width\` and \`Height\` independently (e.g. \`r.Width = 4; r.Height = 5;\`). With \`Square\`, setting one changes the other, so \`Area\` and behavior surprise the caller. **Substitution** breaks.

### Better design (no inheritance that breaks contract)

- Do **not** make \`Square\` inherit \`Rectangle\` if it changes the contract (independent width/height).
- Or expose a **common interface** (e.g. \`IShape\` with \`Area\`) and have \`Rectangle\` and \`Square\` as separate implementations. Callers depend on \`IShape\`; both are substitutable for that contract.

\`\`\`csharp
public interface IShape { int Area { get; } }
public class Rectangle : IShape { public int Width { get; set; } public int Height { get; set; } public int Area => Width * Height; }
public class Square : IShape { public int Side { get; set; } public int Area => Side * Side; }
\`\`\`

**How this fits together:** Subtypes must honor the **contract** of the base (or interface). If the base allows setting width and height independently, a subtype cannot silently couple them. Either do not inherit, or use an interface that only exposes what is truly common (e.g. \`Area\`).

---

## Interface Segregation (ISP)

### What it is and why it matters

**Interface Segregation:** Clients should not depend on **interfaces they do not use**. Prefer **small, focused interfaces** (e.g. \`IReadOrders\`, \`IWriteOrders\`) over one large interface so that implementers are not forced to provide unused methods and callers depend only on what they need.

### Before (fat interface)

\`\`\`csharp
public interface IOrderService
{
    Order GetById(int id);
    IReadOnlyList<Order> GetByCustomer(string customerId);
    void Add(Order order);
    void Update(Order order);
    void Delete(int id);
}

// Reporter only needs read; but must depend on full IOrderService
public class OrderReporter
{
    private readonly IOrderService _orders;
    public OrderReporter(IOrderService orders) => _orders = orders;
    public Report Generate() => new Report(_orders.GetByCustomer("C1"));
}
\`\`\`

**Problems:** \`OrderReporter\` only needs **read** operations but depends on \`IOrderService\` with write methods. Any implementation (e.g. stub for tests) must implement all methods. Changes to write contract can affect read-only clients.

### After (segregated interfaces)

\`\`\`csharp
public interface IReadOrders
{
    Order GetById(int id);
    IReadOnlyList<Order> GetByCustomer(string customerId);
}

public interface IWriteOrders
{
    void Add(Order order);
    void Update(Order order);
    void Delete(int id);
}

public interface IOrderService : IReadOrders, IWriteOrders { }

public class OrderReporter
{
    private readonly IReadOrders _orders;
    public OrderReporter(IReadOrders orders) => _orders = orders;
    public Report Generate() => new Report(_orders.GetByCustomer("C1"));
}
\`\`\`

**How this fits together:** Callers that only read depend on \`IReadOrders\`; callers that write depend on \`IWriteOrders\` (or \`IOrderService\`). Implementations can provide only \`IReadOrders\` (e.g. read-only replica) or both. Tests can stub \`IReadOrders\` with just the read methods. **No client is forced to depend on methods it does not use.**

---

## Dependency Inversion (DIP)

### What it is and why it matters

**Dependency Inversion:** High-level modules should not depend on low-level modules; both should depend on **abstractions**. In practice: depend on **interfaces** (e.g. \`IOrderRepository\`), not concrete types (e.g. \`SqlOrderRepository\`). **Dependency injection** implements DIP: the container provides the concrete implementation; your code depends only on the interface.

### Before (dependency on concretion)

\`\`\`csharp
public class OrderService
{
    private readonly SqlOrderRepository _repo = new SqlOrderRepository();

    public Order Get(int id) => _repo.GetById(id);
}
\`\`\`

**Problems:** \`OrderService\` is **tightly coupled** to \`SqlOrderRepository\`. You cannot unit test with a fake repository or switch to a different storage without changing \`OrderService\`.

### After (depend on abstraction, inject implementation)

\`\`\`csharp
public interface IOrderRepository
{
    Order GetById(int id);
    void Add(Order order);
}

public class OrderService
{
    private readonly IOrderRepository _repo;

    public OrderService(IOrderRepository repo) => _repo = repo;

    public Order Get(int id) => _repo.GetById(id);
}

// Registration (Program.cs)
builder.Services.AddScoped<IOrderRepository, SqlOrderRepository>();
\`\`\`

**How this fits together:** \`OrderService\` depends only on \`IOrderRepository\`. The **container** provides \`SqlOrderRepository\` (or a mock in tests). High-level (\`OrderService\`) and low-level (\`SqlOrderRepository\`) both depend on the **abstraction** \`IOrderRepository\`. You can swap implementations without changing \`OrderService\`.

---

## Enterprise practices

1. **Apply SRP at the class and module level.** One class = one reason to change; one module = one cohesive area (e.g. ordering, billing).
2. **Use OCP for variation.** When you have multiple "types" of behavior (discounts, payment methods, handlers), use **interfaces + implementations** and **DI** so new behavior is added by new code.
3. **Design for LSP when using inheritance.** Prefer **composition** over inheritance when substitution is unclear; use **interfaces** to define contracts that subtypes must honor.
4. **Segregate interfaces by client need.** If a client only reads, give it \`IReadX\`. Avoid fat interfaces that force implementers to throw \`NotSupportedException\` for unused methods.
5. **Depend on abstractions everywhere.** Controllers and services depend on \`IOrderRepository\`, \`IOrderService\`, etc. Register implementations in DI; use the composition root to wire concretions.

---

## When to relax SOLID

- **Simple code or prototypes** – Over-abstracting a 50-line script can slow you down. Apply SOLID when the code will **evolve** or be **tested**.
- **Performance-critical paths** – Sometimes a single class or inline logic is clearer and faster; document the trade-off.
- **Stable, unlikely-to-change code** – If a small module will never change, strict SRP/OCP may not pay off.
- **Do not use SOLID as an excuse for over-engineering** – Prefer the **simplest** design that meets SRP, OCP, LSP, ISP, DIP where they add value. KISS and YAGNI still apply.

---

## Summary

**SOLID** is five principles: **Single Responsibility** (one reason to change per class), **Open/Closed** (extend by new code, not modification), **Liskov Substitution** (subtypes substitutable for base), **Interface Segregation** (small, focused interfaces), **Dependency Inversion** (depend on abstractions, inject implementations). In **.NET**, apply them with **interfaces**, **dependency injection**, **strategy-style** extensions, and **focused** classes. This article covered each principle with before/after .NET examples, enterprise practices, and when to relax SOLID.

---


---

## Position & Rationale

I apply SOLID when the codebase will be touched by more than one person, when we need unit tests with mocks, or when we expect to swap implementations (e.g. another repository, another notification channel). I don't treat it as dogma for every class—sometimes a small, stable module doesn't need five interfaces. The rationale here is testability and change isolation: if you can't test a use case without the real DB, or you can't add a new discount type without editing three places, SOLID (especially DIP and OCP) gives you a path. I've used it in .NET for domain and application layers; infrastructure and presentation implement the interfaces and get wired in the composition root.

---

## Trade-Offs & Failure Modes

- **What you give up:** More files, more interfaces, more indirection. Onboarding takes longer until people internalise "one reason to change" and "depend on abstractions." You also pay in upfront design—figuring out the right interface boundaries.
- **Where it goes wrong:** When nobody enforces the boundaries. One "god" service that does validation, persistence, and notification "because it's easier." Or interfaces that leak implementation details (e.g. \`SaveOrder(Order, SqlConnection)\`). Another failure: applying SOLID to every single class in a tiny app so you end up with 20 interfaces and no second implementation.
- **How it fails when misapplied:** Adding interfaces "for SOLID" with only one implementation and no tests that use the abstraction. Or the opposite—refusing to split a 2,000-line class because "SRP is overkill." Early warning signs: "we have SOLID but our domain still references \`DbContext\`"; "we're not sure if this is application or infrastructure"; "every new feature touches the same three files."
- **Early warning signs:** High-level code depending on concrete types; tests that need the real database; one class with five reasons to change and nobody wants to touch it.

---

## What Most Guides Miss

Most guides show the five principles and a toy example, then stop. The bit they skip: **DIP is where testability actually comes from.** If your use case depends on \`new SqlOrderRepository()\`, you can't unit test it without a database. Inject \`IOrderRepository\` and suddenly tests use a fake. Another gap: **LSP isn't just "subtypes must substitute."** In practice it's "don't weaken preconditions or strengthen postconditions"—so no throwing in a subtype when the base doesn't, and no returning null when the base returns a value. People violate LSP with the best intentions (e.g. \`Square\` extending \`Rectangle\` and overriding setters). Finally: **when to relax.** SOLID isn't for one-off scripts or 50-line utilities. Apply it where code will evolve and be tested; skip the extra interfaces when the module is stable and tiny. Most posts don't say that—they imply you must SOLID everything.

---

## Decision Framework

- **If greenfield and non-trivial domain** → Start with SRP and DIP (interfaces for repositories, services); add OCP when you have multiple strategies or handlers.
- **If brownfield** → Extract one area (e.g. order placement) into clear responsibilities and inject dependencies; leave the rest until you have capacity.
- **If "where does this go?" is unclear** → Ask: "If I swapped the database or the notification channel, would this change?" No → domain or application; Yes → infrastructure.
- **If the class has more than one reason to change** → Split; give each class one job. If you have only one implementation today, the interface still pays off for tests and future swaps.
- **If someone says "SOLID is overkill"** → For a 50-line script, maybe. For code that multiple people change or that you need to test in isolation, it's not.

---

## Key Takeaways

- SOLID is five principles: SRP, OCP, LSP, ISP, DIP. In .NET, apply them with interfaces, DI, and focused classes.
- DIP is what makes unit testing possible—depend on \`IOrderRepository\`, inject a fake in tests.
- One reason to change per class; extend by new code (OCP); subtypes substitutable for base (LSP); small interfaces (ISP).
- Don't SOLID everything—apply where code will evolve and be tested; relax for small, stable, or one-off code.

---

## When I Would Use This Again — and When I Wouldn’t

I would apply SOLID again when: building or refactoring domain or application-layer code in .NET that multiple people will change, that needs unit tests with mocks, or that will evolve (new features, new implementations). Same applies to libraries and shared packages where interface stability matters.

I wouldn’t push SOLID when: the codebase is small and stable, the team does not use DI or testing, or the code is clearly one-off (scripts, migrations, throwaway tooling). I wouldn’t add interfaces “for SOLID” without a second implementation or tests that use them. For performance-critical or high-churn experimental code, I’d keep SOLID light and revisit when the design stabilizes.

---

## Frequently Asked Questions

### What is SOLID?

SOLID is five object-oriented design principles: Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion. They help you write maintainable, testable, and flexible code.

### What is Single Responsibility (SRP)?

A class should have **one reason to change**. Split responsibilities (e.g. validation, persistence, notification) into separate classes so that each has one clear job.

### What is Open/Closed (OCP)?

**Open for extension** (add new behavior via new code), **closed for modification** (avoid changing existing code). Use interfaces and new implementations (e.g. new discount strategy) instead of editing existing methods (e.g. adding a new case in a switch).

### What is Liskov Substitution (LSP)?

Subtypes must be **substitutable** for their base types. Code that expects the base type should work with any subtype without knowing the difference. Do not weaken preconditions, strengthen postconditions, or throw in cases the base does not.

### What is Interface Segregation (ISP)?

Clients should not depend on **interfaces they do not use**. Prefer small, focused interfaces (e.g. \`IReadOrders\`, \`IWriteOrders\`) over one large interface so that callers and implementers depend only on what they need.

### What is Dependency Inversion (DIP)?

**Depend on abstractions** (interfaces), not concretions. High-level and low-level modules both depend on interfaces; the composition root (e.g. DI container) wires concrete implementations. In .NET, use constructor injection and register interface → implementation.

### Why follow SOLID?

**Testability** (small units, injectable dependencies), **maintainability** (changes are localized), **flexibility** (extend by new code, swap implementations). Reduces coupling and makes evolution safer.

### SRP example in .NET?

Separate \`OrderValidator\` (validation), \`IOrderRepository\` (persistence), \`IOrderNotificationService\` (email). \`OrderService\` orchestrates and depends on these abstractions; each class has one reason to change.

### OCP example in .NET?

Use \`IDiscountStrategy\` and multiple implementations (\`StandardDiscountStrategy\`, \`PremiumDiscountStrategy\`). Add \`PlatinumDiscountStrategy\` without changing existing code; register in DI and extend the strategy map.

### LSP violation example?

\`Square\` inheriting \`Rectangle\` and overriding \`Width\`/\`Height\` so they stay equal. Code that sets \`Width\` and \`Height\` independently breaks when given a \`Square\`. Fix: do not inherit, or use an interface (\`IShape\`) that only exposes what is common (\`Area\`).

### ISP example in .NET?

\`IReadOrders\` and \`IWriteOrders\` instead of one \`IOrderService\` with read and write. \`OrderReporter\` depends only on \`IReadOrders\`; implementers can provide read-only or read-write.

### DIP example in .NET?

\`OrderService\` depends on \`IOrderRepository\` (injected in constructor). \`Program.cs\` registers \`AddScoped<IOrderRepository, SqlOrderRepository>\`. Tests inject a mock \`IOrderRepository\`. High-level code never references \`SqlOrderRepository\` directly.

### Most important SOLID principle?

Depends on context. **DIP** is crucial for testability and swapping implementations. **SRP** is the foundation for maintainability. **OCP** matters when you have many variations (strategies, handlers). All five work together.

### When is it OK to violate SOLID?

Simple scripts, prototypes, or code that will not change. Performance-critical paths where abstraction cost is measurable. Document the trade-off and revisit when the code evolves.

### SOLID vs DRY vs KISS?

**SOLID** guides **structure** (responsibilities, dependencies, interfaces). **DRY** avoids **duplication**. **KISS** favors **simplicity**. They are complementary: apply SOLID where it adds value without over-engineering (KISS); keep logic in one place (DRY) while respecting SRP (one class, one responsibility).
`,
  faqs: [
  {
    "question": "What is SOLID?",
    "answer": "Five principles: SRP, OCP, LSP, ISP, DIP for maintainable code."
  },
  {
    "question": "What is SRP?",
    "answer": "Single Responsibility. One reason to change per class."
  },
  {
    "question": "What is OCP?",
    "answer": "Open/Closed. Open for extension, closed for modification."
  },
  {
    "question": "What is LSP?",
    "answer": "Liskov Substitution. Subtypes substitutable for base."
  },
  {
    "question": "What is ISP?",
    "answer": "Interface Segregation. Small, specific interfaces."
  },
  {
    "question": "What is DIP?",
    "answer": "Dependency Inversion. Depend on abstractions."
  },
  {
    "question": "Why follow SOLID?",
    "answer": "Testable, maintainable, flexible code."
  },
  {
    "question": "SRP example in .NET?",
    "answer": "Separate OrderValidator, IOrderRepository, IOrderNotificationService; OrderService orchestrates."
  },
  {
    "question": "OCP example in .NET?",
    "answer": "IDiscountStrategy and implementations; add PlatinumDiscountStrategy without changing existing code."
  },
  {
    "question": "LSP violation example?",
    "answer": "Square inheriting Rectangle and overriding Width/Height; fix with IShape or no inheritance."
  },
  {
    "question": "ISP example in .NET?",
    "answer": "IReadOrders and IWriteOrders instead of one IOrderService; OrderReporter depends only on IReadOrders."
  },
  {
    "question": "DIP example in .NET?",
    "answer": "OrderService depends on IOrderRepository; DI registers implementation; tests inject mock."
  },
  {
    "question": "Most important SOLID principle?",
    "answer": "Depends on context. DIP for testability. SRP for focus. OCP for extension."
  },
  {
    "question": "When violate SOLID?",
    "answer": "Simple code, prototypes, performance-critical paths. Document and revisit."
  },
  {
    "question": "SOLID vs DRY vs KISS?",
    "answer": "Complementary. SOLID structure, DRY duplication, KISS simplicity."
  }
]
}
