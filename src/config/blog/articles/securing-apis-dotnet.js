/**
 * Blog article: securing-apis-dotnet
 * Auto-generated by scripts/split-blog-articles.js. Do not edit the content here by hand if you run the split script again.
 */

export default {
  slug: "securing-apis-dotnet",
  title: "Securing .NET APIs: Auth, Rate Limiting, and Headers",
  excerpt: "Practical security for .NET Web APIs: JWT validation, rate limiting, CORS, and security headers. Hardening production endpoints.",
  date: "2025-09-16",
  topic: "Full-Stack",
  keywords: ["Securing .NET APIs: Auth, Rate Limiting, and Headers", "Securing Apis Dotnet", "Securing Apis Dotnet best practices", "how to securing apis dotnet", "securing apis dotnet in .NET", "securing apis dotnet guide", "securing apis dotnet for enterprise", "securing apis dotnet patterns", "when to use securing apis dotnet", "securing apis dotnet tutorial", "securing apis dotnet examples", "securing apis dotnet in C#", "securing apis dotnet overview", "securing apis dotnet implementation", "understanding securing apis dotnet", "securing apis dotnet for developers", "securing apis dotnet checklist", "securing apis dotnet tips", "securing apis dotnet deep dive", "securing apis dotnet comparison", "securing apis dotnet vs alternatives", "securing apis dotnet .NET Core", "securing apis dotnet Azure", "securing apis dotnet explained", "securing apis dotnet when to use", "securing apis dotnet enterprise", "securing apis dotnet .NET", "what is securing apis dotnet", "securing apis dotnet summary", "securing apis dotnet introduction", "securing apis dotnet fundamentals", "securing apis dotnet step by step", "securing apis dotnet complete guide", "securing apis dotnet for beginners", "securing apis dotnet advanced", "securing apis dotnet production", "securing apis dotnet real world", "securing apis dotnet example code", "securing apis dotnet C# example", "securing apis dotnet .NET example", "learn securing apis dotnet", "securing apis dotnet learn", "securing apis dotnet reference", "securing apis dotnet cheat sheet", "securing apis dotnet pitfalls", "securing apis dotnet common mistakes", "securing apis dotnet performance", "securing apis dotnet optimization", "securing apis dotnet security", "securing apis dotnet testing", "securing apis dotnet unit test", "securing apis dotnet integration", "securing apis dotnet migration", "securing apis dotnet from scratch", "securing apis dotnet 2024", "securing apis dotnet 2025", "best securing apis dotnet", "securing apis dotnet best", "pro securing apis dotnet", "securing apis dotnet expert", "securing apis dotnet consultant", "securing apis dotnet services", "securing apis dotnet course", "securing apis dotnet workshop", "securing apis dotnet webinar", "securing apis dotnet blog", "securing apis dotnet article", "securing apis dotnet post", "why securing apis dotnet", "when securing apis dotnet", "where securing apis dotnet", "securing apis dotnet in .NET 6", "securing apis dotnet in .NET 7", "securing apis dotnet in .NET 8", "securing apis dotnet for C#", "securing apis dotnet for Angular", "securing apis dotnet for Vue", "securing apis dotnet for React", "securing apis dotnet for Azure", "securing apis dotnet for microservices", "securing apis dotnet for API", "securing apis dotnet for database", "securing apis dotnet for testing", "securing apis dotnet for DevOps", "securing apis dotnet for senior developers", "securing apis dotnet for team", "securing apis dotnet for production", "securing apis dotnet for scale", "securing apis dotnet for refactoring", "securing apis dotnet for enterprise applications", "securing apis dotnet for startup", "securing apis dotnet in 2024", "securing apis dotnet in 2025", "securing apis dotnet in 2026", "securing apis dotnet code sample", "securing apis dotnet code example", "securing apis dotnet sample code", "securing apis dotnet full example", "securing apis dotnet working example", "securing apis dotnet practical securing apis dotnet", "securing apis dotnet real world example", "securing apis dotnet use case", "securing apis dotnet use cases", "securing apis dotnet scenario", "securing apis dotnet scenarios", "securing apis dotnet pattern", "securing apis dotnet approach", "securing apis dotnet approaches", "securing apis dotnet strategy", "securing apis dotnet strategies", "securing apis dotnet technique", "securing apis dotnet techniques", "securing apis dotnet method", "securing apis dotnet methods", "securing apis dotnet solution", "securing apis dotnet solutions", "securing apis dotnet implementation guide", "securing apis dotnet getting started", "securing apis dotnet quick start", "securing apis dotnet overview guide", "securing apis dotnet comprehensive guide", "securing apis dotnet detailed guide", "securing apis dotnet practical guide", "securing apis dotnet developer guide", "securing apis dotnet engineer guide", "securing apis dotnet architect guide", "securing apis dotnet for architects", "securing apis dotnet for backend", "securing apis dotnet for tech leads", "securing apis dotnet for senior devs", "benefits of securing apis dotnet", "advantages of securing apis dotnet", "alternatives to securing apis dotnet", "compared to securing apis dotnet", "intro to securing apis dotnet", "basics of securing apis dotnet", "securing apis dotnet tips and tricks", "securing apis dotnet production-ready", "securing apis dotnet enterprise-grade", "securing apis dotnet with Docker", "securing apis dotnet with Kubernetes", "securing apis dotnet in ASP.NET Core", "securing apis dotnet with Entity Framework", "securing apis dotnet with EF Core", "securing apis dotnet modern", "securing apis dotnet updated", "securing apis dotnet latest", "securing apis dotnet walkthrough", "securing apis dotnet hands-on", "securing apis dotnet practical examples", "securing apis dotnet real-world examples", "securing apis dotnet common pitfalls", "securing apis dotnet gotchas", "securing apis dotnet FAQ", "securing apis dotnet FAQs", "securing apis dotnet Q&A", "securing apis dotnet interview questions", "securing apis dotnet interview", "securing apis dotnet certification", "securing apis dotnet training", "securing apis dotnet video", "securing apis dotnet series", "securing apis dotnet part 1", "securing apis dotnet core concepts", "securing apis dotnet key concepts", "securing apis dotnet recap", "securing apis dotnet takeaways", "securing apis dotnet conclusion", "securing apis dotnet next steps", "securing apis dotnet further reading", "securing apis dotnet resources", "securing apis dotnet tools", "securing apis dotnet libraries", "securing apis dotnet frameworks", "securing apis dotnet NuGet", "securing apis dotnet package", "securing apis dotnet GitHub", "securing apis dotnet open source", "securing apis dotnet community", "securing apis dotnet Microsoft docs", "securing apis dotnet documentation", "securing apis dotnet official guide", "securing apis dotnet official tutorial", "securing apis with .NET Core", "securing apis dotnet ASP.NET Core", "Securing", "Securing guide", "Securing tutorial", "Securing best practices", "Securing in .NET", "Securing in C#", "Securing for developers", "Securing examples", "Securing patterns", "Securing overview", "Securing introduction", "Securing deep dive", "Securing explained", "Securing how to", "Securing what is", "Securing when to use", "Securing for enterprise", "Securing .NET Core", "Securing Azure", "Securing C#", "Securing with .NET", "Securing with C#", "Securing with Azure", "Securing with Angular", "Securing with Vue", "Securing with React", "Securing with Entity Framework", "Securing with SQL Server", "Securing step by step", "Securing complete guide", "Securing from scratch", "Securing 2024", "Securing 2025", "Securing 2026", "Securing code example", "Securing sample code", "Securing implementation", "Securing real world", "Securing production", "Securing for beginners", "Securing advanced", "Securing for architects", "Securing for backend", "Securing for API", "Securing in ASP.NET Core", "Securing with EF Core", "Securing tutorial 2024", "Securing guide 2025", "Securing best practices 2024", "Securing C# examples", "Securing .NET examples", "Securing implementation guide", "Securing how to implement", "Securing benefits", "Securing advantages", "Securing pitfalls", "Securing alternatives", "Securing compared", "Securing intro", "Securing basics", "Securing tips and tricks", "Securing production-ready", "Securing enterprise-grade", "Securing maintainable", "Securing testable", "Securing refactoring", "Securing modern", "Securing updated", "Securing latest", "Securing for tech leads", "Securing for senior devs", "Securing with Docker", "Securing with Kubernetes", "Securing in .NET 8", "Securing in .NET 7", "Securing in .NET 6", "Securing Apis", "Securing Apis guide", "Securing Apis tutorial", "Securing Apis best practices", "Securing Apis in .NET", "Securing Apis in C#", "Securing Apis for developers", "Securing Apis examples", "Securing Apis patterns", "Securing Apis overview", "Securing Apis introduction", "Securing Apis deep dive", "Securing Apis explained", "Securing Apis how to", "Securing Apis what is", "Securing Apis when to use", "Securing Apis for enterprise", "Securing Apis .NET Core", "Securing Apis Azure", "Securing Apis C#", "Securing Apis with .NET", "Securing Apis with C#", "Securing Apis with Azure", "Securing Apis with Angular", "Securing Apis with Vue", "Securing Apis with React", "Securing Apis with Entity Framework", "Securing Apis with SQL Server", "Securing Apis step by step", "Securing Apis complete guide", "Securing Apis from scratch", "Securing Apis 2024", "Securing Apis 2025", "Securing Apis 2026", "Securing Apis code example", "Securing Apis sample code", "Securing Apis implementation", "Securing Apis real world", "Securing Apis production", "Securing Apis for beginners", "Securing Apis advanced", "Securing Apis for architects", "Securing Apis for backend", "Securing Apis for API", "Securing Apis in ASP.NET Core", "Securing Apis with EF Core", "Securing Apis tutorial 2024", "Securing Apis guide 2025", "Securing Apis best practices 2024", "Securing Apis C# examples", "Securing Apis .NET examples", "Securing Apis implementation guide", "Securing Apis how to implement", "Securing Apis benefits", "Securing Apis advantages", "Securing Apis pitfalls", "Securing Apis alternatives", "Securing Apis compared", "Securing Apis intro", "Securing Apis basics", "Securing Apis tips and tricks", "Securing Apis production-ready", "Securing Apis enterprise-grade", "Securing Apis maintainable", "Securing Apis testable", "Securing Apis refactoring", "Securing Apis modern", "Securing Apis updated", "Securing Apis latest", "Securing Apis for tech leads", "Securing Apis for senior devs", "Securing Apis with Docker", "Securing Apis with Kubernetes", "Securing Apis in .NET 8", "Securing Apis in .NET 7", "Securing Apis in .NET 6", "Securing Apis Dotnet how to", "Securing Apis Dotnet what is", "Securing Apis Dotnet C#", "Securing Apis Dotnet with .NET", "Securing Apis Dotnet with C#", "Securing Apis Dotnet with Azure", "Securing Apis Dotnet with Angular", "Securing Apis Dotnet with Vue", "Securing Apis Dotnet with React", "Securing Apis Dotnet with SQL Server", "Securing Apis Dotnet 2026", "Securing Apis Dotnet tutorial 2024", "Securing Apis Dotnet guide 2025", "Securing Apis Dotnet best practices 2024", "Securing Apis Dotnet C# examples", "Securing Apis Dotnet .NET examples", "Securing Apis Dotnet how to implement", "Securing Apis Dotnet benefits", "Securing Apis Dotnet advantages", "Securing Apis Dotnet alternatives", "Securing Apis Dotnet compared", "Securing Apis Dotnet intro", "Securing Apis Dotnet basics", "Securing Apis Dotnet maintainable", "Securing Apis Dotnet testable", "Securing Apis Dotnet refactoring", "Apis", "Apis guide", "Apis tutorial", "Apis best practices", "Apis in .NET", "Apis in C#", "Apis for developers", "Apis examples", "Apis patterns", "Apis overview", "Apis introduction", "Apis deep dive", "Apis explained", "Apis how to", "Apis what is", "Apis when to use", "Apis for enterprise", "Apis .NET Core", "Apis Azure", "Apis C#", "Apis with .NET", "Apis with C#", "Apis with Azure", "Apis with Angular", "Apis with Vue", "Apis with React", "Apis with Entity Framework", "Apis with SQL Server", "Apis step by step", "Apis complete guide", "Apis from scratch", "Apis 2024", "Apis 2025", "Apis 2026", "Apis code example", "Apis sample code", "Apis implementation", "Apis real world", "Apis production", "Apis for beginners", "Apis advanced", "Apis for architects", "Apis for backend", "Apis for API", "Apis in ASP.NET Core", "Apis with EF Core", "Apis tutorial 2024", "Apis guide 2025", "Apis best practices 2024", "Apis C# examples", "Apis .NET examples", "Apis implementation guide", "Apis how to implement", "Apis benefits", "Apis advantages", "Apis pitfalls", "Apis alternatives", "Apis compared", "Apis intro"],
  relatedServices: ["full-stack-development","technical-leadership"],
  relatedProjects: ["bat-inhouse-app","chubb-insurance-applications"],
  relatedArticleSlugs: ["full-stack-net-angular-enterprise"],
  author: "Waqas Ahmad",
  content: `## Introduction

This guidance is relevant when the topic of this article applies to your system or design choices; it breaks down when constraints or context differ. I've applied it in real projects and refined the takeaways over time (as of 2026).

**.NET Web APIs** are a primary attack surface for many applications. **Authentication**, **authorization**, **rate limiting**, and **security headers** form the first line of defence. In production systems—from BAT's in-house microservices to Chubb insurance applications—I have seen APIs hardened with **JWT validation**, **rate limiting** per client, and **consistent security headers**. This article is a **full, in-depth guide** to **practical security for .NET APIs**: what API security and JWT/OAuth mean, how to validate tokens, enforce scopes, apply rate limits, set defensive headers, and configure CORS so your endpoints stay secure and resilient to abuse.

Security is **layered**: no single control is enough. Combine **auth**, **rate limiting**, and **headers** so that even if one layer is misconfigured, others still reduce risk. We start with **what API security is** and **what JWT and OAuth2/OIDC are**, then build up from minimal JWT validation to full **Program.cs**-style setup with rate limiting, security headers, and CORS.

If you are new to API security in .NET, start with [Topics covered](#topics-covered) and [Securing .NET APIs at a glance](#securing-net-apis-at-a-glance).

## Topics covered

- [Decision Context](#decision-context)
- [What is API security and why it matters](#what-is-api-security-and-why-it-matters)
- [Securing .NET APIs at a glance](#securing-net-apis-at-a-glance)
- [What is JWT?](#what-is-jwt)
- [What is OAuth2 and OpenID Connect?](#what-is-oauth2-and-openid-connect)
- [Authentication and authorization in ASP.NET Core](#authentication-and-authorization-in-aspnet-core)
- [Rate limiting](#rate-limiting)
- [Security headers](#security-headers)
- [CORS](#cors)
- [Best practices and common issues](#best-practices-and-common-issues)
- [Summary](#summary)
- [Position & Rationale](#position--rationale)
- [Trade-Offs & Failure Modes](#trade-offs--failure-modes)
- [What Most Guides Miss](#what-most-guides-miss)
- [Decision Framework](#decision-framework)
- [Key Takeaways](#key-takeaways)
- [When I Would Use This Again — and When I Wouldn't](#when-i-would-use-this-again--and-when-i-wouldnt)
- [Frequently Asked Questions](#frequently-asked-questions)

------

## Decision Context

- **System scale:** Varies by context; the approach in this article applies to the scales and scenarios described in the body.
- **Team size:** Typically small to medium teams; ownership and clarity matter more than headcount.
- **Time / budget pressure:** Applicable under delivery pressure; I've used it in both greenfield and incremental refactors.
- **Technical constraints:** .NET and related stack where relevant; constraints are noted in the article where they affect the approach.
- **Non-goals:** This article does not optimize for every possible scenario; boundaries are stated where they matter.


## What is API security and why it matters

**API security** is the set of practices and controls that protect your **Web API** from **unauthorised access**, **data theft**, **abuse**, and **misuse**. Unlike a traditional web app (HTML pages and cookies), an **API** is consumed by **programs**: mobile apps, single-page apps (SPAs), or other services. That means you must **authenticate** every request (e.g. with a **JWT** or API key), **authorise** what the caller is allowed to do (e.g. scopes or roles), and protect the API from **abuse** (e.g. rate limiting) and **misconfiguration** (e.g. security headers, CORS).

In .NET this typically includes: **authentication** (who is calling?), **authorization** (what are they allowed to do?), **rate limiting** (how much can they call?), **security headers** (HSTS, X-Content-Type-Options, etc.), and **CORS** (which origins can call from the browser). This article explains each and how to implement them in **ASP.NET Core**. Getting these right from the start reduces the chance of token forgery, scope escalation, DoS, and header-based attacks.

---

## Securing .NET APIs at a glance

| Concept | What it is |
|--------|------------|
| **Authentication** | Establish **who** is calling—validate JWT or API key; reject invalid or expired tokens. |
| **Authorization** | Enforce **what** the caller is allowed to do—check scopes, roles, or policies on every protected endpoint. |
| **JWT** | Compact, URL-safe token with header, payload (claims), and signature; sent as \`Authorization: Bearer <token>\`. |
| **OAuth2 / OIDC** | Standards for authorisation (OAuth2) and identity (OpenID Connect); use an identity provider (Azure AD, IdentityServer, Auth0). |
| **Rate limiting** | Cap requests per client (IP, key, or user) in a time window; return **429** with **Retry-After** when exceeded. |
| **Security headers** | HSTS, X-Content-Type-Options, X-Frame-Options, CSP, Referrer-Policy—set on every response. |
| **CORS** | Allow only trusted origins to call your API from the browser; never use wildcard for credentialed requests in production. |

\`\`\`mermaid
sequenceDiagram
  participant Client
  participant API
  participant IdP as Identity Provider
  Client->>IdP: Login / get token
  IdP->>Client: Access token (JWT)
  Client->>API: Request + Authorization: Bearer <token>
  API->>API: Validate JWT, check scope/role
  API->>API: Rate limit check
  API->>Client: Response + security headers
\`\`\`

---

## What is JWT?

**JWT** (JSON Web Token) is a **compact, URL-safe** format for representing **claims** between two parties. A JWT has three parts separated by dots: **header** (algorithm and type), **payload** (claims such as subject, audience, expiry, scopes), and **signature** (so the token cannot be forged). The API does not store session state; instead, the **client** sends the JWT in the **Authorization: Bearer &lt;token&gt;** header on each request. The API **validates** the signature (using the identity provider's public keys), checks **expiry** and **audience**, and then uses the **claims** (e.g. scope, role) for **authorization**. JWTs are **stateless** from the API's perspective and work well for SPAs and mobile apps that call your API.

---

## What is OAuth2 and OpenID Connect?

**OAuth2** is a **framework** for **authorisation**: it lets a user or app grant limited access to resources (e.g. "this app can read my profile") without sharing passwords. **OpenID Connect (OIDC)** builds on OAuth2 and adds **identity**: it provides **ID tokens** (who the user is) and **user info** in a standard way. In practice, you use an **identity provider** (e.g. Azure AD, IdentityServer, Auth0) that supports OIDC. The client (SPA or mobile app) gets an **access token** (often a JWT) and sends it to your API; your API **validates** the token and checks **scopes** or **roles** to decide what the caller is allowed to do. Using a standard protocol (OAuth2/OIDC) gives you **single sign-on**, **revocation**, and **auditability** without building your own auth from scratch.

---

## Authentication and authorization in ASP.NET Core

Use **OAuth2 / OpenID Connect** with a trusted identity provider (Azure AD, IdentityServer, or a managed service). In ASP.NET Core, add the **JWT Bearer** middleware and validate the token on every request. Configure **Authority** (issuer) and **Audience** so that only tokens issued for your API are accepted. Validate **scopes** or **roles** in attributes or requirement handlers so that only authorised callers can access sensitive operations.

**Why we do this:** Without validation, any client could send a forged or expired token. By validating issuer, audience, signature, and expiry, we ensure only tokens from our identity provider and intended for our API are accepted. Authorization policies then enforce what each caller is allowed to do.

**Step 1: Add JWT Bearer authentication**

\`\`\`csharp
// Program.cs – JWT Bearer
using Microsoft.AspNetCore.Authentication.JwtBearer;

builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        options.Authority = "https://login.microsoftonline.com/your-tenant/v2.0";
        options.Audience = "api://your-api";
        options.TokenValidationParameters.ValidateIssuer = true;
        options.TokenValidationParameters.ValidateAudience = true;
        options.TokenValidationParameters.ValidateLifetime = true;
    });
\`\`\`

What this does: The middleware will fetch signing keys from the issuer's **metadata** (e.g. \`.well-known/openid-configuration\`) and validate the token's signature, issuer, audience, and expiry. Any request without a valid token to protected endpoints will receive **401 Unauthorized**.

**Step 2: Add authorization policies**

\`\`\`csharp
// Program.cs – Authorization policies
builder.Services.AddAuthorization(options =>
{
    options.AddPolicy("RequireReadScope", policy =>
        policy.RequireClaim("scope", "api.read"));
    options.AddPolicy("RequireWriteScope", policy =>
        policy.RequireClaim("scope", "api.write"));
});
\`\`\`

What this does: Defines named policies that require specific claims (e.g. \`scope\` = \`api.write\`). Controllers or actions then use \`[Authorize(Policy = "RequireWriteScope")]\` so that only callers with that scope can access the endpoint.

**Step 3: Use in the pipeline and on endpoints**

\`\`\`csharp
// Program.cs – Pipeline order (after UseRouting)
app.UseAuthentication();
app.UseAuthorization();

// On controller or minimal API:
// [Authorize(Policy = "RequireWriteScope")]
// public IActionResult CreateOrder(...) { ... }
\`\`\`

How this fits together: Every request passes through \`UseAuthentication()\`, which validates the JWT and sets \`HttpContext.User\`. \`UseAuthorization()\` then runs and checks the \`[Authorize]\` attribute and policy; if the caller does not have the required scope or role, the response is **403 Forbidden**. Never trust client-supplied identity without validation. Store secrets (e.g. client credentials) in **Azure Key Vault** or your secrets manager; never in code or config in source control.

---

## Rate limiting

Apply **rate limiting** per client (by IP, API key, or user ID) to prevent abuse and protect backend resources. In **.NET 7+**, use the built-in **rate limiting middleware**; on earlier versions, use a package like AspNetCoreRateLimit or a gateway (e.g. API Management) in front of your API. Define limits per endpoint or per policy (e.g. 100 requests per minute per IP for read, 10 for write). Return **429 Too Many Requests** with a **Retry-After** header when the limit is exceeded so clients know when to retry.

**Step 1: Add rate limiter and policy**

\`\`\`csharp
// Program.cs – Rate limiting (.NET 7+)
using System.Threading.RateLimiting;

builder.Services.AddRateLimiter(options =>
{
    options.AddFixedWindowLimiter("api", opt =>
    {
        opt.Window = TimeSpan.FromMinutes(1);
        opt.PermitLimit = 100;
    });
    options.OnRejected = async (context, _) =>
    {
        context.HttpContext.Response.StatusCode = 429;
        if (context.Lease.TryGetMetadata(MetadataName.RetryAfter, out var retryAfter))
            context.HttpContext.Response.Headers.RetryAfter = retryAfter.TotalSeconds.ToString();
        await context.HttpContext.Response.WriteAsync("Too many requests.");
    };
});
app.UseRateLimiter();
\`\`\`

What this does: Registers a **fixed window** limiter (100 requests per minute per connection). When the limit is exceeded, \`OnRejected\` sets **429** and adds **Retry-After** so clients can back off. Apply the limiter with \`[EnableRateLimiting("api")]\` on controller or endpoint, or globally via \`options.GlobalLimiter\`.

How this fits together: The middleware runs after routing; each request is counted against the limit (by default per IP). When the limit is hit, the request is short-circuited with 429 and never reaches your action. Use different limiters for read vs write (e.g. stricter for write) by defining multiple policies and applying them per endpoint.

---

## Security headers

Set **defensive headers** on every response so that browsers and proxies enforce safer behaviour. Common headers include:

- **Strict-Transport-Security (HSTS)** – force HTTPS.
- **X-Content-Type-Options: nosniff** – prevent MIME sniffing.
- **X-Frame-Options: DENY** (or SAMEORIGIN) – reduce clickjacking risk.
- **Content-Security-Policy (CSP)** – restrict script and resource origins (tune for your app).
- **Referrer-Policy** – control how much referrer info is sent.

You can add these in middleware or in a reverse proxy (e.g. API Management, nginx). Keep CSP tuned so that legitimate scripts and styles still load.

**Step 1: Inline middleware (minimal)**

\`\`\`csharp
// Program.cs – Security headers (inline)
app.Use(async (context, next) =>
{
    context.Response.Headers["X-Content-Type-Options"] = "nosniff";
    context.Response.Headers["X-Frame-Options"] = "DENY";
    context.Response.Headers["Referrer-Policy"] = "strict-origin-when-cross-origin";
    await next();
});
\`\`\`

What this does: Adds three headers to every response. Place this early in the pipeline (e.g. after UseRouting) so that even error responses get the headers.

**Step 2: Dedicated middleware (HSTS in production)**

\`\`\`csharp
// Middleware/SecurityHeadersMiddleware.cs
public class SecurityHeadersMiddleware
{
    private readonly RequestDelegate _next;
    private readonly bool _addHsts;

    public SecurityHeadersMiddleware(RequestDelegate next, IWebHostEnvironment env)
    {
        _next = next;
        _addHsts = env.IsProduction();
    }

    public async Task InvokeAsync(HttpContext context)
    {
        context.Response.Headers["X-Content-Type-Options"] = "nosniff";
        context.Response.Headers["X-Frame-Options"] = "DENY";
        context.Response.Headers["Referrer-Policy"] = "strict-origin-when-cross-origin";
        if (_addHsts)
            context.Response.Headers["Strict-Transport-Security"] = "max-age=31536000; includeSubDomains";
        await _next(context);
    }
}
// Program.cs – register: app.UseMiddleware<SecurityHeadersMiddleware>();
\`\`\`

What this file is: A dedicated middleware that sets the same headers and adds **HSTS** only in production (so local HTTP still works in dev). Encapsulating headers in a class keeps **Program.cs** clean and makes it easy to add CSP or other headers later.

How this fits together: The middleware runs for every request and adds headers before calling \`_next\`. The response then goes through the rest of the pipeline; when it is sent, the headers are included. Tune **Content-Security-Policy** when your API serves HTML or when you need to restrict script sources; start with report-only mode if unsure, then enforce once validated.

---

## CORS

Configure **CORS** explicitly so that only allowed origins can call your API from the browser. Do not use wildcard in production for credentialed requests; list the front-end origins you trust. Use **AllowCredentials()** only when you need cookies or auth headers and your origins are specific.

**Cross-Origin Resource Sharing (CORS)** is a browser mechanism: when your SPA (e.g. on \`https://app.example.com\`) calls your API (e.g. on \`https://api.example.com\`), the browser sends an **Origin** header and may send a **preflight** (OPTIONS) request. Your API must respond with **Access-Control-Allow-Origin** and related headers so the browser allows the response. If you do not configure CORS, the browser blocks the response and the front end cannot read it.

\`\`\`csharp
// Program.cs – CORS policy
var allowedOrigins = builder.Configuration.GetSection("Cors:AllowedOrigins").Get<string[]>()
    ?? new[] { "https://your-frontend.com" };
builder.Services.AddCors(options =>
{
    options.AddPolicy("ApiCors", policy =>
    {
        policy.WithOrigins(allowedOrigins)
            .AllowAnyMethod()
            .AllowAnyHeader();
        // Use .AllowCredentials() only when needed (cookies/auth headers) and origins are explicit
    });
});
// After UseRouting, before UseAuthorization:
app.UseCors("ApiCors");
\`\`\`

What this does: Defines a named policy that allows only the configured origins; methods and headers are open so that your front end can send GET, POST, and \`Authorization\`. In production, **never** use \`*\` for credentialed requests; list each allowed origin (e.g. from config) so that only your known front ends can call the API.

---

## Best practices and common issues

**Do:** Validate **issuer** and **audience** for JWT; enforce **authorization** (scope/role) on every protected endpoint; apply **rate limiting** (including on public endpoints); set **security headers** on every response; configure **CORS** with explicit origins; store **secrets** in Key Vault (or equivalent) and use **Managed Identity** where possible; return **429** with **Retry-After** when rate limited.

**Don't:** Skip token validation or use wildcard CORS for credentialed requests; store secrets in appsettings or source control; forget to validate scopes/roles (accepting a valid token is not enough); leave public or anonymous endpoints without rate limiting.

**Common issues:**

- **Token validation misconfiguration:** Wrong Authority, Audience, or issuer validation allows invalid or cross-tenant tokens. Always validate **issuer** and **audience**; use **metadata** from the identity provider so that key rotation is handled. Test with invalid and expired tokens.
- **Rate limiting too strict or too loose:** Too strict and legitimate users get 429; too loose and abuse is possible. **Measure** traffic and set limits per endpoint (e.g. read vs write); use **sliding window** or **token bucket** and return **Retry-After** on 429.
- **Certificate and TLS issues:** Expired or misconfigured TLS certs cause silent failures or browser errors. Use **managed certificates** where possible; define **rotation** and **expiry monitoring**. Enforce **TLS 1.2** minimum.
- **CORS blocking legitimate frontends:** Forgetting to add a new front-end origin or using wildcard with credentials breaks production. **List allowed origins** explicitly; use environment-specific config.
- **Security headers missing or wrong:** Missing HSTS, X-Content-Type-Options, or CSP leaves the app exposed. Add **security headers** in middleware or at the reverse proxy; tune CSP so that legitimate scripts still load.
- **Secrets in config:** Connection strings or API keys in appsettings or plain environment variables. Use **Azure Key Vault** and **Managed Identity** so that no secrets are stored in code or config in source control.
- **Skipping scope/role validation:** Accepting a valid token without checking **scopes** or **roles** lets callers access more than intended. Always enforce **authorization** (e.g. \`[Authorize(Policy = "RequireWriteScope")]\`) on sensitive endpoints.
- **No rate limiting on public endpoints:** Public or anonymous endpoints (e.g. login, sign-up) are easy targets. Apply **rate limiting** (per IP or per key) even when auth is not required; use **captcha** or **throttling** for high-risk actions.

---
---

## Position & Rationale

I treat **auth** (JWT validation with Authority and Audience) and **authorization** (policies and \`[Authorize]\` on every protected endpoint) as non-negotiable for any API that handles sensitive data. I add **rate limiting** on all endpoints—including public ones like login and sign-up—so abuse and brute force are bounded; I return **429** with **Retry-After**. I set **security headers** (HSTS, X-Content-Type-Options, X-Frame-Options, CSP, Referrer-Policy) in middleware or at the reverse proxy; I never rely on a single control. I configure **CORS** with explicit origins and never use wildcard for credentialed requests in production. I reject storing secrets in appsettings or env in source control; I use **Key Vault** and **Managed Identity**. I avoid accepting a valid token without enforcing **scopes or roles**—that's the main way APIs over-privilege callers.

---

## Trade-Offs & Failure Modes

- **What this sacrifices:** Some simplicity, extra structure, or operational cost depending on the topic; the article body covers specifics.
- **Where it degrades:** Under scale or when misapplied; early warning signs include drift from the intended use and repeated workarounds.
- **How it fails when misapplied:** Using it where constraints don't match, or over-applying it. The "When I Would Use This Again" section below reinforces boundaries.
- **Early warning signs:** Team confusion, bypasses, or "we're doing X but not really" indicate a mismatch.

---

## What Most Guides Miss

Most guides show how to add JWT validation and then stop. What they skip: **who validates what where**—API keys vs user tokens vs service-to-service; **failure mode** when the auth server is down (cache tokens? fail closed?); and **audit**—logging who called what so you can debug and comply. The hard part isn't the middleware, it's the boundaries and the "what happens when" that nobody documents. In real systems you also need a clear story for key rotation, scope creep, and who owns secrets; most posts don't go there.

---

## Decision Framework

- **If the context matches the assumptions in this article** → Apply the approach as described; adapt to your scale and team.
- **If constraints differ** → Revisit Decision Context and Trade-Offs; simplify or choose an alternative.
- **If you're under heavy time pressure** → Use the minimal subset that gives the most value; expand later.
- **If ownership is unclear** → Clarify before scaling the approach; unclear ownership is an early warning sign.

---

## Key Takeaways

- The article body and Summary capture the technical content; this section distils judgment.
- Apply the approach where context and constraints match; avoid over-application.
- Trade-offs and failure modes are real; treat them as part of the decision.
- Revisit "When I Would Use This Again" when deciding on a new project or refactor.


## Summary

- **API security** in .NET means **authentication** (validate JWT), **authorization** (enforce scopes/roles), **rate limiting** (per client), **security headers** (HSTS, X-Content-Type-Options, X-Frame-Options, CSP, Referrer-Policy), and **CORS** (explicit origins).
- Use **AddJwtBearer** with **Authority** and **Audience**; add **authorization policies** and \`[Authorize(Policy = "...")]\` on every protected endpoint.
- Use **.NET 7+ rate limiting** (or a package/gateway) and return **429** with **Retry-After** when the limit is exceeded.
- Set **security headers** in middleware or at the reverse proxy; use a dedicated middleware class for clarity and HSTS in production only.
- Configure **CORS** with explicit origins; never use wildcard for credentialed requests in production.
- Layer these controls so that authentication, limits, and headers together reduce risk. Use the FAQs below as a quick reference when hardening .NET APIs.

---

## When I Would Use This Again — and When I Wouldn't

I would use this securing approach again for any .NET API that handles user data or sensitive operations—auth, authorization, rate limiting, headers, and CORS from day one. I'd insist on scope/role checks, not just "valid token." I wouldn't ship an API without rate limiting on login and sign-up. I wouldn't use CORS wildcard with credentials in production. For an internal-only API behind a VPN with no public surface, the minimum might be auth and headers; as soon as the API is reachable from the internet or multiple clients, the full set is mandatory in my view. If the team can't own an identity provider or Key Vault, I'd still add the patterns and treat getting those as a prerequisite for production.


---

## Frequently Asked Questions

### How do I validate JWT tokens correctly in .NET?

Use **AddJwtBearer** with **Authority** (issuer URL) and **Audience**; ensure **ValidateIssuer** and **ValidateAudience** are true. The middleware will fetch signing keys from the issuer's metadata and validate signature and expiry. Never skip validation for convenience.

### What rate limit should I set for my API?

Start with **conservative** limits (e.g. 100 requests per minute per IP for read, 10 for write) and **measure**; adjust based on real traffic and abuse patterns. Use **sliding window** or **token bucket**; return **429** with **Retry-After** when the limit is exceeded.

### How do I handle certificate rotation for my API?

Use **Azure App Service managed certificates** or **Let's Encrypt** with auto-renewal where possible. For custom certs, store in **Key Vault** and use a **rotation policy**; set **alerts** for expiry (e.g. 30 days before). Document the rotation process in a runbook.

### What security headers are essential for a .NET API?

At minimum: **Strict-Transport-Security (HSTS)**, **X-Content-Type-Options: nosniff**, **X-Frame-Options: DENY** (or SAMEORIGIN), **Referrer-Policy**. Add **Content-Security-Policy** when the API serves HTML or when you need to restrict script sources; tune for your app.

### Should I use API keys or JWT for API authentication?

Use **JWT** (OAuth2/OpenID Connect) when you have **users** or **apps** that need scoped access and revocation. Use **API keys** only for **machine-to-machine** simple cases; even then, prefer **Managed Identity** when on Azure. Never use API keys for user-facing apps.

### How do I prevent secrets from leaking in my .NET API?

Use **Azure Key Vault** (or equivalent) for connection strings, API keys, and certificates; reference them via **configuration** (e.g. Key Vault config provider). Use **Managed Identity** for service-to-service auth. Never commit secrets to source control; use **secret scanning** in CI.

### What is the difference between authentication and authorization?

**Authentication** answers "who is calling?"—you validate the token or credentials and establish identity. **Authorization** answers "what are they allowed to do?"—you check scopes, roles, or policies and allow or deny the operation. Always do both on every protected endpoint.

### How do I return 429 with Retry-After when rate limited?

When using .NET 7+ rate limiting, use an **OnRejected** callback to set \`context.HttpContext.Response.StatusCode = 429\` and add the **Retry-After** header from the **RateLimitLease** (e.g. \`TryGetMetadata(MetadataName.RetryAfter, out var retryAfter)\`). This helps clients back off and retry correctly.

### Should I validate JWT in a gateway or in the API?

You can do either: **API Management** or a gateway can validate the token and forward claims to the API (fewer validations, single point of config), or the **API** can validate the token itself (simpler topology, no gateway dependency). Ensure the token is validated **once** and never trust unvalidated claims.

### What is API security?

API security is the set of practices that protect your Web API from unauthorised access, data theft, and abuse: **authentication** (who is calling?), **authorization** (what are they allowed to do?), **rate limiting**, **security headers**, and **CORS**.

### Why use JWT instead of session cookies for APIs?

APIs are often called by mobile apps or SPAs that do not use browser cookies. JWT (or bearer tokens) are sent in the **Authorization** header and work across clients. They also support scopes and expiry and can be validated without server-side session storage.

### How do I configure CORS for my .NET API?

Use **AddCors()** with a named policy that allows **specific origins** (e.g. \`https://your-frontend.com\`). Use **AllowCredentials()** only when you need cookies or auth headers and your origins are explicit. Do not use wildcard in production for credentialed requests.

### What is rate limiting and why do I need it?

Rate limiting caps how many requests a client can send in a time window. It prevents abuse, DoS, and cost blowouts. Return **429 Too Many Requests** with **Retry-After** when the limit is exceeded. Use .NET 7+ built-in middleware or a package like AspNetCoreRateLimit.

### How do I enforce authorization per endpoint?

Use \`[Authorize]\` on controllers or actions; use \`[Authorize(Policy = "PolicyName")]\` for scope or role-based checks. Configure policies in **AddAuthorization()** (e.g. \`RequireClaim("scope", "api.write")\`). Never rely only on hiding URLs; always check on the server.

### What is HSTS and why add it?

**Strict-Transport-Security (HSTS)** tells browsers to use HTTPS only when talking to your API. It reduces the risk of downgrade attacks and accidental HTTP. Set \`max-age\` (e.g. 31536000 for one year) and \`includeSubDomains\` if applicable.

### Should I use API keys for machine-to-machine auth?

API keys are simple but hard to rotate and revoke per client. Prefer **Managed Identity** when on Azure; use **client credentials** (OAuth2) or **certificate-based auth** when you need per-client identity. Store keys in Key Vault and rotate them periodically.
`,
  faqs: [
  {
    "question": "How do I validate JWT tokens correctly in .NET?",
    "answer": "Use AddJwtBearer with Authority (issuer URL) and Audience; ensure ValidateIssuer and ValidateAudience are true. The middleware fetches signing keys from the issuer metadata and validates signature and expiry. Never skip validation for convenience."
  },
  {
    "question": "What rate limit should I set for my API?",
    "answer": "Start with conservative limits (e.g. 100 requests per minute per IP for read, 10 for write) and measure; adjust based on real traffic and abuse patterns. Use sliding window or token bucket; return 429 with Retry-After when the limit is exceeded."
  },
  {
    "question": "How do I handle certificate rotation for my API?",
    "answer": "Use Azure App Service managed certificates or Let's Encrypt with auto-renewal where possible. For custom certs, store in Key Vault and use a rotation policy; set alerts for expiry (e.g. 30 days before). Document the rotation process in a runbook."
  },
  {
    "question": "What security headers are essential for a .NET API?",
    "answer": "At minimum: Strict-Transport-Security (HSTS), X-Content-Type-Options: nosniff, X-Frame-Options: DENY (or SAMEORIGIN), Referrer-Policy. Add Content-Security-Policy when the API serves HTML or when you need to restrict script sources; tune for your app."
  },
  {
    "question": "Should I use API keys or JWT for API authentication?",
    "answer": "Use JWT (OAuth2/OpenID Connect) when you have users or apps that need scoped access and revocation. Use API keys only for machine-to-machine simple cases; even then, prefer Managed Identity when on Azure. Never use API keys for user-facing apps."
  },
  {
    "question": "How do I prevent secrets from leaking in my .NET API?",
    "answer": "Use Azure Key Vault (or equivalent) for connection strings, API keys, and certificates; reference them via configuration (e.g. Key Vault config provider). Use Managed Identity for service-to-service auth. Never commit secrets to source control; use secret scanning in CI."
  },
  {
    "question": "What is the difference between authentication and authorization?",
    "answer": "Authentication answers who is calling—you validate the token or credentials and establish identity. Authorization answers what they are allowed to do—you check scopes, roles, or policies. Always do both on every protected endpoint."
  },
  {
    "question": "How do I return 429 with Retry-After when rate limited?",
    "answer": "When using .NET 7+ rate limiting, use an OnRejected callback to set Response.StatusCode = 429 and add the Retry-After header from the RateLimitLease so clients know when to retry."
  },
  {
    "question": "Should I validate JWT in a gateway or in the API?",
    "answer": "Either: a gateway can validate and forward claims (centralised), or the API can validate (simpler topology). Ensure the token is validated once and never trust unvalidated claims."
  },
  {
    "question": "What is API security?",
    "answer": "API security is the set of practices that protect your Web API from unauthorised access, data theft, and abuse: authentication (who is calling?), authorization (what are they allowed to do?), rate limiting, security headers, and CORS."
  },
  {
    "question": "Why use JWT instead of session cookies for APIs?",
    "answer": "APIs are often called by mobile apps or SPAs that do not use browser cookies. JWT (or bearer tokens) are sent in the Authorization header and work across clients. They support scopes and expiry and can be validated without server-side session storage."
  },
  {
    "question": "How do I configure CORS for my .NET API?",
    "answer": "Use AddCors() with a named policy that allows specific origins (e.g. https://your-frontend.com). Use AllowCredentials() only when you need cookies or auth headers and your origins are explicit. Do not use wildcard in production for credentialed requests."
  },
  {
    "question": "What is rate limiting and why do I need it?",
    "answer": "Rate limiting caps how many requests a client can send in a time window. It prevents abuse, DoS, and cost blowouts. Return 429 Too Many Requests with Retry-After when the limit is exceeded. Use .NET 7+ built-in middleware or a package like AspNetCoreRateLimit."
  },
  {
    "question": "How do I enforce authorization per endpoint?",
    "answer": "Use [Authorize] on controllers or actions; use [Authorize(Policy = \"PolicyName\")] for scope or role-based checks. Configure policies in AddAuthorization() (e.g. RequireClaim(\"scope\", \"api.write\")). Never rely only on hiding URLs; always check on the server."
  },
  {
    "question": "What is HSTS and why add it?",
    "answer": "Strict-Transport-Security (HSTS) tells browsers to use HTTPS only when talking to your API. It reduces the risk of downgrade attacks and accidental HTTP. Set max-age (e.g. 31536000 for one year) and includeSubDomains if applicable."
  },
  {
    "question": "Should I use API keys for machine-to-machine auth?",
    "answer": "API keys are simple but hard to rotate and revoke per client. Prefer Managed Identity when on Azure; use client credentials (OAuth2) or certificate-based auth when you need per-client identity. Store keys in Key Vault and rotate them periodically."
  }
]
}
