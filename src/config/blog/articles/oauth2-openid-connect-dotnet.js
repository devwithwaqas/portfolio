/**
 * Blog article: oauth2-openid-connect-dotnet
 * Auto-generated by scripts/split-blog-articles.js. Do not edit the content here by hand if you run the split script again.
 */

export default {
  slug: "oauth2-openid-connect-dotnet",
  title: "OAuth2 and OpenID Connect in .NET: In-Depth",
  excerpt: "OAuth2 flows, OpenID Connect, JWT validation, and securing .NET APIs and SPAs. Identity providers, scopes, and refresh tokens.",
  date: "2025-05-24",
  topic: "Full-Stack",
  keywords: ["OAuth2 and OpenID Connect in .NET: In-Depth", "Oauth2 Openid Connect Dotnet", "Oauth2 Openid Connect Dotnet best practices", "how to oauth2 openid connect dotnet", "oauth2 openid connect dotnet in .NET", "oauth2 openid connect dotnet guide", "oauth2 openid connect dotnet for enterprise", "oauth2 openid connect dotnet patterns", "when to use oauth2 openid connect dotnet", "oauth2 openid connect dotnet tutorial", "oauth2 openid connect dotnet examples", "oauth2 openid connect dotnet in C#", "oauth2 openid connect dotnet overview", "oauth2 openid connect dotnet implementation", "understanding oauth2 openid connect dotnet", "oauth2 openid connect dotnet for developers", "oauth2 openid connect dotnet checklist", "oauth2 openid connect dotnet tips", "oauth2 openid connect dotnet deep dive", "oauth2 openid connect dotnet comparison", "oauth2 openid connect dotnet vs alternatives", "oauth2 openid connect dotnet .NET Core", "oauth2 openid connect dotnet Azure", "oauth2 openid connect dotnet explained", "oauth2 openid connect dotnet when to use", "oauth2 openid connect dotnet enterprise", "oauth2 openid connect dotnet .NET", "what is oauth2 openid connect dotnet", "oauth2 openid connect dotnet summary", "oauth2 openid connect dotnet introduction", "oauth2 openid connect dotnet fundamentals", "oauth2 openid connect dotnet step by step", "oauth2 openid connect dotnet complete guide", "oauth2 openid connect dotnet for beginners", "oauth2 openid connect dotnet advanced", "oauth2 openid connect dotnet production", "oauth2 openid connect dotnet real world", "oauth2 openid connect dotnet example code", "oauth2 openid connect dotnet C# example", "oauth2 openid connect dotnet .NET example", "learn oauth2 openid connect dotnet", "oauth2 openid connect dotnet learn", "oauth2 openid connect dotnet reference", "oauth2 openid connect dotnet cheat sheet", "oauth2 openid connect dotnet pitfalls", "oauth2 openid connect dotnet common mistakes", "oauth2 openid connect dotnet performance", "oauth2 openid connect dotnet optimization", "oauth2 openid connect dotnet security", "oauth2 openid connect dotnet testing", "oauth2 openid connect dotnet unit test", "oauth2 openid connect dotnet integration", "oauth2 openid connect dotnet migration", "oauth2 openid connect dotnet from scratch", "oauth2 openid connect dotnet 2024", "oauth2 openid connect dotnet 2025", "best oauth2 openid connect dotnet", "oauth2 openid connect dotnet best", "pro oauth2 openid connect dotnet", "oauth2 openid connect dotnet expert", "oauth2 openid connect dotnet consultant", "oauth2 openid connect dotnet services", "oauth2 openid connect dotnet course", "oauth2 openid connect dotnet workshop", "oauth2 openid connect dotnet webinar", "oauth2 openid connect dotnet blog", "oauth2 openid connect dotnet article", "oauth2 openid connect dotnet post", "why oauth2 openid connect dotnet", "when oauth2 openid connect dotnet", "where oauth2 openid connect dotnet", "oauth2 openid connect dotnet in .NET 6", "oauth2 openid connect dotnet in .NET 7", "oauth2 openid connect dotnet in .NET 8", "oauth2 openid connect dotnet for C#", "oauth2 openid connect dotnet for Angular", "oauth2 openid connect dotnet for Vue", "oauth2 openid connect dotnet for React", "oauth2 openid connect dotnet for Azure", "oauth2 openid connect dotnet for microservices", "oauth2 openid connect dotnet for API", "oauth2 openid connect dotnet for database", "oauth2 openid connect dotnet for testing", "oauth2 openid connect dotnet for DevOps", "oauth2 openid connect dotnet for senior developers", "oauth2 openid connect dotnet for team", "oauth2 openid connect dotnet for production", "oauth2 openid connect dotnet for scale", "oauth2 openid connect dotnet for refactoring", "oauth2 openid connect dotnet for enterprise applications", "oauth2 openid connect dotnet for startup", "oauth2 openid connect dotnet in 2024", "oauth2 openid connect dotnet in 2025", "oauth2 openid connect dotnet in 2026", "oauth2 openid connect dotnet code sample", "oauth2 openid connect dotnet code example", "oauth2 openid connect dotnet sample code", "oauth2 openid connect dotnet full example", "oauth2 openid connect dotnet working example", "oauth2 openid connect dotnet practical oauth2 openid connect dotnet", "oauth2 openid connect dotnet real world example", "oauth2 openid connect dotnet use case", "oauth2 openid connect dotnet use cases", "oauth2 openid connect dotnet scenario", "oauth2 openid connect dotnet scenarios", "oauth2 openid connect dotnet pattern", "oauth2 openid connect dotnet approach", "oauth2 openid connect dotnet approaches", "oauth2 openid connect dotnet strategy", "oauth2 openid connect dotnet strategies", "oauth2 openid connect dotnet technique", "oauth2 openid connect dotnet techniques", "oauth2 openid connect dotnet method", "oauth2 openid connect dotnet methods", "oauth2 openid connect dotnet solution", "oauth2 openid connect dotnet solutions", "oauth2 openid connect dotnet implementation guide", "oauth2 openid connect dotnet getting started", "oauth2 openid connect dotnet quick start", "oauth2 openid connect dotnet overview guide", "oauth2 openid connect dotnet comprehensive guide", "oauth2 openid connect dotnet detailed guide", "oauth2 openid connect dotnet practical guide", "oauth2 openid connect dotnet developer guide", "oauth2 openid connect dotnet engineer guide", "oauth2 openid connect dotnet architect guide", "oauth2 openid connect dotnet for architects", "oauth2 openid connect dotnet for backend", "oauth2 openid connect dotnet for tech leads", "oauth2 openid connect dotnet for senior devs", "benefits of oauth2 openid connect dotnet", "advantages of oauth2 openid connect dotnet", "alternatives to oauth2 openid connect dotnet", "compared to oauth2 openid connect dotnet", "intro to oauth2 openid connect dotnet", "basics of oauth2 openid connect dotnet", "oauth2 openid connect dotnet tips and tricks", "oauth2 openid connect dotnet production-ready", "oauth2 openid connect dotnet enterprise-grade", "oauth2 openid connect dotnet with Docker", "oauth2 openid connect dotnet with Kubernetes", "oauth2 openid connect dotnet in ASP.NET Core", "oauth2 openid connect dotnet with Entity Framework", "oauth2 openid connect dotnet with EF Core", "oauth2 openid connect dotnet modern", "oauth2 openid connect dotnet updated", "oauth2 openid connect dotnet latest", "oauth2 openid connect dotnet walkthrough", "oauth2 openid connect dotnet hands-on", "oauth2 openid connect dotnet practical examples", "oauth2 openid connect dotnet real-world examples", "oauth2 openid connect dotnet common pitfalls", "oauth2 openid connect dotnet gotchas", "oauth2 openid connect dotnet FAQ", "oauth2 openid connect dotnet FAQs", "oauth2 openid connect dotnet Q&A", "oauth2 openid connect dotnet interview questions", "oauth2 openid connect dotnet interview", "oauth2 openid connect dotnet certification", "oauth2 openid connect dotnet training", "oauth2 openid connect dotnet video", "oauth2 openid connect dotnet series", "oauth2 openid connect dotnet part 1", "oauth2 openid connect dotnet core concepts", "oauth2 openid connect dotnet key concepts", "oauth2 openid connect dotnet recap", "oauth2 openid connect dotnet takeaways", "oauth2 openid connect dotnet conclusion", "oauth2 openid connect dotnet next steps", "oauth2 openid connect dotnet further reading", "oauth2 openid connect dotnet resources", "oauth2 openid connect dotnet tools", "oauth2 openid connect dotnet libraries", "oauth2 openid connect dotnet frameworks", "oauth2 openid connect dotnet NuGet", "oauth2 openid connect dotnet package", "oauth2 openid connect dotnet GitHub", "oauth2 openid connect dotnet open source", "oauth2 openid connect dotnet community", "oauth2 openid connect dotnet Microsoft docs", "oauth2 openid connect dotnet documentation", "oauth2 openid connect dotnet official guide", "oauth2 openid connect dotnet official tutorial", "oauth2 openid connect with .NET Core", "oauth2 openid connect dotnet ASP.NET Core", "Oauth2", "Oauth2 guide", "Oauth2 tutorial", "Oauth2 best practices", "Oauth2 in .NET", "Oauth2 in C#", "Oauth2 for developers", "Oauth2 examples", "Oauth2 patterns", "Oauth2 overview", "Oauth2 introduction", "Oauth2 deep dive", "Oauth2 explained", "Oauth2 how to", "Oauth2 what is"],
  relatedServices: ["full-stack-development","technical-leadership"],
  relatedProjects: ["bat-inhouse-app","airasia-id90"],
  relatedArticleSlugs: ["securing-apis-dotnet","full-stack-net-angular-enterprise"],
  author: "Waqas Ahmad",
  content: `## Introduction

This guidance is relevant when the topic of this article applies to your system or design choices; it breaks down when constraints or context differ. I've applied it in real projects and refined the takeaways over time (as of 2026).

**OAuth2** and **OpenID Connect (OIDC)** are the standards for modern authentication and authorisation. OAuth2 handles **authorisation**—letting applications access resources on behalf of users. OpenID Connect extends OAuth2 for **authentication**—establishing who the user is.

If you are building APIs, SPAs, or mobile apps in .NET, you will use these protocols. This article covers OAuth2 and OIDC in depth: the flows, how to validate JWTs in ASP.NET Core, how to secure APIs, and common pitfalls to avoid.

## Topics covered

- [Decision Context](#decision-context)
- [What is OAuth2?](#what-is-oauth2)
- [What is OpenID Connect?](#what-is-openid-connect)
- [OAuth2 flows](#oauth2-flows)
- [Tokens: access, ID, refresh](#tokens-access-id-refresh)
- [JWT validation in ASP.NET Core](#jwt-validation-in-aspnet-core)
- [Scopes and claims](#scopes-and-claims)
- [Securing APIs](#securing-apis)
- [Securing SPAs](#securing-spas)
- [Enterprise best practices](#enterprise-best-practices)
- [Common issues](#common-issues)
- [Summary](#summary)
- [Position & Rationale](#position--rationale)
- [Trade-Offs & Failure Modes](#trade-offs--failure-modes)
- [What Most Guides Miss](#what-most-guides-miss)
- [Decision Framework](#decision-framework)
- [Key Takeaways](#key-takeaways)
- [When I Would Use This Again — and When I Wouldn't](#when-i-would-use-this-again--and-when-i-wouldnt)
- [Frequently Asked Questions](#frequently-asked-questions)

## Decision Context

- **System scale:** APIs and SPAs (or native apps) that need to authenticate users or call APIs on behalf of users or services. Applies when you're adding or refining auth (OAuth2/OIDC) in .NET.
- **Team size:** Backend and front-end; someone must own token validation, scopes, and secure storage. Works when the team can configure an identity provider (Azure AD, Auth0, etc.) and validate JWTs correctly.
- **Time / budget pressure:** Fits when you have an IdP and can use Authorization Code + PKCE for SPAs; breaks down when you try to invent your own auth or store secrets in the client.
- **Technical constraints:** ASP.NET Core; OAuth2/OIDC; JWT validation; Azure AD, Auth0, or similar IdP. Assumes you use HTTPS and don't log or expose tokens.
- **Non-goals:** This article does not optimise for legacy or custom auth schemes; it focuses on OAuth2 and OpenID Connect in .NET with standard flows.

## What is OAuth2?

**OAuth2** is an authorisation framework. It lets a client application obtain limited access to a resource (API) on behalf of a user, without the user sharing their password.

**Key concepts:**
- **Resource Owner:** The user who owns the data
- **Client:** The application requesting access
- **Authorization Server:** Issues tokens (e.g. Azure AD, Auth0, IdentityServer)
- **Resource Server:** The API that accepts tokens

**OAuth2 does not tell you who the user is**—only that they granted permission. That is where OpenID Connect comes in.

## What is OpenID Connect?

**OpenID Connect (OIDC)** is a layer on top of OAuth2 that adds authentication. It introduces:
- **ID Token:** A JWT containing user identity claims (\`sub\`, \`name\`, \`email\`)
- **UserInfo Endpoint:** Returns user profile data
- **Standard Claims:** \`sub\` (subject), \`iss\` (issuer), \`aud\` (audience), \`exp\` (expiration)

Use OIDC when you need to know **who** the user is, not just that they are authorised.

## OAuth2 flows

| Flow | Use case | Client type |
|------|----------|-------------|
| **Authorization Code** | User login (SPA, mobile, web) | Confidential or public |
| **Authorization Code + PKCE** | Public clients (SPA, mobile) | Public |
| **Client Credentials** | Machine-to-machine (no user) | Confidential |
| **Implicit** | Legacy; avoid | Public |
| **Device Code** | Devices without browser (TV, CLI) | Public |

### Authorization Code Flow

Used when a user logs in via a browser:

1. App redirects user to Authorization Server
2. User logs in and consents
3. Authorization Server redirects back with a **code**
4. App exchanges code for **access token** (and optionally **refresh token**)

\`\`\`
GET /authorize?
  response_type=code&
  client_id=myapp&
  redirect_uri=https://myapp.com/callback&
  scope=openid profile api.read&
  state=xyz

POST /token
  grant_type=authorization_code&
  code=abc123&
  redirect_uri=https://myapp.com/callback&
  client_id=myapp&
  client_secret=secret
\`\`\`

### Authorization Code + PKCE

For public clients (SPAs, mobile apps) that cannot securely store a client secret:

1. App generates a **code_verifier** (random string) and **code_challenge** (hash of verifier)
2. App sends code_challenge in the authorize request
3. After receiving code, app sends code_verifier in the token request
4. Authorization Server verifies the challenge

\`\`\`csharp
// Generate PKCE values
var codeVerifier = GenerateRandomString(64);
var codeChallenge = Base64Url(SHA256(codeVerifier));

// Authorize request includes code_challenge
// Token request includes code_verifier
\`\`\`

### Client Credentials Flow

For machine-to-machine (no user involved):

\`\`\`
POST /token
  grant_type=client_credentials&
  client_id=backend-service&
  client_secret=secret&
  scope=api.read api.write
\`\`\`

## Tokens: access, ID, refresh

| Token | Purpose | Lifetime |
|-------|---------|----------|
| **Access Token** | Authorise API calls | Short (minutes to hours) |
| **ID Token** | Authenticate user (identity) | Short |
| **Refresh Token** | Get new access token without login | Long (days to weeks) |

**Access Token** is sent to the API in the \`Authorization: Bearer\` header. The API validates it.

**ID Token** is for the client application only. It contains user identity claims. Do not send it to APIs.

**Refresh Token** is stored securely (httpOnly cookie or secure storage). Use it to obtain new access tokens.

## JWT validation in ASP.NET Core

**JWT (JSON Web Token)** is the common format for access and ID tokens. ASP.NET Core validates JWTs using the \`Microsoft.AspNetCore.Authentication.JwtBearer\` package.

\`\`\`csharp
// Program.cs
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        options.Authority = "https://login.microsoftonline.com/{tenant}/v2.0";
        options.Audience = "api://my-api-client-id";
        
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuer = true,
            ValidateAudience = true,
            ValidateLifetime = true,
            ValidateIssuerSigningKey = true
        };
    });

builder.Services.AddAuthorization();

var app = builder.Build();
app.UseAuthentication();
app.UseAuthorization();
\`\`\`

**What happens:**
1. JWT Bearer middleware extracts token from \`Authorization: Bearer\` header
2. Fetches signing keys from Authority's JWKS endpoint
3. Validates signature, issuer, audience, expiration
4. Populates \`HttpContext.User\` with claims

## Scopes and claims

**Scopes** define what the token can access. The client requests scopes; the Authorization Server includes them in the token.

\`\`\`json
{
  "aud": "api://my-api",
  "iss": "https://login.microsoftonline.com/{tenant}/v2.0",
  "sub": "user-id",
  "scp": "api.read api.write",
  "exp": 1700000000
}
\`\`\`

**Validate scopes in .NET:**

\`\`\`csharp
// Policy-based authorization
builder.Services.AddAuthorization(options =>
{
    options.AddPolicy("ReadAccess", policy =>
        policy.RequireClaim("scp", "api.read"));
    
    options.AddPolicy("WriteAccess", policy =>
        policy.RequireClaim("scp", "api.write"));
});

// Controller
[Authorize(Policy = "WriteAccess")]
[HttpPost]
public async Task<IActionResult> CreateOrder(CreateOrderRequest request)
{
    // Only callers with api.write scope can reach here
}
\`\`\`

## Securing APIs

**1. Always validate tokens.** Use JWT Bearer middleware with correct Authority and Audience.

**2. Validate scopes.** Do not accept any valid token—check that it has the required scopes.

**3. Use HTTPS.** Tokens are bearer tokens; anyone with the token can use it.

**4. Set short token lifetimes.** Minutes to hours for access tokens. Use refresh tokens for longer sessions.

**5. Never log tokens.** Access tokens in logs are a security risk.

\`\`\`csharp
[ApiController]
[Route("api/[controller]")]
[Authorize]
public class OrdersController : ControllerBase
{
    [HttpGet]
    [Authorize(Policy = "ReadAccess")]
    public async Task<IActionResult> GetOrders()
    {
        var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
        // Return only this user's orders
    }
}
\`\`\`

## Securing SPAs

SPAs are public clients—they cannot securely store secrets. Best practices:

**1. Use Authorization Code + PKCE.** No client secret required.

**2. Store tokens in memory or secure cookie.** Never in localStorage (XSS vulnerable).

**3. Use silent refresh or refresh tokens in httpOnly cookie.** Avoid prompting user repeatedly.

**4. Backend For Frontend (BFF) pattern.** Keep tokens server-side; SPA uses session cookie.

\`\`\`csharp
// BFF pattern: proxy API calls, attach token server-side
app.MapGet("/api/orders", async (HttpContext context, IHttpClientFactory factory) =>
{
    var accessToken = await context.GetTokenAsync("access_token");
    var client = factory.CreateClient();
    client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", accessToken);
    return await client.GetFromJsonAsync<Order[]>("https://api.example.com/orders");
});
\`\`\`

## Enterprise best practices

**1. Use Azure AD or established IdP.** Do not roll your own authentication.

**2. Validate all claims.** Issuer, audience, expiration, signature. Do not skip validation.

**3. Use PKCE for all public clients.** Required for SPAs and mobile apps.

**4. Store refresh tokens securely.** HttpOnly cookie or secure server-side storage.

**5. Implement token revocation.** For sensitive actions, check token validity against a revocation list.

**6. Use short-lived access tokens.** 5-60 minutes. Refresh tokens extend the session.

**7. Monitor for anomalies.** Log authentication events; alert on unusual patterns.

**8. Rotate client secrets.** Regularly rotate secrets for confidential clients.

## Common issues

| Issue | Cause | Fix |
|-------|-------|-----|
| **401 Unauthorized** | Wrong audience or issuer | Match Authority and Audience exactly |
| **Token expired** | Lifetime exceeded | Use refresh token; reduce access token lifetime |
| **Invalid signature** | Wrong signing key | Ensure JWKS endpoint is correct |
| **Missing scope** | Token lacks required scope | Client must request scope; API must validate |
| **CORS errors** | Cross-origin blocked | Configure CORS for your SPA domain |
| **Token in URL** | Query string leaked in logs | Use Authorization header only |

## Summary

OAuth2 handles authorisation; OpenID Connect adds authentication. Use Authorization Code + PKCE for user login, Client Credentials for machine-to-machine. Validate JWTs with correct Authority, Audience, and scopes. Store tokens securely, use HTTPS, and never log tokens.

## Position & Rationale

I use **Authorization Code + PKCE** for SPAs and native apps—no client secret in the client; the IdP issues tokens after user consent. I use **Client Credentials** for server-to-server or background jobs when there’s no user. I **validate JWTs** with the correct Authority (issuer), Audience, and signing keys (JWKS); I never skip audience or scope checks. I store **tokens** in memory or secure storage (e.g. httpOnly cookie for web); I never put access or refresh tokens in localStorage for SPAs if I can avoid it (cookie or backend session is safer). I avoid implicit flow and resource-owner password flow for new apps; they’re deprecated or insecure. I don’t log tokens or put them in URLs.

## Trade-Offs & Failure Modes

**OAuth2/OIDC** adds dependency on an IdP and correct validation; you gain standard, delegatable auth. **PKCE** adds a step in the flow; you gain security for public clients. **JWT validation** must be strict (issuer, audience, scope, expiry); wrong config leads to broken auth or over-privilege. Failure modes: wrong audience or scope validation (API accepts tokens meant for another app); tokens in URL or logs (leak); client secret in SPA (never do that); skipping PKCE for public clients.

## What Most Guides Miss

Most guides show “add JWT bearer” but don’t stress **audience validation**—if you don’t validate audience, any token from the same IdP can call your API. **Scope** validation is often omitted; the API must check that the token has the scope for the operation. **Token storage** in SPAs (localStorage vs cookie vs backend session) has security trade-offs; many tutorials use localStorage without mentioning refresh token rotation and XSS. **Refresh token** handling (where to store, when to rotate) is underplayed.

## Decision Framework

- **If user login (SPA or native)** → Authorization Code + PKCE; no client secret in the client.
- **If server-to-server or daemon** → Client Credentials; store client secret server-side only.
- **For API** → Validate JWT: Authority, Audience, scopes; use JWKS from the IdP.
- **For tokens** → Store in memory or secure cookie; never in URL or logs; use HTTPS.
- **For SPAs** → Prefer backend session or secure cookie for tokens; if using localStorage, understand XSS and refresh rotation.

## Key Takeaways

- **OAuth2** = authorisation; **OIDC** = authentication (ID token, user info). Use **Authorization Code + PKCE** for SPAs/native; **Client Credentials** for machine-to-machine.
- **Validate** JWT: issuer, audience, scopes, expiry; use JWKS. Never skip audience.
- Store tokens securely; never in URL or logs; never client secret in the client.
- Avoid implicit and resource-owner password flows for new apps.

## When I Would Use This Again — and When I Wouldn't

I’d use **OAuth2/OIDC** again for any API or SPA that needs user or service auth—standard flows and JWT validation with a proper IdP. I’d use **PKCE** for every public client. I wouldn’t implement my own token issuance or store client secrets in the front end. I also wouldn’t deploy without validating audience and scopes on the API; otherwise tokens from other apps can be accepted.

## Frequently Asked Questions

### What is OAuth2?

**OAuth2** is an authorisation framework that lets apps access resources on behalf of users without sharing passwords. It issues access tokens.

### What is OpenID Connect?

**OIDC** extends OAuth2 for authentication. It adds ID tokens containing user identity claims (\`sub\`, \`name\`, \`email\`).

### What is JWT?

**JWT** (JSON Web Token) is a signed token format containing claims. Validated by the API using the issuer's public key.

### What is the difference between access token and ID token?

**Access token** authorises API calls. **ID token** contains user identity—use it in your app, not for API calls.

### When should I use Authorization Code vs Client Credentials?

**Authorization Code** for user login (SPA, mobile, web). **Client Credentials** for service-to-service (no user).

### What is PKCE?

**PKCE** (Proof Key for Code Exchange) secures the Authorization Code flow for public clients that cannot store a secret.

### Where should I store tokens in a SPA?

In memory or httpOnly cookie. Never in localStorage (vulnerable to XSS).

### How do I validate scopes in .NET?

Use policy-based authorization: \`options.AddPolicy("ReadAccess", policy => policy.RequireClaim("scp", "api.read"))\`.

### What is a refresh token?

A long-lived token used to obtain new access tokens without re-prompting the user.

### How do I handle token expiration?

Use refresh tokens to get new access tokens silently. Implement token refresh in your client.

### What is the BFF pattern?

**Backend For Frontend** keeps tokens server-side. The SPA uses a session cookie; the BFF proxies API calls with the token.

### How do I revoke tokens?

Implement a token revocation endpoint or use short-lived tokens. For critical actions, check a revocation list.

### What Authority should I use for Azure AD?

\`https://login.microsoftonline.com/{tenant}/v2.0\` for v2.0 endpoint. Use your tenant ID or "common" for multi-tenant.

### What is the difference between issuer and audience?

**Issuer** is who issued the token (the IdP). **Audience** is who the token is intended for (your API).

### How do I debug JWT issues?

Decode the token at jwt.io (never in production with real tokens). Check issuer, audience, expiration, and scopes.`,
  faqs: [
  {
    "question": "What is OAuth2?",
    "answer": "Authorisation framework that lets apps access resources on behalf of users without sharing passwords."
  },
  {
    "question": "What is OpenID Connect?",
    "answer": "Extends OAuth2 for authentication. Adds ID tokens with user identity claims (sub, name, email)."
  },
  {
    "question": "What is JWT?",
    "answer": "JSON Web Token—signed token format with claims. Validated using issuer public key."
  },
  {
    "question": "Access token vs ID token?",
    "answer": "Access token authorises API calls. ID token contains identity—use in app, not for APIs."
  },
  {
    "question": "Authorization Code vs Client Credentials?",
    "answer": "Auth Code for user login. Client Credentials for service-to-service (no user)."
  },
  {
    "question": "What is PKCE?",
    "answer": "Proof Key for Code Exchange—secures Auth Code flow for public clients without secrets."
  },
  {
    "question": "Where store tokens in SPA?",
    "answer": "In memory or httpOnly cookie. Never localStorage (XSS vulnerable)."
  },
  {
    "question": "How validate scopes in .NET?",
    "answer": "Policy-based authorization: RequireClaim(\"scp\", \"api.read\")."
  },
  {
    "question": "What is a refresh token?",
    "answer": "Long-lived token to get new access tokens without re-prompting user."
  },
  {
    "question": "How handle token expiration?",
    "answer": "Use refresh tokens to get new access tokens silently."
  },
  {
    "question": "What is BFF pattern?",
    "answer": "Backend For Frontend—keeps tokens server-side, SPA uses session cookie."
  },
  {
    "question": "How revoke tokens?",
    "answer": "Token revocation endpoint or short-lived tokens. Check revocation list for critical actions."
  },
  {
    "question": "What Authority for Azure AD?",
    "answer": "https://login.microsoftonline.com/{tenant}/v2.0 for v2.0 endpoint."
  },
  {
    "question": "Issuer vs audience?",
    "answer": "Issuer is who issued token (IdP). Audience is who token is for (your API)."
  },
  {
    "question": "How debug JWT issues?",
    "answer": "Decode at jwt.io (not production). Check issuer, audience, expiration, scopes."
  }
]
}
