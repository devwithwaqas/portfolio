/**
 * Blog article: full-stack-net-angular-enterprise
 * Auto-generated by scripts/split-blog-articles.js. Do not edit the content here by hand if you run the split script again.
 */

export default {
  slug: "full-stack-net-angular-enterprise",
  title: "Full-Stack .NET and Angular for Enterprise Applications",
  excerpt: "In-depth guide to full-stack .NET and Angular for enterprise: solution structure, API design (OpenAPI, versioning, DTOs), authentication (OAuth2, JWT, cookies), Angular HTTP interceptor, deployment and CI/CD, contract tests and preventing API drift, CORS and environment config. Maximum code examples for .NET and Angular. Cross-links to Vue vs Angular vs React comparison.",
  date: "2025-02-11",
  topic: "Full-Stack",
  keywords: ["Full-Stack .NET and Angular for Enterprise Applications", "Full Stack Net Angular Enterprise", "Full Stack Net Angular Enterprise best practices", "how to full stack net angular enterprise", "full stack net angular enterprise in .NET", "full stack net angular enterprise guide", "full stack net angular enterprise for enterprise", "full stack net angular enterprise patterns", "when to use full stack net angular enterprise", "full stack net angular enterprise tutorial", "full stack net angular enterprise examples", "full stack net angular enterprise in C#", "full stack net angular enterprise overview", "full stack net angular enterprise implementation", "understanding full stack net angular enterprise", "full stack net angular enterprise for developers", "full stack net angular enterprise checklist", "full stack net angular enterprise tips", "full stack net angular enterprise deep dive", "full stack net angular enterprise comparison", "full stack net angular enterprise vs alternatives", "full stack net angular enterprise .NET Core", "full stack net angular enterprise Azure", "full stack net angular enterprise explained", "full stack net angular enterprise when to use", "full stack net angular enterprise enterprise", "full stack net angular enterprise .NET", "what is full stack net angular enterprise", "full stack net angular enterprise summary", "full stack net angular enterprise introduction", "full stack net angular enterprise fundamentals", "full stack net angular enterprise step by step", "full stack net angular enterprise complete guide", "full stack net angular enterprise for beginners", "full stack net angular enterprise advanced", "full stack net angular enterprise production", "full stack net angular enterprise real world", "full stack net angular enterprise example code", "full stack net angular enterprise C# example", "full stack net angular enterprise .NET example", "learn full stack net angular enterprise", "full stack net angular enterprise learn", "full stack net angular enterprise reference", "full stack net angular enterprise cheat sheet", "full stack net angular enterprise pitfalls", "full stack net angular enterprise common mistakes", "full stack net angular enterprise performance", "full stack net angular enterprise optimization", "full stack net angular enterprise security", "full stack net angular enterprise testing", "full stack net angular enterprise unit test", "full stack net angular enterprise integration", "full stack net angular enterprise migration", "full stack net angular enterprise from scratch", "full stack net angular enterprise 2024", "full stack net angular enterprise 2025", "best full stack net angular enterprise", "full stack net angular enterprise best", "pro full stack net angular enterprise", "full stack net angular enterprise expert", "full stack net angular enterprise consultant", "full stack net angular enterprise services", "full stack net angular enterprise course", "full stack net angular enterprise workshop", "full stack net angular enterprise webinar", "full stack net angular enterprise blog", "full stack net angular enterprise article", "full stack net angular enterprise post", "why full stack net angular enterprise", "when full stack net angular enterprise", "where full stack net angular enterprise", "full stack net angular enterprise in .NET 6", "full stack net angular enterprise in .NET 7", "full stack net angular enterprise in .NET 8", "full stack net angular enterprise for C#", "full stack net angular enterprise for Angular", "full stack net angular enterprise for Vue", "full stack net angular enterprise for React", "full stack net angular enterprise for Azure", "full stack net angular enterprise for microservices", "full stack net angular enterprise for API", "full stack net angular enterprise for database", "full stack net angular enterprise for testing", "full stack net angular enterprise for DevOps", "full stack net angular enterprise for senior developers", "full stack net angular enterprise for team", "full stack net angular enterprise for production", "full stack net angular enterprise for scale", "full stack net angular enterprise for refactoring", "full stack net angular enterprise for enterprise applications", "full stack net angular enterprise for startup", "full stack net angular enterprise in 2024", "full stack net angular enterprise in 2025", "full stack net angular enterprise in 2026", "full stack net angular enterprise code sample", "full stack net angular enterprise code example", "full stack net angular enterprise sample code", "full stack net angular enterprise full example", "full stack net angular enterprise working example", "full stack net angular enterprise practical full stack net angular enterprise", "full stack net angular enterprise real world example", "full stack net angular enterprise use case", "full stack net angular enterprise use cases", "full stack net angular enterprise scenario", "full stack net angular enterprise scenarios", "full stack net angular enterprise pattern", "full stack net angular enterprise approach", "full stack net angular enterprise approaches", "full stack net angular enterprise strategy", "full stack net angular enterprise strategies", "full stack net angular enterprise technique", "full stack net angular enterprise techniques", "full stack net angular enterprise method", "full stack net angular enterprise methods", "full stack net angular enterprise solution", "full stack net angular enterprise solutions", "full stack net angular enterprise implementation guide", "full stack net angular enterprise getting started", "full stack net angular enterprise quick start", "full stack net angular enterprise overview guide", "full stack net angular enterprise comprehensive guide", "full stack net angular enterprise detailed guide", "full stack net angular enterprise practical guide", "full stack net angular enterprise developer guide", "full stack net angular enterprise engineer guide", "full stack net angular enterprise architect guide", "full stack net angular enterprise for architects", "full stack net angular enterprise for backend", "full stack net angular enterprise for tech leads", "full stack net angular enterprise for senior devs", "benefits of full stack net angular enterprise", "advantages of full stack net angular enterprise", "alternatives to full stack net angular enterprise", "compared to full stack net angular enterprise", "intro to full stack net angular enterprise", "basics of full stack net angular enterprise", "full stack net angular enterprise tips and tricks", "full stack net angular enterprise production-ready", "full stack net angular enterprise enterprise-grade", "full stack net angular enterprise with Docker", "full stack net angular enterprise with Kubernetes", "full stack net angular enterprise in ASP.NET Core", "full stack net angular enterprise with Entity Framework", "full stack net angular enterprise with EF Core", "full stack net angular enterprise modern", "full stack net angular enterprise updated", "full stack net angular enterprise latest", "full stack net angular enterprise walkthrough", "full stack net angular enterprise hands-on", "full stack net angular enterprise practical examples", "full stack net angular enterprise real-world examples", "full stack net angular enterprise common pitfalls", "full stack net angular enterprise gotchas", "full stack net angular enterprise FAQ", "full stack net angular enterprise FAQs", "full stack net angular enterprise Q&A", "full stack net angular enterprise interview questions", "full stack net angular enterprise interview", "full stack net angular enterprise certification", "full stack net angular enterprise training", "full stack net angular enterprise video", "full stack net angular enterprise series", "full stack net angular enterprise part 1", "full stack net angular enterprise core concepts", "full stack net angular enterprise key concepts", "full stack net angular enterprise recap", "full stack net angular enterprise takeaways", "full stack net angular enterprise conclusion", "full stack net angular enterprise next steps", "full stack net angular enterprise further reading", "full stack net angular enterprise resources", "full stack net angular enterprise tools", "full stack net angular enterprise libraries", "full stack net angular enterprise frameworks", "full stack net angular enterprise NuGet", "full stack net angular enterprise package", "full stack net angular enterprise GitHub", "full stack net angular enterprise open source", "full stack net angular enterprise community", "full stack net angular enterprise Microsoft docs", "full stack net angular enterprise documentation", "full stack net angular enterprise official guide", "full stack net angular enterprise official tutorial", "Full", "Full guide", "Full tutorial", "Full best practices", "Full in .NET", "Full in C#", "Full for developers", "Full examples", "Full patterns", "Full overview", "Full introduction", "Full deep dive", "Full explained", "Full how to", "Full what is", "Full when to use", "Full for enterprise", "Full .NET Core", "Full Azure", "Full C#", "Full with .NET", "Full with C#", "Full with Azure", "Full with Angular", "Full with Vue", "Full with React", "Full with Entity Framework", "Full with SQL Server", "Full step by step", "Full complete guide", "Full from scratch", "Full 2024", "Full 2025", "Full 2026", "Full code example", "Full sample code", "Full implementation", "Full real world", "Full production", "Full for beginners", "Full advanced", "Full for architects", "Full for backend", "Full for API", "Full in ASP.NET Core", "Full with EF Core", "Full tutorial 2024", "Full guide 2025", "Full best practices 2024", "Full C# examples", "Full .NET examples", "Full implementation guide", "Full how to implement", "Full benefits", "Full advantages", "Full pitfalls", "Full alternatives", "Full compared", "Full intro", "Full basics", "Full tips and tricks", "Full production-ready", "Full enterprise-grade", "Full maintainable", "Full testable", "Full refactoring", "Full modern", "Full updated", "Full latest", "Full for tech leads", "Full for senior devs", "Full with Docker", "Full with Kubernetes", "Full in .NET 8", "Full in .NET 7", "Full in .NET 6", "Full Stack", "Full Stack guide", "Full Stack tutorial", "Full Stack best practices", "Full Stack in .NET", "Full Stack in C#", "Full Stack for developers", "Full Stack examples", "Full Stack patterns", "Full Stack overview", "Full Stack introduction", "Full Stack deep dive", "Full Stack explained", "Full Stack how to", "Full Stack what is", "Full Stack when to use", "Full Stack for enterprise", "Full Stack .NET Core", "Full Stack Azure", "Full Stack C#", "Full Stack with .NET", "Full Stack with C#", "Full Stack with Azure", "Full Stack with Angular", "Full Stack with Vue", "Full Stack with React", "Full Stack with Entity Framework", "Full Stack with SQL Server", "Full Stack step by step", "Full Stack complete guide", "Full Stack from scratch", "Full Stack 2024", "Full Stack 2025", "Full Stack 2026", "Full Stack code example", "Full Stack sample code", "Full Stack implementation", "Full Stack real world", "Full Stack production", "Full Stack for beginners", "Full Stack advanced", "Full Stack for architects", "Full Stack for backend", "Full Stack for API", "Full Stack in ASP.NET Core", "Full Stack with EF Core", "Full Stack tutorial 2024", "Full Stack guide 2025", "Full Stack best practices 2024", "Full Stack C# examples", "Full Stack .NET examples", "Full Stack implementation guide", "Full Stack how to implement", "Full Stack benefits", "Full Stack advantages", "Full Stack pitfalls", "Full Stack alternatives", "Full Stack compared", "Full Stack intro", "Full Stack basics", "Full Stack tips and tricks", "Full Stack production-ready", "Full Stack enterprise-grade", "Full Stack maintainable", "Full Stack testable", "Full Stack refactoring", "Full Stack modern", "Full Stack updated", "Full Stack latest", "Full Stack for tech leads", "Full Stack for senior devs", "Full Stack with Docker", "Full Stack with Kubernetes", "Full Stack in .NET 8", "Full Stack in .NET 7", "Full Stack in .NET 6", "Full Stack Net", "Full Stack Net guide", "Full Stack Net tutorial", "Full Stack Net best practices", "Full Stack Net in .NET", "Full Stack Net in C#", "Full Stack Net for developers", "Full Stack Net examples", "Full Stack Net patterns", "Full Stack Net overview", "Full Stack Net introduction", "Full Stack Net deep dive", "Full Stack Net explained", "Full Stack Net how to", "Full Stack Net what is", "Full Stack Net when to use", "Full Stack Net for enterprise", "Full Stack Net .NET Core", "Full Stack Net Azure", "Full Stack Net C#", "Full Stack Net with .NET", "Full Stack Net with C#", "Full Stack Net with Azure", "Full Stack Net with Angular", "Full Stack Net with Vue", "Full Stack Net with React", "Full Stack Net with Entity Framework", "Full Stack Net with SQL Server", "Full Stack Net step by step", "Full Stack Net complete guide", "Full Stack Net from scratch", "Full Stack Net 2024", "Full Stack Net 2025", "Full Stack Net 2026", "Full Stack Net code example", "Full Stack Net sample code", "Full Stack Net implementation", "Full Stack Net real world", "Full Stack Net production", "Full Stack Net for beginners", "Full Stack Net advanced", "Full Stack Net for architects", "Full Stack Net for backend", "Full Stack Net for API", "Full Stack Net in ASP.NET Core", "Full Stack Net with EF Core", "Full Stack Net tutorial 2024", "Full Stack Net guide 2025", "Full Stack Net best practices 2024", "Full Stack Net C# examples", "Full Stack Net .NET examples", "Full Stack Net implementation guide", "Full Stack Net how to implement", "Full Stack Net benefits", "Full Stack Net advantages", "Full Stack Net pitfalls", "Full Stack Net alternatives", "Full Stack Net compared", "Full Stack Net intro", "Full Stack Net basics", "Full Stack Net tips and tricks", "Full Stack Net production-ready", "Full Stack Net enterprise-grade", "Full Stack Net maintainable", "Full Stack Net testable", "Full Stack Net refactoring", "Full Stack Net modern", "Full Stack Net updated", "Full Stack Net latest", "Full Stack Net for tech leads", "Full Stack Net for senior devs", "Full Stack Net with Docker", "Full Stack Net with Kubernetes", "Full Stack Net in .NET 8", "Full Stack Net in .NET 7", "Full Stack Net in .NET 6", "Full Stack Net Angular", "Full Stack Net Angular guide", "Full Stack Net Angular tutorial", "Full Stack Net Angular best practices", "Full Stack Net Angular in .NET", "Full Stack Net Angular in C#", "Full Stack Net Angular for developers", "Full Stack Net Angular examples", "Full Stack Net Angular patterns", "Full Stack Net Angular overview", "Full Stack Net Angular introduction", "Full Stack Net Angular deep dive", "Full Stack Net Angular explained", "Full Stack Net Angular how to", "Full Stack Net Angular what is", "Full Stack Net Angular when to use", "Full Stack Net Angular for enterprise", "Full Stack Net Angular .NET Core", "Full Stack Net Angular Azure", "Full Stack Net Angular C#", "Full Stack Net Angular with .NET", "Full Stack Net Angular with C#", "Full Stack Net Angular with Azure", "Full Stack Net Angular with Angular", "Full Stack Net Angular with Vue", "Full Stack Net Angular with React", "Full Stack Net Angular with Entity Framework", "Full Stack Net Angular with SQL Server", "Full Stack Net Angular step by step", "Full Stack Net Angular complete guide", "Full Stack Net Angular from scratch", "Full Stack Net Angular 2024", "Full Stack Net Angular 2025", "Full Stack Net Angular 2026", "Full Stack Net Angular code example", "Full Stack Net Angular sample code", "Full Stack Net Angular implementation", "Full Stack Net Angular real world", "Full Stack Net Angular production", "Full Stack Net Angular for beginners", "Full Stack Net Angular advanced", "Full Stack Net Angular for architects", "Full Stack Net Angular for backend", "Full Stack Net Angular for API", "Full Stack Net Angular in ASP.NET Core", "Full Stack Net Angular with EF Core", "Full Stack Net Angular tutorial 2024", "Full Stack Net Angular guide 2025", "Full Stack Net Angular best practices 2024", "Full Stack Net Angular C# examples", "Full Stack Net Angular .NET examples", "Full Stack Net Angular implementation guide", "Full Stack Net Angular how to implement", "Full Stack Net Angular benefits"],
  relatedServices: ["full-stack-development","microservices-architecture"],
  relatedProjects: ["bat-inhouse-app","gamified-employee-management"],
  relatedArticleSlugs: ["vue-vs-angular-vs-react-full-comparison","database-optimization-entity-framework","securing-apis-dotnet"],
  author: "Waqas Ahmad",
  content: `## Introduction

This guidance is relevant when the topic of this article applies to your system or design choices; it breaks down when constraints or context differ. I've applied it in real projects and refined the takeaways over time (as of 2026).

Enterprise **full-stack** applications built with **.NET** backends and **Angular** frontends require **clear API boundaries**, **consistent authentication**, and **scalable deployment**. Over 17 years delivering production systems—from large-scale employee portals to mission-critical microservices—I have seen teams succeed when they invest in **API contracts**, **OpenAPI specs**, and a **single deployment pipeline** from day one. This article is a **full, in-depth** guide to **full-stack .NET and Angular for enterprise**: what full-stack development is, why .NET + Angular (or .NET + any SPA) fits enterprise, and how to **structure your solution**, **design your API**, **secure it** with OAuth2/OpenID Connect and JWT, **deploy** with CI/CD, and **prevent API drift** with contract tests. Every section includes **concrete C# and Angular/TypeScript examples** so you can apply the patterns directly.

Whether you are starting a new greenfield project or modernising an existing system, the principles below will help you avoid the usual pitfalls: **API drift** between frontend and backend, **auth inconsistencies**, and **deployment bottlenecks**. If you are new to full-stack or to .NET + SPA, we start with the basics and then go through solution structure, API design, auth, deployment, and testing with maximum code examples.

If you are new to full-stack .NET + Angular, start with [Topics covered](#topics-covered) and [Full-stack .NET + Angular at a glance](#full-stack-net--angular-at-a-glance). We explain **full-stack**, **API design**, **OpenAPI**, **auth**, **deployment**, and **contract tests** with concrete detail.

## Topics covered

- [Decision Context](#decision-context)
- [What is full-stack development and why .NET + Angular?](#what-is-full-stack-development-and-why-net--angular)
- [What is API design and why does it matter?](#what-is-api-design-and-why-does-it-matter)
- [Full-stack .NET + Angular at a glance](#full-stack-net--angular-at-a-glance)
- [Solution structure: backend and frontend](#solution-structure-backend-and-frontend)
- [API design: OpenAPI, versioning, DTOs](#api-design-openapi-versioning-dtos)
- [Authentication and authorization: OAuth2, JWT, cookies](#authentication-and-authorization-oauth2-jwt-cookies)
- [Frontend–backend flow and Angular HTTP interceptor](#frontendbackend-flow-and-angular-http-interceptor)
- [Choosing the frontend: Angular vs Vue vs React](#choosing-the-frontend-angular-vs-vue-vs-react)
- [Which architecture when: monolith, modular monolith, microservices](#which-architecture-when-monolith-modular-monolith-microservices)
- [Deployment and CI/CD](#deployment-and-cicd)
- [Contract tests and preventing API drift](#contract-tests-and-preventing-api-drift)
- [CORS and environment configuration](#cors-and-environment-configuration)
- [Common issues and challenges](#common-issues-and-challenges)
- [Best practices and pitfalls](#best-practices-and-pitfalls)
- [Summary](#summary)
- [Position & Rationale](#position--rationale)
- [Trade-Offs & Failure Modes](#trade-offs--failure-modes)
- [What Most Guides Miss](#what-most-guides-miss)
- [Decision Framework](#decision-framework)
- [Key Takeaways](#key-takeaways)
- [When I Would Use This Again — and When I Wouldn't](#when-i-would-use-this-again--and-when-i-wouldnt)
- [Frequently Asked Questions](#frequently-asked-questions)

------

## Decision Context

- **System scale:** Varies by context; the approach in this article applies to the scales and scenarios described in the body.
- **Team size:** Typically small to medium teams; ownership and clarity matter more than headcount.
- **Time / budget pressure:** Applicable under delivery pressure; I've used it in both greenfield and incremental refactors.
- **Technical constraints:** .NET and related stack where relevant; constraints are noted in the article where they affect the approach.
- **Non-goals:** This article does not optimize for every possible scenario; boundaries are stated where they matter.


## What is full-stack development and why .NET + Angular?

**Full-stack development** means building both the **front end** (what the user sees and interacts with in the browser) and the **back end** (the API and data layer that the front end calls). In enterprise settings, the **back end** is often responsible for **auth**, **business rules**, and **persistence**; the **front end** focuses on **UX** and **presentation**. Splitting the two lets teams specialise and deploy independently—but only if the **contract** between them (the **API**) is clear and stable.

**.NET (ASP.NET Core)** is a strong choice for the back end: it is fast, well-supported on Azure, and fits teams that already use C# and Visual Studio. **Angular** is a **full front-end framework** with routing, forms, HTTP client, and testing built in; it uses **TypeScript** by default and enforces a clear structure (modules, components, services). The combination works well when you want **one language family** (TypeScript/C#) across the stack, **strong typing**, and a **single deployment story** (e.g. API + SPA from one pipeline). You do not have to use Angular—**Vue** and **React** are also common with .NET backends—but this article focuses on patterns that apply to **.NET + any SPA**, with **Angular** as the main example. For a detailed **framework comparison** (Vue vs Angular vs React), see [Vue vs Angular vs React: Full Comparison](/blog/vue-vs-angular-vs-react-full-comparison).

---

## What is API design and why does it matter?

**API design** is how you define the **contract** between the front end and the back end: **endpoints**, **request/response shapes**, **status codes**, and **auth**. A well-designed API is **consistent** (e.g. RESTful conventions, versioned), **documented** (e.g. OpenAPI/Swagger), and **stable** so that the front end does not break when the back end evolves. **Why it matters:** Without a clear contract, the front end and back end **drift**—fields are renamed, endpoints change, and integration breaks in subtle ways. Use **OpenAPI** as the single source of truth, **version** your API (e.g. \`/api/v1/...\`), and return **DTOs** (data transfer objects) that match what the client needs, not raw entity shapes. We show concrete examples below.

---

## Full-stack .NET + Angular at a glance

| Area | What it is | Why it matters |
|------|------------|----------------|
| **OpenAPI** | Standard description of your API (endpoints, shapes, auth) | Single source of truth; generate Angular client; contract tests in CI |
| **API versioning** | URL path or header (e.g. \`/api/v1/orders\`) | Evolve the API without breaking existing clients |
| **JWT / OAuth2** | Token-based auth; validate on every request | Stateless, scalable; use httpOnly cookie or Bearer as appropriate |
| **Single pipeline** | One CI/CD that builds API + Angular, runs tests, deploys both | Consistent releases; no frontend/backend version skew |
| **Contract tests** | OpenAPI diff or Pact; run in CI | Catch breaking changes before merge |
| **CORS** | Browser policy for cross-origin API calls | API must allow frontend origin; never wildcard for credentialed requests |

\`\`\`mermaid
sequenceDiagram
  participant User
  participant Angular
  participant API
  participant IdP
  User->>Angular: Login
  Angular->>IdP: Auth request
  IdP->>Angular: Token
  Angular->>API: Request + Bearer token
  API->>API: Validate token
  API->>Angular: Response
  Angular->>User: Render
\`\`\`

---

## Solution structure: backend and frontend

Keep the **API** and the **Angular app** in one repo (monorepo) or in two repos with a **single pipeline** that builds both. A typical layout:

\`\`\`
MyApp.sln
  src/
    MyApp.Api/           # ASP.NET Core API
      Controllers/
      Program.cs
    MyApp.Application/   # Use cases, DTOs (optional)
    MyApp.Infrastructure/
  frontend/              # Angular app
    src/
      app/
        core/            # Auth, HTTP, guards
        features/        # Feature modules (orders, profile)
        shared/
\`\`\`

**Backend: Program.cs (minimal)** – enable OpenAPI and auth:

\`\`\`csharp
// MyApp.Api/Program.cs
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen(c =>
{
    c.SwaggerDoc("v1", new OpenApiInfo { Title = "My API", Version = "v1" });
    c.AddSecurityDefinition("Bearer", new OpenApiSecurityScheme
    {
        Type = SecuritySchemeType.Http,
        Scheme = "bearer",
        Description = "JWT Bearer token"
    });
});
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        options.Authority = builder.Configuration["Auth:Authority"];
        options.Audience = builder.Configuration["Auth:Audience"];
    });
builder.Services.AddCors(options =>
{
    options.AddDefaultPolicy(policy =>
    {
        policy.WithOrigins(builder.Configuration["Cors:AllowedOrigins"]!.Split(';'))
            .AllowAnyMethod().AllowAnyHeader().AllowCredentials();
    });
});

var app = builder.Build();
app.UseCors();
app.UseAuthentication();
app.UseAuthorization();
app.MapControllers();
app.Run();
\`\`\`

**What this does:** Registers **Swagger/OpenAPI**, **JWT authentication**, and **CORS** with config-driven origins. Controllers and DTOs define the API surface; we add versioning and DTO examples next.

---

## API design: OpenAPI, versioning, DTOs

Design your API around **use cases**, not database shapes. Return **DTOs** with only the fields the client needs; use **projection** on the server to avoid over-fetching. Expose an **OpenAPI** spec so the front end can generate a typed client.

**Example: versioned controller and DTO**

\`\`\`csharp
// MyApp.Api/Controllers/V1/OrdersController.cs
[ApiController]
[Route("api/v{version:apiVersion}/[controller]")]
[ApiVersion("1.0")]
public class OrdersController : ControllerBase
{
    private readonly IOrderService _orderService;

    public OrdersController(IOrderService orderService) => _orderService = orderService;

    [HttpGet("{id}")]
    [ProducesResponseType(typeof(OrderDto), StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    public async Task<ActionResult<OrderDto>> GetById(int id, CancellationToken ct)
    {
        var order = await _orderService.GetByIdAsync(id, ct);
        if (order == null) return NotFound();
        return Ok(order);
    }
}

// DTO – only what the client needs
public record OrderDto(int Id, string CustomerName, DateTime OrderDate, decimal Total, List<OrderLineDto> Lines);
public record OrderLineDto(string ProductName, int Quantity, decimal Amount);
\`\`\`

**Register API versioning:**

\`\`\`csharp
builder.Services.AddApiVersioning(options =>
{
    options.DefaultApiVersion = new ApiVersion(1, 0);
    options.AssumeDefaultVersionWhenUnspecified = true;
    options.ReportApiVersions = true;
});
\`\`\`

**What this does:** \`/api/v1/orders/42\` returns an \`OrderDto\`; the OpenAPI spec includes the shape so the Angular app can generate a client. Use **projection** in your service/repository so that \`OrderDto\` is built from the database without loading more than needed (see [Database Optimization with EF Core](/blog/database-optimization-entity-framework) for projection patterns).

---

## Authentication and authorization: OAuth2, JWT, cookies

Use **OAuth2 / OpenID Connect** with a trusted identity provider (Azure AD, IdentityServer, or a managed service). Prefer **JWT bearer tokens** for stateless APIs. Validate the token on every request and enforce **scopes** or **roles** in your API.

**JWT validation (already in Program.cs above):**

\`\`\`csharp
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        options.Authority = "https://your-tenant.b2clogin.com/...";
        options.Audience = "api://your-api";
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuer = true,
            ValidateAudience = true,
            ValidateLifetime = true
        };
    });
\`\`\`

**Authorize by role or policy:**

\`\`\`csharp
[Authorize(Roles = "Admin")]
[HttpGet("admin/orders")]
public async Task<ActionResult<List<OrderDto>>> GetAdminOrders(CancellationToken ct) { ... }
\`\`\`

On the **Angular** side, use an **HTTP interceptor** to attach the token and handle **401** (e.g. refresh or redirect to login). **Never** store tokens in \`localStorage\` if you can avoid it in sensitive apps; use **memory** or **httpOnly cookies** for the access token when the app and API share a domain. We show the interceptor in the next section.

---

## Frontend–backend flow and Angular HTTP interceptor

A typical flow: the user logs in, the front end receives a token, and **every API call** includes the token. The back end validates the token and authorises the request.

**Angular HTTP interceptor – attach Bearer token and handle 401:**

\`\`\`typescript
// frontend/src/app/core/auth/auth.interceptor.ts
import { HttpInterceptorFn, HttpErrorResponse } from '@angular/common/http';
import { inject } from '@angular/core';
import { catchError, switchMap, throwError } from 'rxjs';
import { AuthService } from './auth.service';

export const authInterceptor: HttpInterceptorFn = (req, next) => {
  const auth = inject(AuthService);
  const token = auth.getAccessToken();
  if (token) {
    req = req.clone({
      setHeaders: { Authorization: \`Bearer \${token}\` }
    });
  }
  return next(req).pipe(
    catchError((err: HttpErrorResponse) => {
      if (err.status === 401 && auth.hasRefreshToken()) {
        return auth.refreshToken().pipe(
          switchMap(() => {
            const newToken = auth.getAccessToken();
            const cloned = req.clone({
              setHeaders: { Authorization: \`Bearer \${newToken}\` }
            });
            return next(cloned);
          }),
          catchError(() => {
            auth.logout();
            return throwError(() => err);
          })
        );
      }
      return throwError(() => err);
    })
  );
};
\`\`\`

**What this does:** Every outgoing request gets an \`Authorization: Bearer <token>\` header. On **401**, the interceptor tries to **refresh** the token once; if refresh fails, it logs out. Register the interceptor in \`app.config.ts\` with \`provideHttpClient(withInterceptors([authInterceptor]))\`.

**Token storage:** For **same-domain** setups, prefer **httpOnly cookie** for the access token (or refresh token) so that XSS cannot steal it; use **SameSite** and **Secure** and handle **CSRF**. For **cross-domain** SPAs, **Bearer token in memory** plus **refresh token in httpOnly cookie** is a common pattern.

---

## Choosing the frontend: Angular vs Vue vs React

Choosing a front-end framework for enterprise full-stack with .NET depends on **team skills**, **project scale**, **timeline**, and **ecosystem fit**.

- **Angular**: Full framework (routing, forms, HTTP, testing built in); TypeScript by default; strong conventions. Fits **enterprise** and **long-lived** projects. Steeper learning curve; pairs very well with .NET teams that value structure and DI.
- **Vue**: Progressive; gentle learning curve; Composition API and composables. Fits **mid-size to large** apps when you want structure without rigidity.
- **React**: Library-first; largest ecosystem and hiring pool. Fits **product-led** teams; you assemble routing, state, and forms from the ecosystem.

**All three** work well with .NET backends via **OpenAPI** and **JWT**; the **backend patterns** (API design, auth, deployment) are the same. For a **detailed comparison** (metrics, decision matrix, .NET fit), see [Vue vs Angular vs React: Full Comparison](/blog/vue-vs-angular-vs-react-full-comparison).

---

## Which architecture when: monolith, modular monolith, microservices

Not every system should be microservices. **Monolith** (single deployable unit) is the right default for many apps: simpler operations, one codebase, and transactional consistency. **Modular monolith** keeps one deployable but **bounded contexts** in code (separate assemblies or modules) so you can **extract** a service later if needed. **Microservices** make sense when you have **multiple teams**, **independent scaling**, or **tech diversity** requirements.

**When to stay monolith:** Small team, single domain, no need for independent scaling. **When to adopt modular monolith:** You expect growth; you want clear boundaries and the option to extract services later. **When to go microservices:** Multiple teams, independent release cycles, or scaling/resilience needs that justify the cost. For most .NET + front-end projects, **start with a modular monolith** and split only when pain justifies it.

---

## Deployment and CI/CD

Invest in a **single pipeline** that builds both the .NET API and the Angular app, runs tests, and deploys to your environment (e.g. Azure App Service or containers).

**Pipeline steps (conceptual):**

\`\`\`
1. Restore & build .NET API
2. Run API unit/integration tests
3. Build Angular app (e.g. ng build --configuration=production)
4. (Optional) Run contract tests (OpenAPI diff / Pact)
5. Deploy API (e.g. Azure App Service, container)
6. Deploy Angular output (same host static files or CDN)
\`\`\`

**Environment configuration:** The front end must know the **API base URL** and (if needed) tenant or auth authority per environment. Use **environment files** (e.g. \`environment.prod.ts\`) or **build-time replacement** so that the Angular app points to the correct back end in each environment. **Never** hardcode production URLs in the front end.

\`\`\`typescript
// frontend/src/environments/environment.prod.ts
export const environment = {
  production: true,
  apiUrl: 'https://api.myapp.com',
  authAuthority: 'https://your-tenant.b2clogin.com/...'
};
\`\`\`

Apply **SOLID** and **clean architecture** on the back end: controllers thin, business logic in services, persistence behind repositories so the API stays testable and evolvable.

---

## Contract tests and preventing API drift

**API drift** is when the front end and back end get out of sync: the API returns a new shape or renames a field and the front end breaks. Prevent it by treating the **OpenAPI spec** as the **single source of truth**, **generating** the front-end client from it, and running **contract tests** in CI.

**Generate Angular client from OpenAPI (e.g. NSwag):**

\`\`\`bash
npx @openapitools/openapi-generator-cli generate -i https://localhost:5001/swagger/v1/swagger.json -g typescript-angular -o src/app/api-client
\`\`\`

**Contract test in CI:** After the API build, compare the **current** OpenAPI spec to the **previous** (or to the client’s expected schema). If there are **breaking changes** (e.g. removed field, changed type), **fail the build**. So that breaking changes are caught before merge. Use **OpenAPI diff** tools or **Pact** (consumer-driven contracts) depending on your workflow.

---

## CORS and environment configuration

**CORS (Cross-Origin Resource Sharing):** When the Angular app (e.g. \`https://app.example.com\`) calls the API (e.g. \`https://api.example.com\`), the browser sends an \`Origin\` header and may send a **preflight** (OPTIONS) request. The API must respond with \`Access-Control-Allow-Origin\` and related headers. In .NET, use \`AddCors()\` with a **policy** that allows your front-end origin(s). **Never** use wildcard (\`*\`) for **credentialed** requests in production.

\`\`\`csharp
builder.Services.AddCors(options =>
{
    options.AddDefaultPolicy(policy =>
    {
        policy.WithOrigins(builder.Configuration["Cors:AllowedOrigins"]!.Split(';'))
            .AllowAnyMethod()
            .AllowAnyHeader()
            .AllowCredentials();
    });
});
// ...
app.UseCors();
\`\`\`

**appsettings.Production.json:** Store allowed origins per environment; never commit production URLs in source. Use **secret management** (e.g. Azure Key Vault, pipeline variables) for production origins.

---

## Common issues and challenges

**API drift:** Without a single source of truth (OpenAPI spec), the front end and back end diverge. **Fix:** Generate client from the spec; run contract tests in CI.

**Auth inconsistencies:** Token storage (localStorage vs httpOnly cookie), refresh logic, and scope handling differ between teams. **Fix:** Standardise on one approach; use interceptors to attach tokens and handle 401/refresh in one place.

**CORS and certificates:** Wrong CORS origins or missing certificates in production cause hard-to-debug failures. **Fix:** Environment-specific config for allowed origins; document TLS and certificate rotation.

**Deployment coupling:** Deploying front end and back end separately can leave the app in an inconsistent state. **Fix:** Single pipeline that builds both and deploys in order; or use **feature flags** and **backward-compatible** API versioning so releases are safe.

**Over-fetching and N+1:** Returning full entities and loading navigation properties in loops causes slow APIs. **Fix:** Use **projection** (DTOs) and **eager loading** only for what the client needs; see [Database Optimization with EF Core](/blog/database-optimization-entity-framework).

---

## Best practices and pitfalls

**Do:**

- Use **OpenAPI** as the single source of truth; generate the Angular client from it.
- **Version** the API (URL path or header) so you can evolve without breaking clients.
- Use **JWT** (or OAuth2) with a trusted identity provider; validate and enforce roles/scopes.
- Use a **single pipeline** that builds both API and Angular and runs contract tests.
- Prefer **httpOnly cookie** for tokens when app and API share a domain (XSS-safe).
- Keep **controllers** thin; put business logic in **services** and persistence in **repositories**.

**Don't:**

- Don't let the API and front end **drift**; run contract tests in CI.
- Don't store **access tokens** in \`localStorage\` in sensitive apps (XSS risk).
- Don't use **CORS wildcard** for credentialed requests in production.
- Don't **hardcode** production API URLs in the front end; use environment config.
- Don't **over-fetch**; return DTOs that match what the client needs.

---
---

## Position & Rationale

I treat **OpenAPI** as the single source of truth for the API contract and generate the front-end client from it; I avoid hand-maintained API clients and ad-hoc types. I prefer **one pipeline** that builds both .NET API and Angular (or any SPA), runs contract tests, and deploys both so we never ship front-end and back-end out of sync. I use **JWT** (or OAuth2) with a trusted identity provider and validate on every request; I avoid custom auth schemes unless there's a clear reason. I recommend **httpOnly cookies** for tokens when the app and API share a domain to reduce XSS risk; I reject storing access tokens in \`localStorage\` for sensitive apps. I start with a **modular monolith** and move to microservices only when multiple teams or scaling justify the cost. I rank **contract tests** (OpenAPI diff or Pact) in CI as non-negotiable to prevent API drift.

---

## Trade-Offs & Failure Modes

- **What this sacrifices:** A single pipeline and generated client add upfront setup; versioning and backward compatibility require discipline. Modular monolith still means one deployable; you don't get independent scaling per service until you split.
- **Where it degrades:** Without contract tests, the API and front end drift and break in subtle ways. Hard-coded API URLs or CORS misconfiguration cause environment-specific failures. Over-fetching and N+1 slow the API when DTOs and projection aren't used.
- **How it fails when misapplied:** Building only the API or only the front end in CI so releases get out of sync. Using CORS wildcard with credentials in production. Storing tokens in \`localStorage\` in a sensitive app (XSS). Skipping API versioning so every change breaks existing clients.
- **Early warning signs:** "The front end works in dev but not prod"; "we're not sure which API version the app is calling"; manual client updates after every API change.

---

## What Most Guides Miss

Tutorials often show auth and CORS in isolation and skip **contract testing**. Without OpenAPI as the single source of truth and CI that fails on breaking changes, teams discover API drift only when the front end breaks in staging or production. Another gap: **token storage**—many examples use \`localStorage\`, which is vulnerable to XSS; the trade-off between httpOnly cookies (same-domain, CSRF handling) and Bearer in memory (cross-domain) is rarely explained. Environment configuration (API URL, CORS origins) per environment is also underplayed; hard-coded URLs and wildcard CORS cause hard-to-debug production failures.

---

## Decision Framework

- **If you have a .NET API and a SPA (Angular, Vue, React)** → Use OpenAPI as the contract; generate the client; run contract tests in CI; version the API (path or header).
- **If you deploy API and front end** → Use one pipeline that builds both and deploys both; use environment-specific config for API URL and CORS origins.
- **If you need auth** → Use OAuth2/OpenID Connect and JWT; validate on the API; use an interceptor to attach the token and handle 401/refresh; prefer httpOnly cookie when same-domain.
- **If the API and front end are drifting** → Introduce OpenAPI as source of truth, generate client, add contract tests; fix breaking changes before they reach production.
- **If you're choosing monolith vs microservices** → Start with a modular monolith; split only when multiple teams, independent release, or scaling justify it.

---

## Key Takeaways

- OpenAPI + generated client + contract tests in CI prevent API drift; version the API so you can evolve without breaking clients.
- One pipeline for API and SPA; environment-specific config for URLs and CORS; never hard-code production URLs in the front end.
- Auth: JWT validation on the API; interceptor for token and 401/refresh; prefer httpOnly cookie when same-domain; avoid \`localStorage\` for access tokens in sensitive apps.
- Start with a modular monolith; apply SOLID and clean architecture on the back end; revisit microservices when pain justifies the cost.


## Summary

- **Full-stack** .NET + Angular (or .NET + any SPA) requires **clear API boundaries**, **OpenAPI**, **consistent auth** (OAuth2/JWT), and a **single deployment pipeline**.
- Use **OpenAPI** and **versioning**; generate the front-end client and run **contract tests** in CI to prevent **API drift**.
- **Auth:** JWT validation on the API; Angular interceptor to attach token and handle 401/refresh. Prefer **httpOnly cookie** when same-domain.
- **Deployment:** Build both API and Angular in one pipeline; use **environment-specific** config for API URL and CORS origins.
- Apply **SOLID** and **clean architecture** on the back end. Use the FAQs below as a quick reference when designing and operating .NET + Angular (or Vue/React) systems.

---

## When I Would Use This Again — and When I Wouldn't

I would use this .NET + Angular (or .NET + any SPA) approach again for any enterprise full-stack product where we need a clear API contract, consistent auth, and a single deployment story. I'd insist on OpenAPI, generated client, and contract tests from day one. I wouldn't use it when the "front end" is a small internal script or a single server-rendered app with no separate API—overkill. I wouldn't skip contract tests or versioning to save time; the cost of drift and breaking changes is higher. If the team cannot own both API and front-end pipeline (or coordinate tightly), I'd still apply the same backend patterns but accept that deployment and contract discipline may need to be enforced by process until the pipeline is in place.


---

## Frequently Asked Questions

### When should I use Angular vs Vue or React for enterprise full-stack with .NET?

**Angular** fits when you want a full framework (routing, forms, HTTP, testing) and strong typing out of the box; it pairs well with .NET teams that value structure. **Vue** and **React** are lighter; choose Vue for balance and incremental adoption, React for ecosystem and hiring. All work well with .NET backends via OpenAPI and JWT. For a detailed comparison, see [Vue vs Angular vs React](/blog/vue-vs-angular-vs-react-full-comparison).

### How do I keep the frontend and backend API in sync?

Use **OpenAPI (Swagger)** as the single source of truth; **generate** client types (e.g. NSwag, OpenAPI Generator) for the front end and run **contract tests** in CI so that breaking changes fail the build. **Version** the API (URL path or header) so you can evolve without breaking existing clients.

### What is the best way to store tokens for a .NET + Angular app?

For **SPAs**, prefer **httpOnly cookies** when the app and API **share a domain** so that XSS cannot steal the token; use **SameSite** and **Secure** and handle **CSRF**. When **cross-domain**, **Bearer token in memory** plus **refresh token** in httpOnly cookie is common. **Avoid** storing access tokens in \`localStorage\` in sensitive apps.

### How do I structure a .NET backend for testability and SOLID?

Keep **controllers** thin (validation, orchestration only); put **business logic** in **services** and **persistence** in **repositories**. Use **dependency injection** for all dependencies so you can unit test with mocks. Apply **Single Responsibility** and **Dependency Inversion** so high-level modules do not depend on low-level details.

### What are common CI/CD mistakes for full-stack .NET + frontend?

Building only one part of the stack, **hard-coding** environment URLs, and **missing contract tests**. Use a **single pipeline** that builds both, uses **secret management** for connection strings and API URLs, and runs **API contract tests** (e.g. OpenAPI diff or Pact) so front end and back end stay compatible.

### How do I handle API versioning with Angular and .NET?

Use **URL path versioning** (\`/api/v1/orders\`) or **header versioning** (\`Api-Version: 1\`). Document in OpenAPI; generate the client for the version the front end uses. Support at least **two versions** during migration so existing clients do not break.

### What is OpenAPI and why does it matter for .NET + Angular?

**OpenAPI** (formerly Swagger) is a standard way to **describe** your API: endpoints, request/response shapes, and auth. When you expose an OpenAPI spec from your .NET API, the front end can **generate** a typed client so the Angular app stays in sync. **Contract tests** in CI can compare the spec to the front end’s expectations and fail the build on breaking changes. Without a spec, the front end and back end **drift** and integration breaks.

### How do I deploy .NET API and Angular app together?

Use a **single pipeline**: restore and build the .NET API, run API tests, build the Angular app (e.g. \`ng build --configuration=production\`), then **deploy** the API and the Angular output (e.g. to the same App Service or API + static site). Use **environment-specific** config (API base URL, tenant ID) so the front end points to the right back end in each environment. Never hardcode production URLs in the front end.

### What is API drift and how do I prevent it?

**API drift** is when the front end and back end get out of sync: the API returns a new shape or renames a field and the front end breaks. **Prevent** it by treating the **OpenAPI spec** as the single source of truth, **generating** the front-end client from it, and running **contract tests** in CI so breaking changes fail the build before merge.

### When should I use cookies vs bearer tokens for .NET + SPA?

Use **httpOnly cookies** when the app and API **share a domain** so that XSS cannot steal the token; use **SameSite** and **Secure** and handle **CSRF**. When **cross-domain** (e.g. SPA on different host), **Bearer token in memory** plus **refresh token** in httpOnly cookie is common. Avoid storing access tokens in \`localStorage\` in sensitive apps; they are vulnerable to XSS.

### How do I run contract tests in CI for .NET + Angular?

Use **OpenAPI diff** (compare spec to previous version) or **Pact** (consumer-driven contracts) in your pipeline. Run them **after** the API build so breaking changes fail before merge. Generate the Angular client from the spec so that **compile-time** errors catch mismatches when the spec changes.

### What is CORS and how do I configure it for .NET + Angular?

**CORS** is a browser mechanism: when the Angular app (e.g. on \`https://app.example.com\`) calls the API (e.g. on \`https://api.example.com\`), the browser sends an \`Origin\` header and may send a **preflight** (OPTIONS). The API must respond with \`Access-Control-Allow-Origin\` and related headers. In .NET, use \`AddCors()\` with a policy that allows your front-end origin(s). **Never** use wildcard for **credentialed** requests in production.

### How do I structure the Angular app for a large .NET-backed product?

Use **feature modules** (e.g. orders, profile, admin) and **lazy loading** so each feature loads on demand. Keep **shared** components and services in a core or shared module. Align folder structure with the API’s **bounded contexts**. Use the **generated API client** in a dedicated service layer so components do not call the API directly.

### What is the difference between Angular and Vue/React for .NET back ends?

**All three** work with .NET via **OpenAPI** and **JWT**. Angular is a **full framework** (routing, forms, HTTP built in); Vue and React are **lighter** and require more choices (state, routing). **Back-end patterns** (API design, auth, deployment) are the same; choose by **team skills** and **project scale**. See [Vue vs Angular vs React](/blog/vue-vs-angular-vs-react-full-comparison) for a full comparison.

### How do I handle refresh tokens in an Angular + .NET app?

Store the **refresh token** in an httpOnly cookie (or secure storage); when the access token expires, call a **refresh endpoint** with the refresh token to get a new access token. Use an **HTTP interceptor** to attach the access token and, on **401**, try refresh **once** before redirecting to login. Implement refresh on the .NET side with a **short-lived** access token and **longer-lived** refresh token; **revoke** refresh tokens on logout.

### When should I choose monolith vs microservices for .NET + front-end?

**Start** with a **modular monolith**: one deployable with **clear bounded contexts** in code. Move to **microservices** only when you have **multiple teams**, **independent release cycles**, or **scaling/resilience** needs that justify the operational cost. Most .NET + front-end projects do not need microservices from day one.`,
  faqs: [
  {
    "question": "When should I use Angular vs Vue or React for enterprise full-stack with .NET?",
    "answer": "Angular fits when you want a full framework (routing, forms, HTTP, testing) and strong typing; it pairs well with .NET teams that value structure. Vue and React are lighter; choose Vue for balance, React for ecosystem and hiring. All work with .NET via OpenAPI and JWT. See Vue vs Angular vs React for a full comparison."
  },
  {
    "question": "How do I keep the frontend and backend API in sync?",
    "answer": "Use OpenAPI (Swagger) as the single source of truth; generate client types (e.g. NSwag, OpenAPI Generator) for the frontend and run contract tests in CI so breaking changes fail the build. Version the API (URL path or header) so you can evolve without breaking existing clients."
  },
  {
    "question": "What is the best way to store tokens for a .NET + Angular app?",
    "answer": "For SPAs, prefer httpOnly cookies when the app and API share a domain (XSS-safe); use SameSite and Secure and handle CSRF. When cross-domain, Bearer token in memory plus refresh token in httpOnly cookie is common. Avoid storing access tokens in localStorage in sensitive apps."
  },
  {
    "question": "How do I structure a .NET backend for testability and SOLID?",
    "answer": "Keep controllers thin (validation, orchestration only); put business logic in services and persistence in repositories. Use dependency injection for all dependencies so you can unit test with mocks. Apply Single Responsibility and Dependency Inversion."
  },
  {
    "question": "What are common CI/CD mistakes for full-stack .NET + frontend?",
    "answer": "Building only one part of the stack, hard-coding environment URLs, and missing contract tests. Use a single pipeline that builds both, uses secret management for API URLs, and runs API contract tests (OpenAPI diff or Pact) so frontend and backend stay compatible."
  },
  {
    "question": "How do I handle API versioning with Angular and .NET?",
    "answer": "Use URL path versioning (/api/v1/orders) or header versioning (Api-Version: 1). Document in OpenAPI; generate client for the version the frontend uses. Support at least two versions during migration so existing clients do not break."
  },
  {
    "question": "What is OpenAPI and why does it matter for .NET + Angular?",
    "answer": "OpenAPI describes your API (endpoints, shapes, auth). Expose it from .NET; generate a typed client for Angular so the app stays in sync. Contract tests in CI can catch breaking changes before merge. Without a spec, frontend and backend drift."
  },
  {
    "question": "How do I deploy .NET API and Angular app together?",
    "answer": "Use a single pipeline: build API, run tests, build Angular (ng build --configuration=production), then deploy both (e.g. same App Service or API + static site). Use environment-specific config for API URL and tenant ID."
  },
  {
    "question": "What is API drift and how do I prevent it?",
    "answer": "API drift is when frontend and backend get out of sync. Prevent it with OpenAPI as single source of truth, generated client, and contract tests in CI so breaking changes fail the build before merge."
  },
  {
    "question": "When should I use cookies vs bearer tokens for .NET + SPA?",
    "answer": "Use httpOnly cookies when app and API share a domain (XSS-safe). When cross-domain, use Bearer token in memory plus refresh token in httpOnly cookie. Avoid localStorage for access tokens in sensitive apps."
  },
  {
    "question": "How do I run contract tests in CI for .NET + Angular?",
    "answer": "Use OpenAPI diff (compare spec to previous version) or Pact in the pipeline after the API build. Generate the Angular client from the spec so compile-time errors catch mismatches when the spec changes."
  },
  {
    "question": "What is CORS and how do I configure it for .NET + Angular?",
    "answer": "CORS lets the browser allow cross-origin API calls. In .NET use AddCors() with a policy allowing your frontend origin(s). Never use wildcard for credentialed requests in production."
  },
  {
    "question": "How do I structure the Angular app for a large .NET-backed product?",
    "answer": "Use feature modules and lazy loading; keep shared components and services in core/shared. Align structure with API bounded contexts; use the generated API client in a dedicated service layer."
  },
  {
    "question": "What is the difference between Angular and Vue/React for .NET back ends?",
    "answer": "All work with .NET via OpenAPI and JWT. Angular is a full framework; Vue and React are lighter. Back-end patterns are the same; choose by team skills and scale. See Vue vs Angular vs React for a full comparison."
  },
  {
    "question": "How do I handle refresh tokens in an Angular + .NET app?",
    "answer": "Store refresh token in httpOnly cookie; on 401 use an interceptor to call refresh endpoint and retry once. Implement short-lived access token and longer-lived refresh token on .NET; revoke on logout."
  },
  {
    "question": "When should I choose monolith vs microservices for .NET + front-end?",
    "answer": "Start with a modular monolith: one deployable with clear bounded contexts in code. Move to microservices only when you have multiple teams, independent release cycles, or scaling/resilience needs that justify the cost."
  }
]
}
