/**
 * Blog article: repository-pattern-unit-of-work-dotnet
 * Auto-generated by scripts/split-blog-articles.js. Do not edit the content here by hand if you run the split script again.
 */

export default {
  slug: "repository-pattern-unit-of-work-dotnet",
  title: "Repository Pattern and Unit of Work in .NET",
  excerpt: "In-depth look at Repository and Unit of Work patterns in .NET: when to use them and how they fit with EF Core.",
  date: "2025-07-27",
  topic: "Architecture",
  keywords: ["Repository Pattern and Unit of Work in .NET", "Repository Pattern Unit Of Work Dotnet", "Repository Pattern Unit Of Work Dotnet best practices", "how to repository pattern unit of work dotnet", "repository pattern unit of work dotnet in .NET", "repository pattern unit of work dotnet guide", "repository pattern unit of work dotnet for enterprise", "repository pattern unit of work dotnet patterns", "when to use repository pattern unit of work dotnet", "repository pattern unit of work dotnet tutorial", "repository pattern unit of work dotnet examples", "repository pattern unit of work dotnet in C#", "repository pattern unit of work dotnet overview", "repository pattern unit of work dotnet implementation", "understanding repository pattern unit of work dotnet", "repository pattern unit of work dotnet for developers", "repository pattern unit of work dotnet checklist", "repository pattern unit of work dotnet tips", "repository pattern unit of work dotnet deep dive", "repository pattern unit of work dotnet comparison", "repository pattern unit of work dotnet vs alternatives", "repository pattern unit of work dotnet .NET Core", "repository pattern unit of work dotnet Azure", "repository pattern unit of work dotnet explained", "repository pattern unit of work dotnet when to use", "repository pattern unit of work dotnet enterprise", "repository pattern unit of work dotnet .NET", "what is repository pattern unit of work dotnet", "repository pattern unit of work dotnet summary", "repository pattern unit of work dotnet introduction", "repository pattern unit of work dotnet fundamentals", "repository pattern unit of work dotnet step by step", "repository pattern unit of work dotnet complete guide", "repository pattern unit of work dotnet for beginners", "repository pattern unit of work dotnet advanced", "repository pattern unit of work dotnet production", "repository pattern unit of work dotnet real world", "repository pattern unit of work dotnet example code", "repository pattern unit of work dotnet C# example", "repository pattern unit of work dotnet .NET example", "learn repository pattern unit of work dotnet", "repository pattern unit of work dotnet learn", "repository pattern unit of work dotnet reference", "repository pattern unit of work dotnet cheat sheet", "repository pattern unit of work dotnet pitfalls", "repository pattern unit of work dotnet common mistakes", "repository pattern unit of work dotnet performance", "repository pattern unit of work dotnet optimization", "repository pattern unit of work dotnet security", "repository pattern unit of work dotnet testing", "repository pattern unit of work dotnet unit test", "repository pattern unit of work dotnet integration", "repository pattern unit of work dotnet migration", "repository pattern unit of work dotnet from scratch", "repository pattern unit of work dotnet 2024", "repository pattern unit of work dotnet 2025", "best repository pattern unit of work dotnet", "repository pattern unit of work dotnet best", "pro repository pattern unit of work dotnet", "repository pattern unit of work dotnet expert", "repository pattern unit of work dotnet consultant", "repository pattern unit of work dotnet services", "repository pattern unit of work dotnet course", "repository pattern unit of work dotnet workshop", "repository pattern unit of work dotnet webinar", "repository pattern unit of work dotnet blog", "repository pattern unit of work dotnet article", "repository pattern unit of work dotnet post", "why repository pattern unit of work dotnet", "when repository pattern unit of work dotnet", "where repository pattern unit of work dotnet", "repository pattern unit of work dotnet in .NET 6", "repository pattern unit of work dotnet in .NET 7", "repository pattern unit of work dotnet in .NET 8", "repository pattern unit of work dotnet for C#", "repository pattern unit of work dotnet for Angular", "repository pattern unit of work dotnet for Vue", "repository pattern unit of work dotnet for React", "repository pattern unit of work dotnet for Azure", "repository pattern unit of work dotnet for microservices", "repository pattern unit of work dotnet for API", "repository pattern unit of work dotnet for database", "repository pattern unit of work dotnet for testing", "repository pattern unit of work dotnet for DevOps", "repository pattern unit of work dotnet for senior developers", "repository pattern unit of work dotnet for team", "repository pattern unit of work dotnet for production", "repository pattern unit of work dotnet for scale", "repository pattern unit of work dotnet for refactoring", "repository pattern unit of work dotnet for enterprise applications", "repository pattern unit of work dotnet for startup", "repository pattern unit of work dotnet in 2024", "repository pattern unit of work dotnet in 2025", "repository pattern unit of work dotnet in 2026", "repository pattern unit of work dotnet code sample", "repository pattern unit of work dotnet code example", "repository pattern unit of work dotnet sample code", "repository pattern unit of work dotnet full example", "repository pattern unit of work dotnet working example", "repository pattern unit of work dotnet practical repository pattern unit of work dotnet", "repository pattern unit of work dotnet real world example", "repository pattern unit of work dotnet use case", "repository pattern unit of work dotnet use cases", "repository pattern unit of work dotnet scenario", "repository pattern unit of work dotnet scenarios", "repository pattern unit of work dotnet pattern", "repository pattern unit of work dotnet approach", "repository pattern unit of work dotnet approaches", "repository pattern unit of work dotnet strategy", "repository pattern unit of work dotnet strategies", "repository pattern unit of work dotnet technique", "repository pattern unit of work dotnet techniques", "repository pattern unit of work dotnet method", "repository pattern unit of work dotnet methods", "repository pattern unit of work dotnet solution", "repository pattern unit of work dotnet solutions", "repository pattern unit of work dotnet implementation guide", "repository pattern unit of work dotnet getting started", "repository pattern unit of work dotnet quick start", "repository pattern unit of work dotnet overview guide", "repository pattern unit of work dotnet comprehensive guide", "repository pattern unit of work dotnet detailed guide", "repository pattern unit of work dotnet practical guide", "repository pattern unit of work dotnet developer guide", "repository pattern unit of work dotnet engineer guide", "repository pattern unit of work dotnet architect guide", "repository pattern unit of work dotnet for architects", "repository pattern unit of work dotnet for backend", "repository pattern unit of work dotnet for tech leads", "repository pattern unit of work dotnet for senior devs", "benefits of repository pattern unit of work dotnet", "advantages of repository pattern unit of work dotnet", "alternatives to repository pattern unit of work dotnet", "compared to repository pattern unit of work dotnet", "intro to repository pattern unit of work dotnet", "basics of repository pattern unit of work dotnet", "repository pattern unit of work dotnet tips and tricks", "repository pattern unit of work dotnet production-ready", "repository pattern unit of work dotnet enterprise-grade", "repository pattern unit of work dotnet with Docker", "repository pattern unit of work dotnet with Kubernetes", "repository pattern unit of work dotnet in ASP.NET Core", "repository pattern unit of work dotnet with Entity Framework", "repository pattern unit of work dotnet with EF Core", "repository pattern unit of work dotnet modern", "repository pattern unit of work dotnet updated", "repository pattern unit of work dotnet latest", "repository pattern unit of work dotnet walkthrough", "repository pattern unit of work dotnet hands-on", "repository pattern unit of work dotnet practical examples", "repository pattern unit of work dotnet real-world examples", "repository pattern unit of work dotnet common pitfalls", "repository pattern unit of work dotnet gotchas", "repository pattern unit of work dotnet FAQ", "repository pattern unit of work dotnet FAQs", "repository pattern unit of work dotnet Q&A", "repository pattern unit of work dotnet interview questions", "repository pattern unit of work dotnet interview", "repository pattern unit of work dotnet certification", "repository pattern unit of work dotnet training", "repository pattern unit of work dotnet video", "repository pattern unit of work dotnet series", "repository pattern unit of work dotnet part 1", "repository pattern unit of work dotnet core concepts", "repository pattern unit of work dotnet key concepts", "repository pattern unit of work dotnet recap", "repository pattern unit of work dotnet takeaways", "repository pattern unit of work dotnet conclusion", "repository pattern unit of work dotnet next steps", "repository pattern unit of work dotnet further reading", "repository pattern unit of work dotnet resources", "repository pattern unit of work dotnet tools", "repository pattern unit of work dotnet libraries", "repository pattern unit of work dotnet frameworks", "repository pattern unit of work dotnet NuGet", "repository pattern unit of work dotnet package", "repository pattern unit of work dotnet GitHub", "repository pattern unit of work dotnet open source", "repository pattern unit of work dotnet community", "repository pattern unit of work dotnet Microsoft docs", "repository pattern unit of work dotnet documentation", "repository pattern unit of work dotnet official guide", "repository pattern unit of work dotnet official tutorial", "repository pattern unit of work with .NET Core", "repository pattern unit of work dotnet ASP.NET Core", "Repository", "Repository guide", "Repository tutorial", "Repository best practices", "Repository in .NET", "Repository in C#", "Repository for developers", "Repository examples", "Repository patterns", "Repository overview", "Repository introduction", "Repository deep dive", "Repository explained", "Repository how to", "Repository what is"],
  relatedServices: ["full-stack-development","database-design-optimization"],
  relatedProjects: ["bat-inhouse-app","g5-pos"],
  relatedArticleSlugs: ["clean-architecture-dotnet","database-optimization-entity-framework"],
  author: "Waqas Ahmad",
  content: `## Introduction

This guidance is relevant when the topic of this article applies to your system or design choices; it breaks down when constraints or context differ. I've applied it in real projects and refined the takeaways over time (as of 2026).

The **Repository** and **Unit of Work** patterns are foundational in .NET enterprise applications. Repository abstracts data access; Unit of Work coordinates multiple operations in a single transaction. But with EF Core, which already provides these abstractions, when do you actually need them?

This article covers both patterns in depth: what they are, when to use them with EF Core, implementation approaches, and common pitfalls.

## Topics covered

- [Decision Context](#decision-context)
- [What is the Repository pattern?](#what-is-the-repository-pattern)
- [What is Unit of Work?](#what-is-unit-of-work)
- [EF Core as Repository and Unit of Work](#ef-core-as-repository-and-unit-of-work)
- [When to add your own Repository](#when-to-add-your-own-repository)
- [Implementation examples](#implementation-examples)
- [Generic vs specific repositories](#generic-vs-specific-repositories)
- [Enterprise best practices](#enterprise-best-practices)
- [Common issues](#common-issues)
- [Summary](#summary)
- [Position & Rationale](#position--rationale)
- [Trade-Offs & Failure Modes](#trade-offs--failure-modes)
- [What Most Guides Miss](#what-most-guides-miss)
- [Decision Framework](#decision-framework)
- [Key Takeaways](#key-takeaways)
- [When I Would Use This Again — and When I Wouldn't](#when-i-would-use-this-again--and-when-i-wouldnt)
- [Frequently Asked Questions](#frequently-asked-questions)

## Decision Context

- **System scale:** Applications that need to query and persist data; from simple CRUD to domain-heavy with multiple aggregates. Applies when you’re deciding whether to add a repository layer on top of EF Core.
- **Team size:** Backend developers; someone must own repository interfaces and implementations. Works when the team can agree on abstraction boundaries (or accept DbContext as the repository).
- **Time / budget pressure:** Fits when you need testability (mock repository) or domain-focused query methods; breaks down when the app is simple CRUD and DbContext is enough—then skip the extra layer.
- **Technical constraints:** .NET with EF Core; DbContext already provides DbSet (repository-like) and SaveChanges (unit of work). Assumes you can add interfaces and implementations if you go beyond EF Core.
- **Non-goals:** This article does not optimise for “repository everywhere”; it focuses on when to add repository and unit of work and when EF Core is sufficient.

## What is the Repository pattern?

**Repository** abstracts data access behind an interface. Clients use the repository instead of database APIs directly.

| Benefit | Description |
|---------|-------------|
| **Abstraction** | Hide persistence details (SQL, EF, Dapper) |
| **Testability** | Mock repository in unit tests |
| **Single responsibility** | Data access in one place |
| **Domain focus** | Query methods match domain language |

**Interface example:**

\`\`\`csharp
public interface IOrderRepository
{
    Task<Order?> GetByIdAsync(OrderId id, CancellationToken ct = default);
    Task<IReadOnlyList<Order>> GetByCustomerAsync(CustomerId customerId, CancellationToken ct = default);
    Task AddAsync(Order order, CancellationToken ct = default);
    Task UpdateAsync(Order order, CancellationToken ct = default);
    Task DeleteAsync(Order order, CancellationToken ct = default);
}
\`\`\`

## What is Unit of Work?

**Unit of Work** tracks changes to multiple entities and commits them in one transaction.

| Benefit | Description |
|---------|-------------|
| **Transaction** | Multiple changes, one commit |
| **Consistency** | All succeed or all fail |
| **Change tracking** | Know what changed |

**Interface example:**

\`\`\`csharp
public interface IUnitOfWork
{
    IOrderRepository Orders { get; }
    ICustomerRepository Customers { get; }
    Task<int> SaveChangesAsync(CancellationToken ct = default);
}
\`\`\`

## EF Core as Repository and Unit of Work

**EF Core's DbContext already is both:**
- \`DbSet<T>\` is a repository
- \`SaveChangesAsync()\` is unit of work

\`\`\`csharp
// DbContext as repository + unit of work
public class AppDbContext : DbContext
{
    public DbSet<Order> Orders => Set<Order>();
    public DbSet<Customer> Customers => Set<Customer>();
}

// Usage
var order = await _context.Orders.FindAsync(id);
order.Ship();
await _context.SaveChangesAsync(); // Unit of work commits all changes
\`\`\`

**So do you need your own Repository?** Often no. EF Core provides the abstraction.

## When to add your own Repository

**Add your own Repository when:**
- You want to **hide EF Core** from business logic (Clean Architecture)
- You need to **swap persistence** (EF to Dapper, or to another DB)
- You want **domain-focused query methods** (not LINQ everywhere)
- You need to **test without EF Core** (pure unit tests with mocks)

**Skip custom Repository when:**
- Simple CRUD with no business logic
- Team is comfortable with DbContext in services
- You're not testing at the unit level

## Implementation examples

### Simple Repository (wraps DbContext)

\`\`\`csharp
public class OrderRepository : IOrderRepository
{
    private readonly AppDbContext _context;

    public OrderRepository(AppDbContext context) => _context = context;

    public async Task<Order?> GetByIdAsync(OrderId id, CancellationToken ct = default)
        => await _context.Orders
            .Include(o => o.Lines)
            .FirstOrDefaultAsync(o => o.Id == id, ct);

    public async Task<IReadOnlyList<Order>> GetByCustomerAsync(CustomerId customerId, CancellationToken ct = default)
        => await _context.Orders
            .Where(o => o.CustomerId == customerId)
            .ToListAsync(ct);

    public async Task AddAsync(Order order, CancellationToken ct = default)
        => await _context.Orders.AddAsync(order, ct);

    public Task UpdateAsync(Order order, CancellationToken ct = default)
    {
        _context.Orders.Update(order);
        return Task.CompletedTask;
    }

    public Task DeleteAsync(Order order, CancellationToken ct = default)
    {
        _context.Orders.Remove(order);
        return Task.CompletedTask;
    }
}
\`\`\`

### Unit of Work (wraps DbContext)

\`\`\`csharp
public class UnitOfWork : IUnitOfWork
{
    private readonly AppDbContext _context;
    
    public UnitOfWork(AppDbContext context)
    {
        _context = context;
        Orders = new OrderRepository(context);
        Customers = new CustomerRepository(context);
    }

    public IOrderRepository Orders { get; }
    public ICustomerRepository Customers { get; }

    public Task<int> SaveChangesAsync(CancellationToken ct = default)
        => _context.SaveChangesAsync(ct);
}
\`\`\`

### Registration

\`\`\`csharp
// Program.cs
builder.Services.AddDbContext<AppDbContext>(options =>
    options.UseSqlServer(connectionString));

builder.Services.AddScoped<IOrderRepository, OrderRepository>();
builder.Services.AddScoped<IUnitOfWork, UnitOfWork>();
\`\`\`

### Usage in service

\`\`\`csharp
public class OrderService
{
    private readonly IUnitOfWork _uow;

    public OrderService(IUnitOfWork uow) => _uow = uow;

    public async Task PlaceOrderAsync(PlaceOrderCommand cmd)
    {
        var customer = await _uow.Customers.GetByIdAsync(cmd.CustomerId);
        if (customer == null) throw new NotFoundException();

        var order = new Order(customer.Id, cmd.Lines);
        await _uow.Orders.AddAsync(order);
        await _uow.SaveChangesAsync();
    }
}
\`\`\`

## Generic vs specific repositories

**Generic Repository:**

\`\`\`csharp
public interface IRepository<T> where T : class
{
    Task<T?> GetByIdAsync(object id);
    Task<IReadOnlyList<T>> GetAllAsync();
    Task AddAsync(T entity);
    Task UpdateAsync(T entity);
    Task DeleteAsync(T entity);
}
\`\`\`

**Problems with generic:**
- No domain-specific query methods
- Exposes all operations (including ones you don't want)
- Hard to optimize queries per entity

**Specific Repository is better:**

\`\`\`csharp
public interface IOrderRepository
{
    // Only methods this aggregate needs
    Task<Order?> GetByIdAsync(OrderId id);
    Task<IReadOnlyList<Order>> GetPendingAsync();
    Task AddAsync(Order order);
    // No Update/Delete if aggregate handles it internally
}
\`\`\`

**Recommendation:** Use specific repositories with domain-focused methods.

## Enterprise best practices

**1. Use specific repositories, not generic.** Domain-focused methods are more useful.

**2. Repository per aggregate, not per table.** One repository for Order (including OrderLines), not separate.

**3. Keep repositories thin.** Query and persist; no business logic.

**4. Use DbContext directly for simple apps.** Do not add abstraction you do not need.

**5. Unit of Work should match request scope.** One UoW per HTTP request (scoped).

**6. Do not return IQueryable.** Return materialized results. Keeps queries in repository.

**7. Handle concurrency.** Use EF Core's concurrency tokens; handle \`DbUpdateConcurrencyException\`.

**8. Test with in-memory or real DB.** Integration tests with real DB are valuable.

## Common issues

| Issue | Cause | Fix |
|-------|-------|-----|
| **Repository becomes service** | Business logic in repository | Keep logic in services/aggregates |
| **IQueryable leaking** | Repository returns IQueryable | Return IReadOnlyList or IEnumerable |
| **Generic repository bloat** | Everything uses same interface | Use specific repositories |
| **Saving in repository** | SaveChanges in each method | Save in Unit of Work at end |
| **Over-abstraction** | Repository for simple CRUD | Use DbContext directly |
| **Testing difficulty** | Hard to mock complex queries | Use integration tests; simpler interfaces |

## Summary

Repository abstracts data access; Unit of Work coordinates transactions. EF Core's DbContext already provides both. Add your own when you need testability, swappable persistence, or domain-focused queries. Use specific repositories per aggregate, not generic ones.

## Position & Rationale

I use **EF Core’s DbContext** as the repository and unit of work when the app is straightforward CRUD and we don’t need to mock data access in unit tests—DbContext is already testable with an in-memory provider or integration tests. I add a **repository layer** when we need to swap persistence (e.g. for testing with fakes) or when we want domain-focused query methods (e.g. \`IOrderRepository.GetPendingForCustomer(customerId)\`) instead of exposing DbSet and LINQ everywhere. I prefer **specific repositories** (IOrderRepository, IProductRepository) over a generic IRepository&lt;T&gt; so each aggregate has a clear contract. I avoid putting **SaveChanges** inside repository methods; the unit of work (or the caller) should commit at the end of a logical operation. I don’t add a repository “by default” for every project—only when testability or domain API justifies it.

## Trade-Offs & Failure Modes

**Repository** adds an abstraction and more types; you gain testability and a domain-oriented API. **No repository** keeps DbContext in the open; you gain simplicity but couple callers to EF. **Generic repository** (IRepository&lt;T&gt;) often grows into a fat interface that doesn’t match real queries; specific repositories stay focused. Failure modes: SaveChanges in every repository method (no single transaction boundary); over-abstraction for simple CRUD; generic repository that leaks EF or becomes a pass-through with no value.

## What Most Guides Miss

Most guides show “create IRepository and implementation” but don’t stress that **EF Core already is a repository** (DbSet) and **unit of work** (SaveChanges)—you add your own only when you need a different abstraction. Another gap: **specific vs generic**—generic repositories tend to either expose too much (every LINQ method) or too little (only GetById, Add); specific repositories let you define \`GetPendingOrders\`, \`GetByCustomer\`, etc. **Testing**: if you only ever run integration tests with a real DB, you may not need a mockable repository; if you unit-test domain logic in isolation, a repository interface helps.

## Decision Framework

- **If simple CRUD and no need to mock data access** → Use DbContext directly; use integration tests for persistence.
- **If you need to mock or swap persistence, or want domain-focused query methods** → Add specific repositories (IOrderRepository, etc.); keep Unit of Work at the scope (e.g. one SaveChanges per request).
- **Avoid generic IRepository&lt;T&gt;** unless it’s a thin wrapper with a few methods; prefer specific repositories per aggregate.
- **Don’t call SaveChanges inside repository methods**; let the unit of work or application service commit.
- **For testing** → Integration tests with real or in-memory DB, or unit tests with repository mocks if you have the abstraction.

## Key Takeaways

- **EF Core** = DbSet (repository) + SaveChanges (unit of work); you may not need your own.
- Add **repository** when you need testability (mocks) or domain-focused query API; use **specific** repositories per aggregate.
- **Unit of Work** = one transaction boundary; don’t save inside each repository method.
- Avoid generic repository bloat; prefer specific interfaces that match real use cases.

## When I Would Use This Again — and When I Wouldn't

I’d use **DbContext as repository** again for simple CRUD and when we’re happy with integration tests for data access. I’d add **specific repositories** again when we need to mock persistence in unit tests or when we want a clear domain API (e.g. IOrderRepository.GetPendingForCustomer). I wouldn’t add a generic IRepository&lt;T&gt; that just wraps DbSet with no extra value. I also wouldn’t put SaveChanges inside repository methods—keep the transaction boundary at the application or unit-of-work level.

## Frequently Asked Questions

### What is the Repository pattern?

**Repository** abstracts data access behind an interface. Clients use \`IOrderRepository\` instead of SQL or DbContext directly.

### What is Unit of Work?

**Unit of Work** tracks changes and commits them in one transaction. In EF Core, \`SaveChangesAsync()\` is the unit of work.

### Does EF Core already provide Repository?

Yes. \`DbSet<T>\` acts as a repository; \`SaveChangesAsync()\` is unit of work. You may not need your own.

### When should I add my own Repository?

When you want to **hide EF Core** from business logic, **swap persistence**, add **domain-focused queries**, or **mock in tests**.

### Should I use generic Repository?

Generally no. Specific repositories with domain methods are more useful and avoid exposing unwanted operations.

### How do I test with Repository?

**Unit tests:** Mock the repository interface. **Integration tests:** Use EF Core with in-memory or real database.

### Should Repository call SaveChanges?

No. Repository should not save. Unit of Work (or the caller) saves after all changes are made.

### One repository per table or per aggregate?

**Per aggregate.** Order repository includes OrderLines. One repository per aggregate root.

### Can I return IQueryable from Repository?

Avoid it. Return materialized results (\`IReadOnlyList\`). Keeps queries inside the repository.

### How does Unit of Work fit with DI?

Register as **scoped** (one per request). Repositories share the same DbContext/UoW within the request.

### What about Dapper with Repository?

Works well. Repository hides whether you use EF or Dapper. Switch implementations without changing callers.

### Should every project use Repository?

No. For simple CRUD, DbContext directly is fine. Add abstraction when it provides value.

### How do I handle transactions across repositories?

Unit of Work. Multiple repositories share one DbContext; one \`SaveChangesAsync()\` commits all changes.

### What is the difference between Repository and DAO?

Similar. DAO (Data Access Object) is a more generic term. Repository is domain-focused and part of DDD vocabulary.

### Can I use Repository without Unit of Work?

Yes. Repository can save internally. But Unit of Work is better for coordinating multiple changes.`,
  faqs: [
  {
    "question": "What is Repository pattern?",
    "answer": "Abstracts data access behind an interface. Clients use IOrderRepository instead of SQL or DbContext."
  },
  {
    "question": "What is Unit of Work?",
    "answer": "Tracks changes and commits in one transaction. In EF Core, SaveChangesAsync() is unit of work."
  },
  {
    "question": "Does EF Core provide Repository?",
    "answer": "Yes. DbSet<T> is repository; SaveChangesAsync() is unit of work. May not need your own."
  },
  {
    "question": "When add own Repository?",
    "answer": "To hide EF Core, swap persistence, add domain queries, or mock in tests."
  },
  {
    "question": "Generic vs specific Repository?",
    "answer": "Specific is better. Domain methods are more useful; avoid exposing unwanted operations."
  },
  {
    "question": "How test with Repository?",
    "answer": "Unit tests: mock interface. Integration tests: use EF with in-memory or real DB."
  },
  {
    "question": "Should Repository call SaveChanges?",
    "answer": "No. Unit of Work saves after all changes. Repository just queries and tracks."
  },
  {
    "question": "Per table or per aggregate?",
    "answer": "Per aggregate. Order repository includes OrderLines."
  },
  {
    "question": "Return IQueryable?",
    "answer": "Avoid. Return IReadOnlyList. Keeps queries in repository."
  },
  {
    "question": "Unit of Work with DI?",
    "answer": "Register scoped. Repositories share same DbContext per request."
  },
  {
    "question": "Dapper with Repository?",
    "answer": "Works well. Repository hides whether EF or Dapper. Swap implementations."
  },
  {
    "question": "Every project needs Repository?",
    "answer": "No. Simple CRUD: use DbContext. Add abstraction when it provides value."
  },
  {
    "question": "Transactions across repositories?",
    "answer": "Unit of Work. Multiple repos share DbContext; one SaveChangesAsync commits all."
  },
  {
    "question": "Repository vs DAO?",
    "answer": "Similar. DAO is generic term. Repository is domain-focused DDD vocabulary."
  },
  {
    "question": "Repository without Unit of Work?",
    "answer": "Possible but Unit of Work better for coordinating multiple changes."
  }
]
}
