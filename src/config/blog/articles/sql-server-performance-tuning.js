/**
 * Blog article: sql-server-performance-tuning
 * Auto-generated by scripts/split-blog-articles.js. Do not edit the content here by hand if you run the split script again.
 */

export default {
  slug: "sql-server-performance-tuning",
  title: "SQL Server Performance Tuning for Application Developers",
  excerpt: "Indexes, query plans, statistics, settings, triggers, functions, and locking: what application developers should know when tuning SQL Server. From high-load systems.",
  date: "2025-10-11",
  topic: "Data",
  keywords: ["SQL Server Performance Tuning for Application Developers", "Sql Server Performance Tuning", "Sql Server Performance Tuning best practices", "how to sql server performance tuning", "sql server performance tuning in .NET", "sql server performance tuning guide", "sql server performance tuning for enterprise", "sql server performance tuning patterns", "when to use sql server performance tuning", "sql server performance tuning tutorial", "sql server performance tuning examples", "sql server performance tuning in C#", "sql server performance tuning overview", "sql server performance tuning implementation", "understanding sql server performance tuning", "sql server performance tuning for developers", "sql server performance tuning checklist", "sql server performance tuning tips", "sql server performance tuning deep dive", "sql server performance tuning comparison", "sql server performance tuning vs alternatives", "sql server performance tuning .NET Core", "sql server performance tuning Azure", "sql server performance tuning explained", "sql server performance tuning when to use", "sql server performance tuning enterprise", "sql server performance tuning .NET", "what is sql server performance tuning", "sql server performance tuning summary", "sql server performance tuning introduction", "sql server performance tuning fundamentals", "sql server performance tuning step by step", "sql server performance tuning complete guide", "sql server performance tuning for beginners", "sql server performance tuning advanced", "sql server performance tuning production", "sql server performance tuning real world", "sql server performance tuning example code", "sql server performance tuning C# example", "sql server performance tuning .NET example", "learn sql server performance tuning", "sql server performance tuning learn", "sql server performance tuning reference", "sql server performance tuning cheat sheet", "sql server performance tuning pitfalls", "sql server performance tuning common mistakes", "sql server performance tuning performance", "sql server performance tuning optimization", "sql server performance tuning security", "sql server performance tuning testing", "sql server performance tuning unit test", "sql server performance tuning integration", "sql server performance tuning migration", "sql server performance tuning from scratch", "sql server performance tuning 2024", "sql server performance tuning 2025", "best sql server performance tuning", "sql server performance tuning best", "pro sql server performance tuning", "sql server performance tuning expert", "sql server performance tuning consultant", "sql server performance tuning services", "sql server performance tuning course", "sql server performance tuning workshop", "sql server performance tuning webinar", "sql server performance tuning blog", "sql server performance tuning article", "sql server performance tuning post", "why sql server performance tuning", "when sql server performance tuning", "where sql server performance tuning", "sql server performance tuning in .NET 6", "sql server performance tuning in .NET 7", "sql server performance tuning in .NET 8", "sql server performance tuning for C#", "sql server performance tuning for Angular", "sql server performance tuning for Vue", "sql server performance tuning for React", "sql server performance tuning for Azure", "sql server performance tuning for microservices", "sql server performance tuning for API", "sql server performance tuning for database", "sql server performance tuning for testing", "sql server performance tuning for DevOps", "sql server performance tuning for senior developers", "sql server performance tuning for team", "sql server performance tuning for production", "sql server performance tuning for scale", "sql server performance tuning for refactoring", "sql server performance tuning for enterprise applications", "sql server performance tuning for startup", "sql server performance tuning in 2024", "sql server performance tuning in 2025", "sql server performance tuning in 2026", "sql server performance tuning code sample", "sql server performance tuning code example", "sql server performance tuning sample code", "sql server performance tuning full example", "sql server performance tuning working example", "sql server performance tuning practical sql server performance tuning", "sql server performance tuning real world example", "sql server performance tuning use case", "sql server performance tuning use cases", "sql server performance tuning scenario", "sql server performance tuning scenarios", "sql server performance tuning pattern", "sql server performance tuning approach", "sql server performance tuning approaches", "sql server performance tuning strategy", "sql server performance tuning strategies", "sql server performance tuning technique", "sql server performance tuning techniques", "sql server performance tuning method", "sql server performance tuning methods", "sql server performance tuning solution", "sql server performance tuning solutions", "sql server performance tuning implementation guide", "sql server performance tuning getting started", "sql server performance tuning quick start", "sql server performance tuning overview guide", "sql server performance tuning comprehensive guide", "sql server performance tuning detailed guide", "sql server performance tuning practical guide", "sql server performance tuning developer guide", "sql server performance tuning engineer guide", "sql server performance tuning architect guide", "sql server performance tuning for architects", "sql server performance tuning for backend", "sql server performance tuning for tech leads", "sql server performance tuning for senior devs", "benefits of sql server performance tuning", "advantages of sql server performance tuning", "alternatives to sql server performance tuning", "compared to sql server performance tuning", "intro to sql server performance tuning", "basics of sql server performance tuning", "sql server performance tuning tips and tricks", "sql server performance tuning production-ready", "sql server performance tuning enterprise-grade", "sql server performance tuning with Docker", "sql server performance tuning with Kubernetes", "sql server performance tuning in ASP.NET Core", "sql server performance tuning with Entity Framework", "sql server performance tuning with EF Core", "sql server performance tuning modern", "sql server performance tuning updated", "sql server performance tuning latest", "sql server performance tuning walkthrough", "sql server performance tuning hands-on", "sql server performance tuning practical examples", "sql server performance tuning real-world examples", "sql server performance tuning common pitfalls", "sql server performance tuning gotchas", "sql server performance tuning FAQ", "sql server performance tuning FAQs", "sql server performance tuning Q&A", "sql server performance tuning interview questions", "sql server performance tuning interview", "sql server performance tuning certification", "sql server performance tuning training", "sql server performance tuning video", "sql server performance tuning series", "sql server performance tuning part 1", "sql server performance tuning core concepts", "sql server performance tuning key concepts", "sql server performance tuning recap", "sql server performance tuning takeaways", "sql server performance tuning conclusion", "sql server performance tuning next steps", "sql server performance tuning further reading", "sql server performance tuning resources", "sql server performance tuning tools", "sql server performance tuning libraries", "sql server performance tuning frameworks", "sql server performance tuning NuGet", "sql server performance tuning package", "sql server performance tuning GitHub", "sql server performance tuning open source", "sql server performance tuning community", "sql server performance tuning Microsoft docs", "sql server performance tuning documentation", "sql server performance tuning official guide", "sql server performance tuning official tutorial", "Sql", "Sql guide", "Sql tutorial", "Sql best practices", "Sql in .NET", "Sql in C#", "Sql for developers", "Sql examples", "Sql patterns", "Sql overview", "Sql introduction", "Sql deep dive", "Sql explained", "Sql how to", "Sql what is", "Sql when to use", "Sql for enterprise", "Sql .NET Core", "Sql Azure", "Sql C#", "Sql with .NET", "Sql with C#", "Sql with Azure", "Sql with Angular", "Sql with Vue", "Sql with React", "Sql with Entity Framework", "Sql with SQL Server", "Sql step by step", "Sql complete guide", "Sql from scratch", "Sql 2024", "Sql 2025", "Sql 2026", "Sql code example", "Sql sample code", "Sql implementation", "Sql real world", "Sql production", "Sql for beginners", "Sql advanced", "Sql for architects", "Sql for backend", "Sql for API", "Sql in ASP.NET Core", "Sql with EF Core", "Sql tutorial 2024", "Sql guide 2025", "Sql best practices 2024", "Sql C# examples", "Sql .NET examples", "Sql implementation guide", "Sql how to implement", "Sql benefits", "Sql advantages", "Sql pitfalls", "Sql alternatives", "Sql compared", "Sql intro", "Sql basics", "Sql tips and tricks", "Sql production-ready", "Sql enterprise-grade", "Sql maintainable", "Sql testable", "Sql refactoring", "Sql modern", "Sql updated", "Sql latest", "Sql for tech leads", "Sql for senior devs", "Sql with Docker", "Sql with Kubernetes", "Sql in .NET 8", "Sql in .NET 7", "Sql in .NET 6", "Sql Server", "Sql Server guide", "Sql Server tutorial", "Sql Server best practices", "Sql Server in .NET", "Sql Server in C#", "Sql Server for developers", "Sql Server examples", "Sql Server patterns", "Sql Server overview", "Sql Server introduction", "Sql Server deep dive", "Sql Server explained", "Sql Server how to", "Sql Server what is", "Sql Server when to use", "Sql Server for enterprise", "Sql Server .NET Core", "Sql Server Azure", "Sql Server C#", "Sql Server with .NET", "Sql Server with C#", "Sql Server with Azure", "Sql Server with Angular", "Sql Server with Vue", "Sql Server with React", "Sql Server with Entity Framework", "Sql Server with SQL Server", "Sql Server step by step", "Sql Server complete guide", "Sql Server from scratch", "Sql Server 2024", "Sql Server 2025", "Sql Server 2026", "Sql Server code example", "Sql Server sample code", "Sql Server implementation", "Sql Server real world", "Sql Server production", "Sql Server for beginners", "Sql Server advanced", "Sql Server for architects", "Sql Server for backend", "Sql Server for API", "Sql Server in ASP.NET Core", "Sql Server with EF Core", "Sql Server tutorial 2024", "Sql Server guide 2025", "Sql Server best practices 2024", "Sql Server C# examples", "Sql Server .NET examples", "Sql Server implementation guide", "Sql Server how to implement", "Sql Server benefits", "Sql Server advantages", "Sql Server pitfalls", "Sql Server alternatives", "Sql Server compared", "Sql Server intro", "Sql Server basics", "Sql Server tips and tricks", "Sql Server production-ready", "Sql Server enterprise-grade", "Sql Server maintainable", "Sql Server testable", "Sql Server refactoring", "Sql Server modern", "Sql Server updated", "Sql Server latest", "Sql Server for tech leads", "Sql Server for senior devs", "Sql Server with Docker", "Sql Server with Kubernetes", "Sql Server in .NET 8", "Sql Server in .NET 7", "Sql Server in .NET 6", "Sql Server Performance", "Sql Server Performance guide", "Sql Server Performance tutorial", "Sql Server Performance best practices", "Sql Server Performance in .NET", "Sql Server Performance in C#", "Sql Server Performance for developers", "Sql Server Performance examples", "Sql Server Performance patterns", "Sql Server Performance overview", "Sql Server Performance introduction", "Sql Server Performance deep dive", "Sql Server Performance explained", "Sql Server Performance how to", "Sql Server Performance what is", "Sql Server Performance when to use", "Sql Server Performance for enterprise", "Sql Server Performance .NET Core", "Sql Server Performance Azure", "Sql Server Performance C#", "Sql Server Performance with .NET", "Sql Server Performance with C#", "Sql Server Performance with Azure", "Sql Server Performance with Angular", "Sql Server Performance with Vue", "Sql Server Performance with React", "Sql Server Performance with Entity Framework", "Sql Server Performance with SQL Server", "Sql Server Performance step by step", "Sql Server Performance complete guide", "Sql Server Performance from scratch", "Sql Server Performance 2024", "Sql Server Performance 2025", "Sql Server Performance 2026", "Sql Server Performance code example", "Sql Server Performance sample code", "Sql Server Performance implementation", "Sql Server Performance real world", "Sql Server Performance production", "Sql Server Performance for beginners", "Sql Server Performance advanced", "Sql Server Performance for architects", "Sql Server Performance for backend", "Sql Server Performance for API", "Sql Server Performance in ASP.NET Core", "Sql Server Performance with EF Core", "Sql Server Performance tutorial 2024", "Sql Server Performance guide 2025", "Sql Server Performance best practices 2024", "Sql Server Performance C# examples", "Sql Server Performance .NET examples", "Sql Server Performance implementation guide", "Sql Server Performance how to implement", "Sql Server Performance benefits", "Sql Server Performance advantages", "Sql Server Performance pitfalls", "Sql Server Performance alternatives", "Sql Server Performance compared", "Sql Server Performance intro", "Sql Server Performance basics", "Sql Server Performance tips and tricks", "Sql Server Performance production-ready", "Sql Server Performance enterprise-grade", "Sql Server Performance maintainable", "Sql Server Performance testable", "Sql Server Performance refactoring", "Sql Server Performance modern", "Sql Server Performance updated", "Sql Server Performance latest", "Sql Server Performance for tech leads", "Sql Server Performance for senior devs", "Sql Server Performance with Docker", "Sql Server Performance with Kubernetes", "Sql Server Performance in .NET 8", "Sql Server Performance in .NET 7", "Sql Server Performance in .NET 6", "Sql Server Performance Tuning how to", "Sql Server Performance Tuning what is", "Sql Server Performance Tuning C#", "Sql Server Performance Tuning with .NET", "Sql Server Performance Tuning with C#", "Sql Server Performance Tuning with Azure", "Sql Server Performance Tuning with Angular", "Sql Server Performance Tuning with Vue", "Sql Server Performance Tuning with React", "Sql Server Performance Tuning with SQL Server", "Sql Server Performance Tuning 2026", "Sql Server Performance Tuning tutorial 2024", "Sql Server Performance Tuning guide 2025", "Sql Server Performance Tuning best practices 2024", "Sql Server Performance Tuning C# examples", "Sql Server Performance Tuning .NET examples", "Sql Server Performance Tuning how to implement", "Sql Server Performance Tuning benefits", "Sql Server Performance Tuning advantages", "Sql Server Performance Tuning alternatives", "Sql Server Performance Tuning compared", "Sql Server Performance Tuning intro", "Sql Server Performance Tuning basics", "Sql Server Performance Tuning maintainable", "Sql Server Performance Tuning testable", "Sql Server Performance Tuning refactoring", "Server", "Server guide", "Server tutorial", "Server best practices", "Server in .NET", "Server in C#", "Server for developers", "Server examples", "Server patterns", "Server overview", "Server introduction", "Server deep dive", "Server explained", "Server how to", "Server what is", "Server when to use", "Server for enterprise", "Server .NET Core", "Server Azure", "Server C#", "Server with .NET", "Server with C#", "Server with Azure", "Server with Angular", "Server with Vue", "Server with React", "Server with Entity Framework", "Server with SQL Server", "Server step by step", "Server complete guide", "Server from scratch", "Server 2024", "Server 2025", "Server 2026", "Server code example", "Server sample code", "Server implementation", "Server real world", "Server production", "Server for beginners", "Server advanced", "Server for architects", "Server for backend", "Server for API", "Server in ASP.NET Core", "Server with EF Core", "Server tutorial 2024", "Server guide 2025", "Server best practices 2024", "Server C# examples", "Server .NET examples", "Server implementation guide", "Server how to implement", "Server benefits", "Server advantages", "Server pitfalls", "Server alternatives", "Server compared", "Server intro", "Server basics", "Server tips and tricks", "Server production-ready", "Server enterprise-grade", "Server maintainable", "Server testable", "Server refactoring", "Server modern"],
  relatedServices: ["database-design-optimization","full-stack-development"],
  relatedProjects: ["g5-pos","bat-inhouse-app"],
  relatedArticleSlugs: ["database-optimization-entity-framework"],
  author: "Waqas Ahmad",
  content: `## Introduction

This guidance is relevant when the topic of this article applies to your system or design choices; it breaks down when constraints or context differ. I've applied it in real projects and refined the takeaways over time (as of 2026).

Application developers often leave **SQL tuning** to DBAs—but understanding **indexes**, **query plans**, **statistics**, **server settings**, **triggers**, **functions**, and **locking** helps you write better EF Core and raw SQL. From high-load systems (G5 POS, BAT in-house, and other enterprise apps), I have seen small changes in indexing, parameterization, and schema yield large gains. This article covers **SQL Server performance tuning for application developers**: what you need when tuning SQL Server so that your EF Core and raw queries scale.

The golden rule: **measure first**. Use execution plans, Extended Events, or Query Store to see what is actually executed and how long it takes before you add indexes or rewrite queries.

If you are new to SQL tuning, start with [Topics covered](#topics-covered) and [SQL Server performance tuning at a glance](#sql-server-performance-tuning-at-a-glance).

## Topics covered

- [Decision Context](#decision-context)
- [What is SQL tuning and why application developers need it](#what-is-sql-tuning-and-why-application-developers-need-it)
- [SQL Server performance tuning at a glance](#sql-server-performance-tuning-at-a-glance)
- [Indexes: clustered, nonclustered, covering, filtered](#indexes-clustered-nonclustered-covering-filtered)
- [Statistics: auto-create, auto-update, manual](#statistics-auto-create-auto-update-manual)
- [Execution plans: seek vs scan, key lookup](#execution-plans-seek-vs-scan-key-lookup)
- [Parameter sniffing and plan reuse](#parameter-sniffing-and-plan-reuse)
- [Server settings: MAXDOP, cost threshold, memory](#server-settings-maxdop-cost-threshold-memory)
- [TempDB configuration](#tempdb-configuration)
- [Locking and blocking: isolation levels, RCSI](#locking-and-blocking-isolation-levels-rcsi)
- [Triggers: performance impact and alternatives](#triggers-performance-impact-and-alternatives)
- [Functions: scalar vs table-valued, inlining](#functions-scalar-vs-table-valued-inlining)
- [Index maintenance: REBUILD and REORGANIZE](#index-maintenance-rebuild-and-reorganize)
- [Wait statistics and Query Store](#wait-statistics-and-query-store)
- [Common issues and best practices](#common-issues-and-best-practices)
- [Summary](#summary)
- [Position & Rationale](#position--rationale)
- [Trade-Offs & Failure Modes](#trade-offs--failure-modes)
- [What Most Guides Miss](#what-most-guides-miss)
- [Decision Framework](#decision-framework)
- [Key Takeaways](#key-takeaways)
- [When I Would Use This Again — and When I Wouldn't](#when-i-would-use-this-again--and-when-i-wouldnt)
- [Frequently Asked Questions](#frequently-asked-questions)

------

## Decision Context

- **System scale:** Varies by context; the approach in this article applies to the scales and scenarios described in the body.
- **Team size:** Typically small to medium teams; ownership and clarity matter more than headcount.
- **Time / budget pressure:** Applicable under delivery pressure; I've used it in both greenfield and incremental refactors.
- **Technical constraints:** .NET and related stack where relevant; constraints are noted in the article where they affect the approach.
- **Non-goals:** This article does not optimize for every possible scenario; boundaries are stated where they matter.


## What is SQL tuning and why application developers need it

**SQL tuning** (or **database performance tuning**) is the practice of making **queries** and **schema** (indexes, statistics, settings) **faster** so that your application responds quickly and does not overload the database. **Application developers** write the queries (via EF Core, Dapper, or raw SQL), so understanding **indexes** (what they are, when to add them), **query plans** (how SQL Server executes a query), **statistics** (how the engine estimates rows), **parameterization** (why it matters for plan reuse and security), **triggers** and **functions** (when they hurt performance), and **server settings** (MAXDOP, memory, cost threshold) helps you avoid slow queries and N+1 patterns.

**Why it matters:** Slow or blocking queries increase latency and can take down an app under load. Measuring with execution plans and Query Store, then tuning indexes, statistics, and query shape, reduces mean response time and prevents production incidents. This article explains these concepts and how to apply them when tuning SQL Server from an application developer's perspective.

---

## SQL Server performance tuning at a glance

| Concept | What it is |
|--------|------------|
| **Index** | Structure that speeds up lookups and sorts; **clustered** = physical order (one per table); **nonclustered** = separate structure; **covering** (INCLUDE) = query satisfied from index alone. |
| **Statistics** | Metadata for row count estimates; stale or missing statistics lead to bad plans. **Auto-create** and **auto-update** are usually on; use **UPDATE STATISTICS** for critical tables. |
| **Execution plan** | Recipe the engine uses to run a query: **seek** (good) vs **scan** (often bad on large tables); **key lookup** = look up rest of row from table. |
| **Parameter sniffing** | First parameter value shapes the cached plan; sometimes that plan is bad for other values. Use **OPTION (RECOMPILE)** or **OPTION (OPTIMIZE FOR)** only with evidence. |
| **MAXDOP** | Max degree of parallelism; limits how many cores one query can use. Set per query or server-wide. |
| **Cost threshold** | Threshold (in cost units) above which the engine considers a parallel plan. |
| **TempDB** | Shared workspace for temp tables, sorts, spills; configure file count and size for workload. |
| **RCSI** | Read Committed Snapshot Isolation; readers do not block writers; reduces blocking. |
| **Trigger** | Code that runs on INSERT/UPDATE/DELETE; can slow writes and cause blocking; prefer set-based logic or change tracking. |
| **Scalar function** | Function that returns one value; inlined in SQL Server 2019+ when deterministic; avoid in hot paths when not inlined. |
| **Query Store** | Captures plans and runtime stats per query; use for plan analysis and forcing plans. |

\`\`\`mermaid
flowchart LR
  Query[Query] --> Parser[Parser]
  Parser --> Optimizer[Optimizer]
  Optimizer --> Stats[Statistics]
  Stats --> Plan[Execution plan]
  Plan --> Seek[Index seek]
  Plan --> Scan[Index scan]
  Seek --> Result[Result]
  Scan --> Result
  style Seek fill:#059669,color:#fff
  style Scan fill:#dc2626,color:#fff
\`\`\`

---

## Indexes: clustered, nonclustered, covering, filtered

**Indexes** are structures that the database uses to find rows quickly instead of scanning the whole table. A **clustered index** defines the physical order of rows in the table (one per table); a **nonclustered index** is a separate structure that stores key columns and pointers to the data.

**Step 1: Basic nonclustered index (filter and sort)**

\`\`\`sql
-- Index for common filter and sort: CustomerId, Status, CreatedAt
CREATE NONCLUSTERED INDEX IX_Orders_CustomerId_Status_Created
ON dbo.Orders (CustomerId, Status, CreatedAt DESC);
\`\`\`

**What this does:** The engine can **seek** on \`CustomerId\`, \`Status\`, and use the index for \`ORDER BY CreatedAt DESC\` instead of scanning the table. Use for queries that filter and sort by these columns.

**Step 2: Covering index (INCLUDE)**

\`\`\`sql
-- Covering index: add INCLUDE so the query is satisfied from the index alone (no key lookup)
CREATE NONCLUSTERED INDEX IX_Orders_CustomerId_Status_Created_INCLUDE
ON dbo.Orders (CustomerId, Status, CreatedAt DESC)
INCLUDE (Total, Currency);
\`\`\`

**What this does:** If the query only needs \`CustomerId\`, \`Status\`, \`CreatedAt\`, \`Total\`, \`Currency\`, the engine can satisfy it entirely from the index without touching the table (**key lookup** eliminated). Use **INCLUDE** for columns that appear in SELECT or WHERE but are not part of the key.

**Step 3: Filtered index (subset of rows)**

\`\`\`sql
-- Filtered index: only index rows where Status = 'Pending' (e.g. hot path)
CREATE NONCLUSTERED INDEX IX_Orders_Pending_CustomerId
ON dbo.Orders (CustomerId, CreatedAt DESC)
INCLUDE (Total)
WHERE Status = 'Pending';
\`\`\`

**What this does:** The index only contains rows where \`Status = 'Pending'\`, so it is smaller and faster for queries that filter by \`Status = 'Pending'\`. Use filtered indexes when a significant subset of queries target a subset of rows.

**Clustered index: choose wisely**

\`\`\`sql
-- Clustered index: one per table; choose narrow, stable, increasing key
-- Example: Id (identity) or CreatedAt for append-only tables
CREATE CLUSTERED INDEX IX_Orders_Clustered ON dbo.Orders (Id);
-- Or for time-series: CREATE CLUSTERED INDEX IX_Events_Clustered ON dbo.Events (CreatedAt);
\`\`\`

**What this does:** The **clustered** index defines the physical order of the table. Choose a **narrow**, **stable**, **increasing** key (e.g. \`Id\`, \`CreatedAt\`) so that inserts do not cause excessive page splits.

**How this fits together:** Start with a nonclustered index on filter/sort columns; add **INCLUDE** to make it covering when the query only needs a few columns; use **filtered** indexes when queries target a subset of rows. Keep the clustered key narrow and stable. Do not over-index: every index adds write cost and storage; add indexes for the **queries that run most often** or are **slow**.

---

## Statistics: auto-create, auto-update, manual

**Statistics** are metadata the engine uses to **estimate** row counts and choose plans. Stale or missing statistics lead to **bad plans** (e.g. scan instead of seek).

**Check and update statistics manually**

\`\`\`sql
-- Update statistics for a table (full scan)
UPDATE STATISTICS dbo.Orders WITH FULLSCAN;

-- Update statistics for a specific index
UPDATE STATISTICS dbo.Orders IX_Orders_CustomerId_Status_Created WITH FULLSCAN;

-- Create statistics on a column if missing (engine usually auto-creates)
CREATE STATISTICS ST_Orders_Status ON dbo.Orders (Status);
\`\`\`

**What this does:** \`UPDATE STATISTICS\` refreshes the distribution information used by the optimizer. Use \`FULLSCAN\` for accuracy when the table has changed significantly. \`CREATE STATISTICS\` ensures statistics exist on a column (e.g. for predicates the engine has not seen).

**Verify auto-create and auto-update**

\`\`\`sql
-- Database-level: ensure auto_create_statistics and auto_update_statistics are ON
SELECT name, is_auto_create_stats_on, is_auto_update_stats_on
FROM sys.databases WHERE name = DB_NAME();
\`\`\`

**How this fits together:** Keep **auto-create** and **auto-update** statistics ON. For critical or large tables, add **maintenance jobs** to run \`UPDATE STATISTICS ... WITH FULLSCAN\` periodically (e.g. after large loads) so that plans stay accurate.

---

## Execution plans: seek vs scan, key lookup

Use **execution plans** (SSMS, Azure Data Studio) to see how SQL Server runs a query: **index seek** (good) vs **index scan** or **table scan** (often bad on large tables). **Key lookup** is when the engine uses an index to find rows but then has to **look up** the rest of the columns from the table; for wide tables or many rows, that can be expensive.

**Enable actual execution plan and run a query**

\`\`\`sql
SET STATISTICS IO ON;
SELECT OrderId, CustomerId, Status, CreatedAt, Total
FROM dbo.Orders
WHERE CustomerId = @CustomerId AND Status = 'Pending'
ORDER BY CreatedAt DESC;
SET STATISTICS IO OFF;
\`\`\`

**What to look for:** In the plan, **Index Seek** on \`IX_Orders_CustomerId_Status_Created\` is good; **Index Scan** or **Table Scan** on a large table is a red flag. **Key Lookup** (bookmark lookup) means the index does not cover the query—add **INCLUDE** columns to make it covering. Check **Estimated rows** vs **Actual rows**; large variance can indicate statistics issues.

**Parameterized query from application (EF Core)**

\`\`\`csharp
// EF Core: parameterized by default; plan reused for different CustomerId
var orders = await context.Orders
    .Where(o => o.CustomerId == customerId && o.Status == OrderStatus.Pending)
    .OrderByDescending(o => o.CreatedAt)
    .Select(o => new { o.OrderId, o.CustomerId, o.Status, o.CreatedAt, o.Total })
    .ToListAsync();
\`\`\`

**How this fits together:** Always **parameterize** queries so that plans are reused and SQL injection is avoided. Use execution plans to confirm **seek** vs **scan** and to eliminate **key lookup** with covering indexes.

---

## Parameter sniffing and plan reuse

**Parameter sniffing** is when the engine compiles a plan for the **first** parameter value and reuses it for others; sometimes that plan is bad for other values (e.g. highly selective for value A, not selective for value B).

**Option 1: OPTION (RECOMPILE) — recompile every time**

\`\`\`sql
SELECT OrderId, Total FROM dbo.Orders WHERE CustomerId = @CustomerId
OPTION (RECOMPILE);
\`\`\`

**What this does:** The plan is recompiled for each execution, so each parameter value gets an appropriate plan. Use when the same query has very different optimal plans for different parameter values and you have **evidence** (e.g. from Query Store). Cost: extra compile time per execution.

**Option 2: OPTION (OPTIMIZE FOR) — hint a value**

\`\`\`sql
SELECT OrderId, Total FROM dbo.Orders WHERE CustomerId = @CustomerId
OPTION (OPTIMIZE FOR (@CustomerId UNKNOWN));
-- Or optimize for a specific value: OPTION (OPTIMIZE FOR (@CustomerId = 12345));
\`\`\`

**What this does:** \`OPTIMIZE FOR (@CustomerId UNKNOWN)\` uses average selectivity for the plan; \`OPTIMIZE FOR (@CustomerId = 12345)\` optimizes for a specific value. Use only when you have **evidence** that the default sniffed plan is wrong for most executions.

**How this fits together:** **Measure** with different parameter values (e.g. via Query Store) before adding RECOMPILE or OPTIMIZE FOR. In most cases, **parameterized** queries and **up-to-date statistics** are enough; use these options only when necessary.

---

## Server settings: MAXDOP, cost threshold, memory

**MAXDOP** (max degree of parallelism) limits how many cores a single query can use. **Cost threshold for parallelism** is the cost above which the engine considers a parallel plan.

**Query current settings**

\`\`\`sql
-- Current server settings
SELECT name, value_in_use
FROM sys.configurations
WHERE name IN ('max degree of parallelism', 'cost threshold for parallelism', 'max server memory (MB)');
\`\`\`

**Set MAXDOP and cost threshold (example)**

\`\`\`sql
-- Example: limit parallelism to 4; only use parallel plans when cost > 50
EXEC sp_configure 'max degree of parallelism', 4; RECONFIGURE;
EXEC sp_configure 'cost threshold for parallelism', 50; RECONFIGURE;
\`\`\`

**Override per query**

\`\`\`sql
SELECT * FROM dbo.LargeTable WHERE Region = @Region
OPTION (MAXDOP 2);
\`\`\`

**What this does:** **MAXDOP** prevents a single query from consuming all cores (useful on busy OLTP servers). **Cost threshold** avoids parallel plans for cheap queries. **Max server memory** caps how much RAM SQL Server uses; set so that the OS and other apps have enough. Tune these with your DBA; defaults are often fine for small-medium workloads.

---

## TempDB configuration

**TempDB** is a shared workspace for temp tables, table variables, sorts, and spills. Poor TempDB configuration can cause contention and slow queries.

**Best practices (summary)**

- **Multiple data files**: One file per core (up to 8) for TempDB to reduce allocation contention.
- **Equal size and growth**: All TempDB data files same initial size and growth so that proportional fill is used.
- **Place on fast storage**: TempDB is heavily used; use fast disks or SSD.

**Check TempDB file configuration**

\`\`\`sql
SELECT name, physical_name, size * 8 / 1024 AS size_mb
FROM sys.master_files
WHERE database_id = DB_ID('tempdb');
\`\`\`

**How this fits together:** TempDB configuration is usually done by DBAs. As a developer, avoid unnecessary use of **temp tables** when a **CTE** or **derived table** suffices; and avoid **table variables** for large data when **temp tables** would get better plans (statistics).

---

## Locking and blocking: isolation levels, RCSI

**Blocking** occurs when one session holds locks that another session needs. **Read Committed Snapshot Isolation (RCSI)** allows readers to see a consistent snapshot without blocking writers; writers do not block readers.

**Enable RCSI at database level**

\`\`\`sql
ALTER DATABASE MyApp SET READ_COMMITTED_SNAPSHOT ON;
\`\`\`

**What this does:** Under **RCSI**, read operations use **row versioning** instead of shared locks, so readers do not block writers and writers do not block readers. This reduces blocking in read-heavy workloads. **Snapshot isolation** (different option) provides statement-level snapshot for the session.

**Explicit isolation level (use sparingly)**

\`\`\`sql
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;  -- NOLOCK-style; dirty reads
SELECT * FROM dbo.Orders;
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
\`\`\`

**What this does:** \`READ UNCOMMITTED\` (equivalent to \`NOLOCK\`) avoids shared locks but allows **dirty reads**. Use only when you explicitly accept dirty reads (e.g. approximate reporting); prefer **RCSI** for normal read consistency without blocking.

**How this fits together:** Enable **RCSI** on databases where blocking is a problem and you can accept row versioning overhead. Avoid **NOLOCK** as a default; use only when dirty reads are acceptable.

---

## Triggers: performance impact and alternatives

**Triggers** run on INSERT/UPDATE/DELETE and can **slow writes** and cause **blocking** because they execute in the same transaction as the modifying statement.

**Trigger example (avoid heavy logic in triggers)**

\`\`\`sql
CREATE TRIGGER tr_Orders_AfterInsert ON dbo.Orders
AFTER INSERT
AS
BEGIN
    SET NOCOUNT ON;
    -- Keep logic minimal; avoid loops and heavy queries
    INSERT INTO dbo.OrdersAudit (OrderId, Action, At)
    SELECT OrderId, 'Insert', GETUTCDATE() FROM inserted;
END;
\`\`\`

**What this does:** The trigger runs **for each row** (or once per statement, depending on logic). If the trigger does **complex queries** or **calls other tables** in a loop, it can severely slow the write. Prefer **set-based** logic and **minimal** work in triggers.

**Alternatives to triggers**

- **Change Tracking** or **Change Data Capture (CDC)**: Capture changes asynchronously for audit or sync.
- **Computed columns** or **constraints**: For derived values, use computed columns instead of trigger-updated columns.
- **Application logic**: Move validation or audit to the application layer when possible.

**How this fits together:** Use triggers only when necessary; keep them **short** and **set-based**. For audit trails, consider **temporal tables** (SQL Server 2016+) or **CDC** instead of triggers.

---

## Functions: scalar vs table-valued, inlining

**Scalar functions** (return one value) can **force row-by-row execution** in older SQL Server versions; in **SQL Server 2019+**, many scalar functions are **inlined** when they are deterministic. **Table-valued functions (TVFs)** can be **inline** (single statement) or **multi-statement**; inline TVFs are often inlined into the query plan.

**Scalar function (may not inline if complex)**

\`\`\`sql
CREATE FUNCTION dbo.fn_FormatOrderRef(@OrderId INT) RETURNS NVARCHAR(20)
WITH SCHEMABINDING
AS
BEGIN
    RETURN 'ORD-' + FORMAT(@OrderId, '00000000');
END;
-- Use: SELECT dbo.fn_FormatOrderRef(OrderId) FROM dbo.Orders;
\`\`\`

**Inline table-valued function (better for performance)**

\`\`\`sql
CREATE FUNCTION dbo.fn_OrdersByCustomer(@CustomerId INT)
RETURNS TABLE
AS
RETURN (
    SELECT OrderId, Status, CreatedAt, Total
    FROM dbo.Orders
    WHERE CustomerId = @CustomerId
);
-- Use: SELECT * FROM dbo.fn_OrdersByCustomer(@id) o INNER JOIN ...
\`\`\`

**What this does:** **Inline TVFs** are expanded into the query like a view, so the optimizer can use indexes and join order. **Multi-statement TVFs** and **non-inlined scalar functions** can cause **row-by-row** execution. Prefer **inline TVFs** or **views** when you need reusable table expressions; avoid scalar functions in the SELECT list for large sets unless you know they inline.

**How this fits together:** Use **inline TVFs** instead of multi-statement TVFs when possible; avoid **scalar functions** in hot paths unless they are inlined (SQL Server 2019+). When in doubt, **measure** with execution plans.

---

## Index maintenance: REBUILD and REORGANIZE

**Fragmentation** (from page splits and deletes) can slow scans. **REBUILD** rebuilds the index from scratch; **REORGANIZE** defragments leaf pages in place.

**Check fragmentation**

\`\`\`sql
SELECT OBJECT_NAME(ips.object_id) AS TableName, i.name AS IndexName,
       ips.avg_fragmentation_in_percent, ips.page_count
FROM sys.dm_db_index_physical_stats(DB_ID(), NULL, NULL, NULL, 'LIMITED') ips
JOIN sys.indexes i ON ips.object_id = i.object_id AND ips.index_id = i.index_id
WHERE ips.avg_fragmentation_in_percent > 10 AND ips.page_count > 1000
ORDER BY ips.avg_fragmentation_in_percent DESC;
\`\`\`

**Reorganize vs Rebuild**

\`\`\`sql
-- Reorganize: online, lower impact; use for moderate fragmentation
ALTER INDEX IX_Orders_CustomerId_Status_Created ON dbo.Orders REORGANIZE;

-- Rebuild: full rebuild; use for high fragmentation; can be ONLINE
ALTER INDEX IX_Orders_CustomerId_Status_Created ON dbo.Orders REBUILD
WITH (ONLINE = ON, FILLFACTOR = 90);
\`\`\`

**What this does:** **REORGANIZE** defragments in place and is **online** by default. **REBUILD** rebuilds the index; use \`ONLINE = ON\` for Enterprise Edition to avoid blocking. **FILLFACTOR** leaves space on pages to reduce future page splits. Run maintenance during low-traffic windows.

**How this fits together:** Schedule **index maintenance** (REORGANIZE or REBUILD) based on fragmentation; use **Query Store** and **dm_db_index_physical_stats** to decide which indexes to maintain.

---

## Wait statistics and Query Store

**Wait statistics** show what SQL Server is waiting on (e.g. PAGEIOLATCH, LCK_M_S). Use **Query Store** (Azure SQL, SQL Server 2016+) to capture **plans** and **runtime stats** per query so you can find regressions and force plans.

**Enable Query Store**

\`\`\`sql
ALTER DATABASE MyApp SET QUERY_STORE = ON
WITH (OPERATION_MODE = READ_WRITE, MAX_STORAGE_SIZE_MB = 500);
\`\`\`

**Top waits (simplified)**

\`\`\`sql
SELECT wait_type, wait_time_ms / 1000.0 AS wait_s, waiting_tasks_count
FROM sys.dm_os_wait_stats
WHERE wait_type NOT LIKE '%SLEEP%' AND wait_type NOT IN ('REQUEST_FOR_DEADLOCK_SEARCH', 'SQLTRACE_BUFFER_FLUSH')
ORDER BY wait_time_ms DESC;
\`\`\`

**How this fits together:** Use **Query Store** to identify **slow** or **regressed** queries and to **force** a known-good plan when the engine chooses a bad one. Use **wait stats** to see if the bottleneck is I/O, locking, or CPU.

---

## Common issues and best practices

**Adding indexes without measuring:** Add indexes only for queries that are **slow** or **run often**. Measure with execution plans and usage; remove unused indexes.

**Table scans on large tables:** Add indexes for WHERE, JOIN, ORDER BY; use **covering indexes** (INCLUDE) when the query only needs a few columns. Keep **statistics** up to date.

**Ad-hoc SQL and plan cache bloat:** **Parameterize** all queries so that plans are reused and the plan cache is not filled with one-off plans.

**Ignoring parameter sniffing:** Measure with different parameter values; use **RECOMPILE** or **OPTIMIZE FOR** only when you have evidence.

**Missing or stale statistics:** Ensure **auto-create** and **auto-update** statistics are ON; run **UPDATE STATISTICS** for critical tables in maintenance.

**Heavy triggers:** Keep triggers **minimal** and **set-based**; consider **CDC** or **temporal tables** for audit.

**Scalar functions in SELECT:** Prefer **inline TVFs** or **expressions** in the query when possible; verify inlining in SQL Server 2019+.

**Best practices:** Measure first; parameterize; index for actual query shape; maintain statistics and indexes; use RCSI to reduce blocking; use Query Store for plan analysis.

---
---

## Position & Rationale

I **measure first**—execution plans, Query Store, or Extended Events—before adding indexes or rewriting queries; I avoid guessing. I prefer **covering indexes** (INCLUDE) to remove key lookups when the query shape is stable; I avoid over-indexing so writes don’t suffer. I keep **statistics** auto-create and auto-update on and run manual **UPDATE STATISTICS** for critical tables when needed. I use **RCSI** (Read Committed Snapshot Isolation) to reduce blocking; I avoid **NOLOCK** as a default. I treat **parameter sniffing** fixes (RECOMPILE, OPTIMIZE FOR) as last resort and only with evidence from plans. I minimise **triggers** and **scalar functions** in hot paths; I prefer CDC or temporal for audit and inline TVFs where possible. I reject adding indexes without measuring; I reject changing server settings (MAXDOP, cost threshold) without DBA or evidence.

---

## Trade-Offs & Failure Modes

- **What this sacrifices:** More indexes add write cost and maintenance; RCSI increases tempdb and version store. Tuning is iterative and can conflict with other workloads.
- **Where it degrades:** Over-indexing slows inserts/updates; wrong index choice (e.g. for one query only) wastes space. Ignoring statistics or plan reuse leads to sudden regressions. Triggers and scalar functions in hot paths cause hidden cost.
- **How it fails when misapplied:** Adding indexes without measuring so we don’t know if they help. Using NOLOCK everywhere and accepting dirty reads. Changing MAXDOP or cost threshold globally without testing. Relying on triggers for critical logic when CDC or app-level events are safer.
- **Early warning signs:** "Queries were fast last week"; "we added 10 indexes and writes got slow"; "blocking is high"; "plan changed and everything got slow."

---

## What Most Guides Miss

Many guides show index types and execution plans but skip **measurement discipline**—you need a baseline (Query Store, Extended Events) before and after so you know what actually improved. **Parameter sniffing** and **plan reuse** are underplayed; a "good" plan for one parameter value can be bad for another, and RECOMPILE/OPTIMIZE FOR have trade-offs. **RCSI** vs default read committed and the impact on tempdb and version store are rarely explained for app devs. **Triggers** and **scalar functions** in SELECT are often left in place; the cost of per-row execution is easy to miss until load grows.

---

## Decision Framework

- **If a query or workload is slow** → Measure first (plan, Query Store, waits); identify scans, key lookups, and missing indexes; then add or adjust indexes and re-measure.
- **If you have blocking** → Enable RCSI if acceptable; avoid NOLOCK as default; look at isolation level and long transactions.
- **If plans are unstable** → Check parameter sniffing; use RECOMPILE or OPTIMIZE FOR only with evidence; maintain statistics.
- **If you have triggers or scalar functions in hot paths** → Consider CDC, temporal, or app-level events for audit; prefer inline TVFs or expressions; measure impact.
- **If you change server settings** → Coordinate with DBA; test MAXDOP, cost threshold, and memory in non-prod first.

---

## Key Takeaways

- Measure first; use covering indexes and statistics; prefer RCSI over NOLOCK; minimise triggers and scalar functions in hot paths.
- Parameter sniffing and plan reuse matter; fix with evidence. Use Query Store and execution plans to validate changes.
- Revisit indexes and statistics when query shapes or data volume change.


## Summary

- **Indexes**: Clustered (one per table, narrow/stable/increasing); nonclustered for filter/sort; **covering** (INCLUDE) to avoid key lookup; **filtered** for subset of rows. Do not over-index.
- **Statistics**: Keep **auto-create** and **auto-update** ON; run **UPDATE STATISTICS** for critical tables.
- **Plans**: Prefer **seek** over **scan**; eliminate **key lookup** with covering indexes; **parameterize** for plan reuse.
- **Parameter sniffing**: Use **RECOMPILE** or **OPTIMIZE FOR** only with evidence.
- **Settings**: Tune **MAXDOP** and **cost threshold** with DBA; configure **TempDB** and **memory** appropriately.
- **Locking**: **RCSI** reduces blocking; avoid **NOLOCK** as default.
- **Triggers**: Keep minimal; prefer **CDC** or **temporal** for audit.
- **Functions**: Prefer **inline TVFs**; avoid scalar functions in hot paths unless inlined.
- **Maintenance**: **REORGANIZE** or **REBUILD** based on fragmentation; use **Query Store** for plan analysis.

---

## When I Would Use This Again — and When I Wouldn't

I would use this SQL tuning approach again whenever I own or influence SQL Server-backed apps—measure first, then indexes, statistics, RCSI, and minimal triggers/functions. I'd use it for high-load systems (e.g. POS, batch, APIs with heavy queries) where app devs and DBAs collaborate. I wouldn't add indexes or change server settings without measuring and re-measuring. I wouldn't use NOLOCK as a blanket fix for blocking; I'd enable RCSI or fix long transactions. For small, low-throughput apps with simple queries, a light touch (basic indexes, default settings) may be enough; as soon as we have slow queries or blocking, the full discipline pays off. If the team has no access to Query Store or execution plans, I'd get that in place before deep tuning.


---

## Frequently Asked Questions

### How do I read an execution plan in SQL Server?

Open the plan in SSMS or Azure Data Studio; look for **index seek** (good) vs **index scan** or **table scan** (often bad on large tables). Check **estimated rows** vs **actual rows**; large variance can indicate statistics issues. Focus on the **highest cost** operators first.

### When should I add a covering index (INCLUDE)?

When a query **only needs** a small set of columns and the engine can satisfy the query from the index without touching the table. Add **INCLUDE** columns that are in SELECT or WHERE but not in the key; this avoids key lookups.

### What is parameter sniffing and how do I handle it?

**Parameter sniffing** is when the engine compiles a plan for the first parameter value and reuses it for others; sometimes that plan is bad for other values. **Measure** with different parameters; use **OPTION (RECOMPILE)** or **OPTION (OPTIMIZE FOR)** only when you have evidence and understand the trade-off.

### How do I measure SQL performance in production?

Use **Extended Events** or **Query Store** (Azure SQL, SQL Server 2016+) to capture slow queries and plans. Use **Application Insights** or your APM with SQL dependency tracking. **Correlate** slow requests with the SQL they execute.

### What are common mistakes when tuning SQL Server?

**Adding indexes without measuring**; **ignoring execution plans**; **ad-hoc SQL** with literals; **missing statistics**; **over-indexing** (every column). **Measure first**; add indexes and tune based on actual query shape and usage.

### How do I choose between clustered and nonclustered indexes?

**Clustered**: one per table; defines physical order. Choose a **narrow, stable, increasing** key (e.g. Id, CreatedAt). **Nonclustered**: for WHERE, JOIN, ORDER BY; use **covering** (INCLUDE) when the query only needs a few columns. Do not over-index.

### What is EF Core doing under the hood when I run a query?

EF Core **translates** your LINQ (or raw SQL) into **parameterized** SQL and sends it to SQL Server. It uses **ADO.NET** under the hood; the same rules apply: parameterize, use indexes, avoid N+1 (e.g. Include or explicit loads). Use **AsNoTracking()** for read-only queries to avoid change-tracking overhead.

### When should I use raw SQL instead of EF Core?

Use **raw SQL** when EF Core cannot express the query efficiently (e.g. complex CTEs, bulk operations, vendor-specific features) or when you need maximum control. Always **parameterize**; use **FromSqlRaw** or **ExecuteSqlRaw** with parameters so that plans are reused and injection is avoided.

### What is a key lookup and when is it a problem?

A **key lookup** is when the engine uses an index to find rows but then has to **look up** the rest of the columns from the table. For wide tables or many rows, that can be expensive. Use a **covering index** (INCLUDE the needed columns) so that the query is satisfied from the index alone.

### How do I find missing indexes in SQL Server?

Use **Dynamic Management Views** (e.g. \`sys.dm_db_missing_index_details\`) or **Query Store** (Azure SQL, SQL Server 2016+) to see which queries would benefit from indexes. Do not add every suggestion blindly; **measure** and add indexes for the **most impactful** queries first.

### What is statistics and why does it matter?

**Statistics** are metadata the engine uses to **estimate** row counts and choose plans. Stale or missing statistics lead to **bad plans** (e.g. scan instead of seek). Ensure **auto-create** and **auto-update** statistics are on; for critical tables, consider **maintenance jobs** to update statistics regularly.

### How do I avoid N+1 queries with EF Core?

**N+1** is when you load a list and then loop and load related data per item (one query for the list + N for each item). Use **Include()** (eager load) or **explicit load** in one round-trip; or **project** only the columns you need so that EF generates a single efficient query.

### What is plan cache and plan reuse?

**Plan cache** stores compiled **execution plans** so that the same query shape (with different parameter values) can reuse the plan. **Parameterized** queries reuse plans; **ad-hoc** SQL with literals can create a new plan per value and **bloat** the cache. Always parameterize.

### How do I tune a slow stored procedure?

**Measure**: capture the plan and runtime with different parameter values. Check **indexes** on tables used in the procedure; add **covering indexes** if key lookups are expensive. Consider **parameter sniffing** (recompile or optimize for) only with evidence. Simplify logic and avoid unnecessary cursors or loops when set-based operations are possible.

### What tools can I use to profile SQL Server?

**SSMS** / **Azure Data Studio**: execution plans, Activity Monitor, Query Store. **Extended Events**: lightweight tracing for slow queries and blocking. **Application Insights** / **APM**: correlate app requests with SQL dependencies. **SQL Server Profiler** (legacy): use Extended Events instead for new work.

### When should I use REBUILD vs REORGANIZE?

Use **REORGANIZE** for moderate fragmentation (e.g. 10–30%); it is online and lower impact. Use **REBUILD** for high fragmentation (e.g. > 30%); use \`ONLINE = ON\` when available to reduce blocking.

### What is RCSI and when should I enable it?

**Read Committed Snapshot Isolation** lets readers see a consistent snapshot without blocking writers. Enable when you have **blocking** between readers and writers and can accept the overhead of row versioning in TempDB.

### Do triggers slow down INSERT/UPDATE/DELETE?

Yes. Triggers run in the same transaction as the write; **heavy** or **row-by-row** logic in triggers can significantly slow writes. Keep triggers **minimal** and **set-based**; consider **CDC** or **temporal tables** for audit.

### Why avoid scalar functions in SELECT for large sets?

**Scalar functions** (in older SQL Server) can force **row-by-row** execution because the engine may not inline them. In **SQL Server 2019+**, many deterministic scalar functions are inlined; when not inlined, avoid them in hot paths or use **inline TVFs** / expressions instead.
`,
  faqs: [
  {
    "question": "How do I read an execution plan in SQL Server?",
    "answer": "Open the plan in SSMS or Azure Data Studio; look for index seek (good) vs index scan or table scan (often bad on large tables). Check estimated rows vs actual rows; large variance can indicate statistics issues. Focus on the highest cost operators first."
  },
  {
    "question": "When should I add a covering index (INCLUDE)?",
    "answer": "When a query only needs a small set of columns and the engine can satisfy the query from the index without touching the table. Add INCLUDE columns that are in SELECT or WHERE but not in the key; this avoids key lookups."
  },
  {
    "question": "What is parameter sniffing and how do I handle it?",
    "answer": "Parameter sniffing is when the engine compiles a plan for the first parameter value and reuses it for others; sometimes that plan is bad for other values. Measure with different parameters; use OPTION (RECOMPILE) or OPTION (OPTIMIZE FOR) only when you have evidence and understand the trade-off."
  },
  {
    "question": "How do I measure SQL performance in production?",
    "answer": "Use Extended Events or Query Store (Azure SQL, SQL Server 2016+) to capture slow queries and plans. Use Application Insights or your APM with SQL dependency tracking. Correlate slow requests with the SQL they execute."
  },
  {
    "question": "What are common mistakes when tuning SQL Server?",
    "answer": "Adding indexes without measuring; ignoring execution plans; ad-hoc SQL with literals; missing statistics; over-indexing (every column). Measure first; add indexes and tune based on actual query shape and usage."
  },
  {
    "question": "How do I choose between clustered and nonclustered indexes?",
    "answer": "Clustered: one per table; defines physical order. Choose a narrow, stable, increasing key (e.g. Id, CreatedAt). Nonclustered: for WHERE, JOIN, ORDER BY; use covering (INCLUDE) when the query only needs a few columns. Do not over-index."
  },
  {
    "question": "What is EF Core doing under the hood when I run a query?",
    "answer": "EF Core translates LINQ into parameterized SQL and uses ADO.NET. Use AsNoTracking() for read-only queries. Same tuning rules: parameterize, use indexes, avoid N+1 (Include or explicit loads)."
  },
  {
    "question": "When should I use raw SQL instead of EF Core?",
    "answer": "Use raw SQL when EF cannot express the query efficiently (complex CTEs, bulk ops) or when you need maximum control. Always parameterize; use FromSqlRaw or ExecuteSqlRaw with parameters."
  },
  {
    "question": "What is a key lookup and when is it a problem?",
    "answer": "Key lookup is when the engine uses an index then looks up remaining columns from the table. For wide tables or many rows it can be expensive. Use a covering index (INCLUDE) to satisfy the query from the index alone."
  },
  {
    "question": "How do I find missing indexes in SQL Server?",
    "answer": "Use sys.dm_db_missing_index_details or Query Store to see which queries would benefit. Measure and add indexes for the most impactful queries first; do not add every suggestion blindly."
  },
  {
    "question": "What is statistics and why does it matter?",
    "answer": "Statistics are metadata for row count estimates and plan choice. Stale or missing statistics lead to bad plans. Ensure auto-create and auto-update statistics are on; consider maintenance jobs for critical tables."
  },
  {
    "question": "How do I avoid N+1 queries with EF Core?",
    "answer": "Use Include() (eager load) or explicit load in one round-trip; or project only needed columns so EF generates a single efficient query. Do not loop and load related data per item."
  },
  {
    "question": "What is plan cache and plan reuse?",
    "answer": "Plan cache stores compiled execution plans. Parameterized queries reuse plans; ad-hoc SQL with literals can bloat the cache. Always parameterize for reuse and security."
  },
  {
    "question": "How do I tune a slow stored procedure?",
    "answer": "Measure with plans and different parameters. Check indexes; add covering indexes if key lookups are expensive. Consider parameter sniffing (recompile/optimize for) only with evidence. Prefer set-based operations over cursors."
  },
  {
    "question": "What tools can I use to profile SQL Server?",
    "answer": "SSMS/Azure Data Studio (plans, Activity Monitor, Query Store), Extended Events, Application Insights/APM. Use Extended Events instead of SQL Server Profiler for new work."
  },
  {
    "question": "When should I use REBUILD vs REORGANIZE?",
    "answer": "Use REORGANIZE for moderate fragmentation (e.g. 10–30%); it is online and lower impact. Use REBUILD for high fragmentation (e.g. > 30%); use ONLINE = ON when available to reduce blocking."
  },
  {
    "question": "What is RCSI and when should I enable it?",
    "answer": "Read Committed Snapshot Isolation lets readers see a consistent snapshot without blocking writers. Enable when you have blocking between readers and writers and can accept the overhead of row versioning in TempDB."
  },
  {
    "question": "Do triggers slow down INSERT/UPDATE/DELETE?",
    "answer": "Yes. Triggers run in the same transaction as the write; heavy or row-by-row logic in triggers can significantly slow writes. Keep triggers minimal and set-based; consider CDC or temporal tables for audit."
  },
  {
    "question": "Why avoid scalar functions in SELECT for large sets?",
    "answer": "Scalar functions (in older SQL Server) can force row-by-row execution because the engine may not inline them. In SQL Server 2019+ many deterministic scalar functions are inlined; when not inlined, avoid them in hot paths or use inline TVFs/expressions instead."
  }
]
}
