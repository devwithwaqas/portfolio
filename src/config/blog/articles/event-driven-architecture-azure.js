/**
 * Blog article: event-driven-architecture-azure
 * Auto-generated by scripts/split-blog-articles.js. Do not edit the content here by hand if you run the split script again.
 */

export default {
  slug: "event-driven-architecture-azure",
  title: "Event-Driven Architecture on Azure",
  excerpt: "Event Grid, Service Bus, and Event Hubs: when to use which, and how to design for failure and replay. From production event-driven systems.",
  date: "2025-01-04",
  topic: "Cloud",
  keywords: ["Event-Driven Architecture on Azure", "Event Driven Architecture Azure", "Event Driven Architecture Azure best practices", "how to event driven architecture azure", "event driven architecture azure in .NET", "event driven architecture azure guide", "event driven architecture azure for enterprise", "event driven architecture azure patterns", "when to use event driven architecture azure", "event driven architecture azure tutorial", "event driven architecture azure examples", "event driven architecture azure in C#", "event driven architecture azure overview", "event driven architecture azure implementation", "understanding event driven architecture azure", "event driven architecture azure for developers", "event driven architecture azure checklist", "event driven architecture azure tips", "event driven architecture azure deep dive", "event driven architecture azure comparison", "event driven architecture azure vs alternatives", "event driven architecture azure .NET Core", "event driven architecture azure Azure", "event driven architecture azure explained", "event driven architecture azure when to use", "event driven architecture azure enterprise", "event driven architecture azure .NET", "what is event driven architecture azure", "event driven architecture azure summary", "event driven architecture azure introduction", "event driven architecture azure fundamentals", "event driven architecture azure step by step", "event driven architecture azure complete guide", "event driven architecture azure for beginners", "event driven architecture azure advanced", "event driven architecture azure production", "event driven architecture azure real world", "event driven architecture azure example code", "event driven architecture azure C# example", "event driven architecture azure .NET example", "learn event driven architecture azure", "event driven architecture azure learn", "event driven architecture azure reference", "event driven architecture azure cheat sheet", "event driven architecture azure pitfalls", "event driven architecture azure common mistakes", "event driven architecture azure performance", "event driven architecture azure optimization", "event driven architecture azure security", "event driven architecture azure testing", "event driven architecture azure unit test", "event driven architecture azure integration", "event driven architecture azure migration", "event driven architecture azure from scratch", "event driven architecture azure 2024", "event driven architecture azure 2025", "best event driven architecture azure", "event driven architecture azure best", "pro event driven architecture azure", "event driven architecture azure expert", "event driven architecture azure consultant", "event driven architecture azure services", "event driven architecture azure course", "event driven architecture azure workshop", "event driven architecture azure webinar", "event driven architecture azure blog", "event driven architecture azure article", "event driven architecture azure post", "why event driven architecture azure", "when event driven architecture azure", "where event driven architecture azure", "event driven architecture azure in .NET 6", "event driven architecture azure in .NET 7", "event driven architecture azure in .NET 8", "event driven architecture azure for C#", "event driven architecture azure for Angular", "event driven architecture azure for Vue", "event driven architecture azure for React", "event driven architecture azure for Azure", "event driven architecture azure for microservices", "event driven architecture azure for API", "event driven architecture azure for database", "event driven architecture azure for testing", "event driven architecture azure for DevOps", "event driven architecture azure for senior developers", "event driven architecture azure for team", "event driven architecture azure for production", "event driven architecture azure for scale", "event driven architecture azure for refactoring", "event driven architecture azure for enterprise applications", "event driven architecture azure for startup", "event driven architecture azure in 2024", "event driven architecture azure in 2025", "event driven architecture azure in 2026", "event driven architecture azure code sample", "event driven architecture azure code example", "event driven architecture azure sample code", "event driven architecture azure full example", "event driven architecture azure working example", "event driven architecture azure practical event driven architecture azure", "event driven architecture azure real world example", "event driven architecture azure use case", "event driven architecture azure use cases", "event driven architecture azure scenario", "event driven architecture azure scenarios", "event driven architecture azure pattern", "event driven architecture azure approach", "event driven architecture azure approaches", "event driven architecture azure strategy", "event driven architecture azure strategies", "event driven architecture azure technique", "event driven architecture azure techniques", "event driven architecture azure method", "event driven architecture azure methods", "event driven architecture azure solution", "event driven architecture azure solutions", "event driven architecture azure implementation guide", "event driven architecture azure getting started", "event driven architecture azure quick start", "event driven architecture azure overview guide", "event driven architecture azure comprehensive guide", "event driven architecture azure detailed guide", "event driven architecture azure practical guide", "event driven architecture azure developer guide", "event driven architecture azure engineer guide", "event driven architecture azure architect guide", "event driven architecture azure for architects", "event driven architecture azure for backend", "event driven architecture azure for tech leads", "event driven architecture azure for senior devs", "benefits of event driven architecture azure", "advantages of event driven architecture azure", "alternatives to event driven architecture azure", "compared to event driven architecture azure", "intro to event driven architecture azure", "basics of event driven architecture azure", "event driven architecture azure tips and tricks", "event driven architecture azure production-ready", "event driven architecture azure enterprise-grade", "event driven architecture azure with Docker", "event driven architecture azure with Kubernetes", "event driven architecture azure in ASP.NET Core", "event driven architecture azure with Entity Framework", "event driven architecture azure with EF Core", "event driven architecture azure modern", "event driven architecture azure updated", "event driven architecture azure latest", "event driven architecture azure walkthrough", "event driven architecture azure hands-on", "event driven architecture azure practical examples", "event driven architecture azure real-world examples", "event driven architecture azure common pitfalls", "event driven architecture azure gotchas", "event driven architecture azure FAQ", "event driven architecture azure FAQs", "event driven architecture azure Q&A", "event driven architecture azure interview questions", "event driven architecture azure interview", "event driven architecture azure certification", "event driven architecture azure training", "event driven architecture azure video", "event driven architecture azure series", "event driven architecture azure part 1", "event driven architecture azure core concepts", "event driven architecture azure key concepts", "event driven architecture azure recap", "event driven architecture azure takeaways", "event driven architecture azure conclusion", "event driven architecture azure next steps", "event driven architecture azure further reading", "event driven architecture azure resources", "event driven architecture azure tools", "event driven architecture azure libraries", "event driven architecture azure frameworks", "event driven architecture azure NuGet", "event driven architecture azure package", "event driven architecture azure GitHub", "event driven architecture azure open source", "event driven architecture azure community", "event driven architecture azure Microsoft docs", "event driven architecture azure documentation", "event driven architecture azure official guide", "event driven architecture azure official tutorial", "event driven architecture azure on Azure", "Azure event driven architecture azure", "event driven architecture azure Azure cloud", "Azure event driven architecture azure pattern", "Event", "Event guide", "Event tutorial", "Event best practices", "Event in .NET", "Event in C#", "Event for developers", "Event examples", "Event patterns", "Event overview", "Event introduction", "Event deep dive", "Event explained", "Event how to", "Event what is", "Event when to use", "Event for enterprise", "Event .NET Core", "Event Azure", "Event C#", "Event with .NET", "Event with C#", "Event with Azure", "Event with Angular", "Event with Vue", "Event with React", "Event with Entity Framework", "Event with SQL Server", "Event step by step", "Event complete guide", "Event from scratch", "Event 2024", "Event 2025", "Event 2026", "Event code example", "Event sample code", "Event implementation", "Event real world", "Event production", "Event for beginners", "Event advanced", "Event for architects", "Event for backend", "Event for API", "Event in ASP.NET Core", "Event with EF Core", "Event tutorial 2024", "Event guide 2025", "Event best practices 2024", "Event C# examples", "Event .NET examples", "Event implementation guide", "Event how to implement", "Event benefits", "Event advantages", "Event pitfalls", "Event alternatives", "Event compared", "Event intro", "Event basics", "Event tips and tricks", "Event production-ready", "Event enterprise-grade", "Event maintainable", "Event testable", "Event refactoring", "Event modern", "Event updated", "Event latest", "Event for tech leads", "Event for senior devs", "Event with Docker", "Event with Kubernetes", "Event in .NET 8", "Event in .NET 7", "Event in .NET 6", "Event Driven", "Event Driven guide", "Event Driven tutorial", "Event Driven best practices", "Event Driven in .NET", "Event Driven in C#", "Event Driven for developers", "Event Driven examples", "Event Driven patterns", "Event Driven overview", "Event Driven introduction", "Event Driven deep dive", "Event Driven explained", "Event Driven how to", "Event Driven what is", "Event Driven when to use", "Event Driven for enterprise", "Event Driven .NET Core", "Event Driven Azure", "Event Driven C#", "Event Driven with .NET", "Event Driven with C#", "Event Driven with Azure", "Event Driven with Angular", "Event Driven with Vue", "Event Driven with React", "Event Driven with Entity Framework", "Event Driven with SQL Server", "Event Driven step by step", "Event Driven complete guide", "Event Driven from scratch", "Event Driven 2024", "Event Driven 2025", "Event Driven 2026", "Event Driven code example", "Event Driven sample code", "Event Driven implementation", "Event Driven real world", "Event Driven production", "Event Driven for beginners", "Event Driven advanced", "Event Driven for architects", "Event Driven for backend", "Event Driven for API", "Event Driven in ASP.NET Core", "Event Driven with EF Core", "Event Driven tutorial 2024", "Event Driven guide 2025", "Event Driven best practices 2024", "Event Driven C# examples", "Event Driven .NET examples", "Event Driven implementation guide", "Event Driven how to implement", "Event Driven benefits", "Event Driven advantages", "Event Driven pitfalls", "Event Driven alternatives", "Event Driven compared", "Event Driven intro", "Event Driven basics", "Event Driven tips and tricks", "Event Driven production-ready", "Event Driven enterprise-grade", "Event Driven maintainable", "Event Driven testable", "Event Driven refactoring", "Event Driven modern", "Event Driven updated", "Event Driven latest", "Event Driven for tech leads", "Event Driven for senior devs", "Event Driven with Docker", "Event Driven with Kubernetes", "Event Driven in .NET 8", "Event Driven in .NET 7", "Event Driven in .NET 6", "Event Driven Architecture", "Event Driven Architecture guide", "Event Driven Architecture tutorial", "Event Driven Architecture best practices", "Event Driven Architecture in .NET", "Event Driven Architecture in C#", "Event Driven Architecture for developers", "Event Driven Architecture examples", "Event Driven Architecture patterns", "Event Driven Architecture overview", "Event Driven Architecture introduction", "Event Driven Architecture deep dive", "Event Driven Architecture explained", "Event Driven Architecture how to", "Event Driven Architecture what is", "Event Driven Architecture when to use", "Event Driven Architecture for enterprise", "Event Driven Architecture .NET Core", "Event Driven Architecture C#", "Event Driven Architecture with .NET", "Event Driven Architecture with C#", "Event Driven Architecture with Azure", "Event Driven Architecture with Angular", "Event Driven Architecture with Vue", "Event Driven Architecture with React", "Event Driven Architecture with Entity Framework", "Event Driven Architecture with SQL Server", "Event Driven Architecture step by step", "Event Driven Architecture complete guide", "Event Driven Architecture from scratch", "Event Driven Architecture 2024", "Event Driven Architecture 2025", "Event Driven Architecture 2026", "Event Driven Architecture code example", "Event Driven Architecture sample code", "Event Driven Architecture implementation", "Event Driven Architecture real world", "Event Driven Architecture production", "Event Driven Architecture for beginners", "Event Driven Architecture advanced", "Event Driven Architecture for architects", "Event Driven Architecture for backend", "Event Driven Architecture for API", "Event Driven Architecture in ASP.NET Core", "Event Driven Architecture with EF Core", "Event Driven Architecture tutorial 2024", "Event Driven Architecture guide 2025", "Event Driven Architecture best practices 2024", "Event Driven Architecture C# examples", "Event Driven Architecture .NET examples", "Event Driven Architecture implementation guide", "Event Driven Architecture how to implement", "Event Driven Architecture benefits", "Event Driven Architecture advantages", "Event Driven Architecture pitfalls", "Event Driven Architecture alternatives", "Event Driven Architecture compared", "Event Driven Architecture intro", "Event Driven Architecture basics", "Event Driven Architecture tips and tricks", "Event Driven Architecture production-ready", "Event Driven Architecture enterprise-grade", "Event Driven Architecture maintainable", "Event Driven Architecture testable", "Event Driven Architecture refactoring", "Event Driven Architecture modern", "Event Driven Architecture updated", "Event Driven Architecture latest", "Event Driven Architecture for tech leads", "Event Driven Architecture for senior devs", "Event Driven Architecture with Docker", "Event Driven Architecture with Kubernetes", "Event Driven Architecture in .NET 8", "Event Driven Architecture in .NET 7", "Event Driven Architecture in .NET 6", "Event Driven Architecture Azure how to", "Event Driven Architecture Azure what is"],
  relatedServices: ["microservices-architecture","azure-cloud-architecture"],
  relatedProjects: ["bat-inhouse-app"],
  relatedArticleSlugs: ["azure-microservices-best-practices","azure-cloud-architecture-patterns"],
  author: "Waqas Ahmad",
  content: `## Introduction

This guidance is relevant when the topic of this article applies to your system or design choices; it breaks down when constraints or context differ. I've applied it in real projects and refined the takeaways over time (as of 2026).

**Event-driven architecture** on Azure lets you build **loosely coupled**, **scalable** systems that react to changes in real time. Whether you are integrating microservices, processing telemetry, or reacting to Azure resource events, the platform offers three main building blocks: **Azure Service Bus**, **Azure Event Grid**, and **Azure Event Hubs**. Picking the right one—and designing for **at-least-once delivery**, **idempotency**, and **replay**—is critical for production reliability.

This article is a **full, in-depth guide** to **event-driven architecture on Azure**: what event-driven architecture is, what **Service Bus**, **Event Grid**, and **Event Hubs** are and when to use each, how to implement producers and consumers, and how to harden your systems for failure and recovery. From BAT's in-house microservices to other enterprise event-driven systems, teams run into trouble when they treat every message as "fire-and-forget" or ignore dead-letter queues and correlation. The patterns below help avoid those pitfalls.

If you are new to event-driven architecture on Azure, start with [Topics covered](#topics-covered) and [Event-driven on Azure at a glance](#event-driven-on-azure-at-a-glance).

## Topics covered

- [Decision Context](#decision-context)
- [What is event-driven architecture and why it matters](#what-is-event-driven-architecture-and-why-it-matters)
- [Event-driven on Azure at a glance](#event-driven-on-azure-at-a-glance)
- [Azure Service Bus: queues and topics](#azure-service-bus-queues-and-topics)
- [Azure Event Grid: event routing and fan-out](#azure-event-grid-event-routing-and-fan-out)
- [Azure Event Hubs: ingestion and stream processing](#azure-event-hubs-ingestion-and-stream-processing)
- [Designing for at-least-once delivery and idempotency](#designing-for-at-least-once-delivery-and-idempotency)
- [Dead-letter queues and monitoring](#dead-letter-queues-and-monitoring)
- [Best practices and common issues](#best-practices-and-common-issues)
- [Summary](#summary)
- [Position & Rationale](#position--rationale)
- [Trade-Offs & Failure Modes](#trade-offs--failure-modes)
- [What Most Guides Miss](#what-most-guides-miss)
- [Decision Framework](#decision-framework)
- [Key Takeaways](#key-takeaways)
- [When I Would Use This Again — and When I Wouldn't](#when-i-would-use-this-again--and-when-i-wouldnt)
- [Frequently Asked Questions](#frequently-asked-questions)

------

## Decision Context

- **System scale:** Varies by context; the approach in this article applies to the scales and scenarios described in the body.
- **Team size:** Typically small to medium teams; ownership and clarity matter more than headcount.
- **Time / budget pressure:** Applicable under delivery pressure; I've used it in both greenfield and incremental refactors.
- **Technical constraints:** .NET and related stack where relevant; constraints are noted in the article where they affect the approach.
- **Non-goals:** This article does not optimize for every possible scenario; boundaries are stated where they matter.


## What is event-driven architecture and why it matters

**Event-driven architecture** is an approach where **components** of a system communicate by **producing** and **consuming** **events**—discrete things that happened (e.g. "OrderPlaced", "BlobCreated", "DeviceTelemetry"). Producers **publish** events without knowing who will consume them; consumers **subscribe** and react. This **decouples** services: the order service does not call the inventory or notification service directly; it publishes \`OrderPlaced\` and any number of subscribers can react. Benefits include **scalability** (add consumers without changing producers), **resilience** (if a consumer is down, events can be queued and processed later where the broker supports it), and **flexibility** (new subscribers can be added without changing existing ones).

On **Azure**, the three main services are **Service Bus** (reliable **queues** and **topics** for your own services), **Event Grid** (high-throughput **event routing** and Azure resource events with fan-out), and **Event Hubs** (high-throughput **ingestion** and **stream processing**). Each has a different **throughput**, **delivery guarantee**, and **use case**. Choosing the wrong one leads to cost, complexity, or reliability issues. This article explains **when to use which** and how to design for **at-least-once** delivery, **idempotency**, and **replay** so that your event-driven systems are production-ready.

---

## Event-driven on Azure at a glance

| Service | What it is | When to use |
|--------|------------|-------------|
| **Azure Service Bus** | **Queues** (point-to-point) and **topics** (publish-subscribe with filters). Durable, ordered (with sessions), dead-letter, deferral. | **Reliable messaging between your services**: order processing, workflow steps, any scenario where you cannot afford to lose a message and order may matter. Not for millions of events/sec. |
| **Azure Event Grid** | **Event routing**: push-based, high throughput, deep Azure integration (blob created, resource changes, custom topics). At-least-once; subscribers must be idempotent. | **Reacting to events** with **fan-out** to many subscribers; Azure resource events; notifications; low-latency event-driven workflows. Does not queue for long-term processing. |
| **Azure Event Hubs** | **High-throughput ingestion**: millions of events per second; **consumer groups** (e.g. hot path vs cold analytics). | **Ingesting** telemetry, logs, and streams; processing with **Stream Analytics**, **Spark**, or your own consumers. Not a general-purpose queue. |

\`\`\`mermaid
flowchart LR
  subgraph Producers
    App[Your app]
    Azure[Azure resources]
  end
  subgraph Messaging
    SB[Service Bus]
    EG[Event Grid]
    EH[Event Hubs]
  end
  subgraph Consumers
    Svc[Microservices]
    Func[Functions]
    Stream[Stream processing]
  end
  App --> SB
  App --> EG
  Azure --> EG
  App --> EH
  SB --> Svc
  EG --> Svc
  EG --> Func
  EH --> Stream
\`\`\`

---

## Azure Service Bus: queues and topics

**Azure Service Bus** provides **queues** (point-to-point: one producer, one consumer pool) and **topics** (publish-subscribe: one producer, many **subscriptions** with optional **filters**). Messages are **durable**, **ordered** within a session if you use sessions, and support **dead-lettering** and **deferral**. Use Service Bus when you need **reliable messaging between your own services**—order processing, workflow steps, or any scenario where you cannot afford to lose a message and where processing order may matter. It is not designed for millions of events per second; it is designed for **consistency** and **durability**.

**Step 1: Send a message to a queue**

\`\`\`csharp
// Producer – send to Service Bus queue
using Azure.Messaging.ServiceBus;

var client = new ServiceBusClient(connectionString);
var sender = client.CreateSender("order-queue");

var message = new ServiceBusMessage(JsonSerializer.Serialize(new OrderPlacedEvent
{
    OrderId = orderId,
    IdempotencyId = Guid.NewGuid().ToString(),
    Timestamp = DateTime.UtcNow
}))
{
    MessageId = idempotencyId,
    CorrelationId = correlationId
};
await sender.SendMessageAsync(message);
await sender.DisposeAsync();
await client.DisposeAsync();
\`\`\`

What this does: Creates a **Service Bus client** and **sender** for the queue \`order-queue\`. Serializes an \`OrderPlacedEvent\` (including an **idempotency ID** and **correlation ID**) and sends it. \`MessageId\` and \`CorrelationId\` are set so that consumers can deduplicate and trace the request.

**Step 2: Receive and process messages**

\`\`\`csharp
// Consumer – receive from Service Bus queue
var client = new ServiceBusClient(connectionString);
var processor = client.CreateProcessor("order-queue", new ServiceBusProcessorOptions
{
    MaxConcurrentCalls = 4,
    AutoCompleteMessages = false
});

processor.ProcessMessageAsync += async args =>
{
    var body = args.Message.Body.ToString();
    var evt = JsonSerializer.Deserialize<OrderPlacedEvent>(body);
    try
    {
        await HandleOrderPlacedAsync(evt, args.CancellationToken);
        await args.CompleteMessageAsync(args.Message);
    }
    catch (Exception)
    {
        await args.AbandonMessageAsync(args.Message); // retry, or eventually DLQ
    }
};
processor.ProcessErrorAsync += args => { /* log */ return Task.CompletedTask; };
await processor.StartProcessingAsync();
\`\`\`

What this does: Creates a **processor** that receives messages from \`order-queue\`. For each message, it deserializes the event, calls \`HandleOrderPlacedAsync\`, and **completes** the message on success or **abandons** it so that Service Bus can retry (and eventually move to the **dead-letter queue** if max delivery count is exceeded). \`AutoCompleteMessages = false\` so that you complete only after successful processing.

**Step 3: Configure queue and dead-letter in Azure**

Create the queue in Azure (Portal, ARM, or Bicep) with **MaxDeliveryCount** (e.g. 10) so that failed messages move to the **dead-letter queue** instead of being dropped. Enable **sessions** if you need FIFO per session key.

How this fits together: Producers send messages with **correlation ID** and **idempotency key**; consumers process them and complete or abandon. Failed messages are retried and eventually land in the DLQ for inspection and resubmit. Use **Application Insights** and **correlation ID** to trace a single business transaction across producers and consumers.

---

## Azure Event Grid: event routing and fan-out

**Azure Event Grid** is an **event routing** service: **high throughput**, **push-based** delivery, and deep integration with **Azure** (e.g. blob created, resource group changes, **custom topics**). Use Event Grid when you are **reacting to events** and need **fan-out** to many subscribers with **low latency**. It is **at-least-once** delivery; subscribers must be **idempotent**. Event Grid does not queue for long-term processing—it pushes and retries with backoff. Ideal for **notifications**, **integrations**, and event-driven workflows that react quickly.

**Publish to a custom topic**

\`\`\`csharp
// Publisher – Event Grid custom topic
using Azure.Messaging.EventGrid;
using Azure.Messaging.EventGrid.SystemEvents;

var client = new EventGridPublisherClient(
    new Uri(topicEndpoint),
    new AzureKeyCredential(topicKey));

var evt = new EventGridEvent(
    subject: "orders/placed",
    eventType: "OrderPlaced",
    dataVersion: "1.0",
    data: new BinaryData(JsonSerializer.Serialize(new OrderPlacedEvent { OrderId = orderId })))
{
    Id = idempotencyId,
    EventTime = DateTimeOffset.UtcNow
};
await client.SendEventAsync(evt);
\`\`\`

What this does: Sends a **custom event** to an **Event Grid topic**. Subscribers (webhooks, Azure Functions, Logic Apps, etc.) receive the event. Use **Id** (idempotency) and **subject** / **eventType** for filtering and routing.

**Subscribe with Azure Functions**

\`\`\`csharp
// Function – Event Grid trigger
[FunctionName("OnOrderPlaced")]
public static async Task Run(
    [EventGridTrigger] EventGridEvent evt,
    ILogger log)
{
    log.LogInformation("Event: {Subject} {Id}", evt.Subject, evt.Id);
    var data = JsonSerializer.Deserialize<OrderPlacedEvent>(evt.Data.ToString());
    await HandleOrderPlacedAsync(data);
}
\`\`\`

What this does: An **Azure Function** triggered by Event Grid receives the event. The function must be **idempotent** (same event may be delivered more than once). Use \`evt.Id\` as idempotency key.

How this fits together: Publishers send events to a **topic**; Event Grid **delivers** to all **subscriptions** (webhook, Function, etc.). Subscribers process and return 2xx; Event Grid retries on failure. No long-term queue—delivery is push-based with retries.

---

## Azure Event Hubs: ingestion and stream processing

**Azure Event Hubs** is for **high-throughput ingestion**: **telemetry**, **logs**, and **stream processing**. It accepts **millions of events per second**; you consume via **consumer groups** (e.g. one group for hot path, another for cold analytics). Use Event Hubs when you are **ingesting** large volumes of data and processing with **Stream Analytics**, **Spark**, or your own consumers. It is **not** a general-purpose queue; use **Service Bus** for that.

**Send events to Event Hubs**

\`\`\`csharp
// Producer – Event Hubs
using Azure.Messaging.EventHubs;
using Azure.Messaging.EventHubs.Producer;

var producer = new EventHubProducerClient(connectionString, eventHubName);
var batch = await producer.CreateBatchAsync();
batch.TryAdd(new EventData(JsonSerializer.Serialize(telemetryEvent)));
await producer.SendAsync(batch);
await producer.DisposeAsync();
\`\`\`

What this does: Creates an **Event Hubs producer** and sends a **batch** of events. Event Hubs is optimized for **throughput**; use batching and multiple partitions for scale.

**Consume with a processor**

\`\`\`csharp
// Consumer – Event Hubs processor
var processor = new EventProcessorClient(
    blobContainerClient, // checkpoint store
    consumerGroup,
    connectionString,
    eventHubName);
processor.ProcessEventAsync += async args =>
{
    var body = args.Data.Body.ToString();
    await ProcessTelemetryAsync(body);
};
await processor.StartProcessingAsync();
\`\`\`

What this does: **EventProcessorClient** reads from a **consumer group** and **checkpoints** progress in blob storage. Each partition is processed by one processor instance; scale out by adding instances. Use **consumer groups** to have multiple independent consumers (e.g. real-time alerts vs batch analytics).

How this fits together: Producers send high-volume events to **Event Hubs**; consumers in one or more **consumer groups** process them. **Stream Analytics**, **Spark**, or custom processors read from a consumer group. **Retention** allows replay by resetting consumer offset. Do not use Event Hubs as a queue for transactional workflows—use **Service Bus** for that.

---

## Designing for at-least-once delivery and idempotency

Both **Service Bus** and **Event Grid** deliver **at least once**. Your handler may receive the same message or event **more than once** (e.g. after a retry or replay). Your processing logic must be **idempotent**: processing the same message twice should not double-charge a customer or create duplicate records. Use a **correlation ID** or **idempotency key** (stored in cache or database) to **detect and skip** duplicates.

**Idempotent handler pattern**

\`\`\`csharp
// Idempotent handler – check before process
public async Task HandleOrderPlacedAsync(OrderPlacedEvent evt, CancellationToken ct)
{
    if (await _processedIds.ExistsAsync(evt.IdempotencyId, ct))
        return; // already processed
    await _processedIds.AddAsync(evt.IdempotencyId, ct);

    await _orderService.CreateOrderAsync(evt.OrderId, evt.Payload, ct);
}
\`\`\`

What this does: Before processing, **check** whether \`IdempotencyId\` has already been processed (e.g. in a cache or table). If yes, **return** without side effects. If no, **add** the key and then perform the operation. For **updates**, use **upsert** (insert or update by key) so that replay overwrites instead of duplicating.

How this fits together: Every event carries an **idempotency key**; handlers **record** processed keys and **skip** duplicates. Combined with **correlation ID** in headers and logs, you can trace a business transaction end-to-end and avoid duplicate side effects on retry or replay.

---

## Dead-letter queues and monitoring

Configure **dead-letter queues (DLQ)** on Service Bus **queues** and **subscriptions** so that messages that fail after **max delivery count** are moved there instead of dropped. **Process the DLQ** periodically: fix the bug or data, then **resubmit** to the main queue or **abandon**. Use **Application Insights** or your logging stack to **alert on DLQ depth** and processing failures. **Correlate** requests with **trace IDs** across services so you can follow a single business transaction through the event pipeline.

**Service Bus:** Set \`MaxDeliveryCount\` on the queue or subscription; failed messages move to the **dead-letter** subqueue. Use \`MessageReceiver\` to read from the DLQ and resubmit or abandon. **Event Grid:** Subscribers return 2xx on success; Event Grid retries with backoff on failure. There is no built-in DLQ; ensure your endpoint is idempotent and log failures for manual or automated retry. **Event Hubs:** No DLQ; consumers checkpoint progress. Failed processing is handled in your code (retry, skip, or write to a separate store for later replay).

---

## Best practices and common issues

**Do:** **Match the service to the pattern**—Service Bus for queues/topics, Event Grid for event routing, Event Hubs for ingestion and streaming. **Design for idempotency** (idempotency key, skip or upsert). **Propagate correlation ID** in message headers and logs. **Configure DLQ** on Service Bus and **monitor** DLQ depth. **Use async** (Service Bus, Event Grid) for cross-service communication; use sync only at the edge or within a single service.

**Don't:** Use **Service Bus** for ingestion at millions/sec, or **Event Hubs** as a general queue—leads to cost and complexity. **Non-idempotent handlers** lead to duplicate processing. **Ignoring the DLQ** means failed messages are never fixed. **Missing correlation IDs** make debugging and tracing impossible.

**Common issues:**

- **Using the wrong service:** Service Bus for millions/sec ingestion, or Event Hubs as a general queue. **Fix:** Use **Service Bus** for reliable queues/topics; **Event Grid** for event routing; **Event Hubs** for ingestion and stream processing.
- **Non-idempotent handlers:** Processing the same message twice double-charges or duplicates records. **Fix:** Use **idempotency key** and **store processed keys**; skip or upsert on replay.
- **Ignoring dead-letter queues:** Failed messages sit in the DLQ; no one processes them. **Fix:** **Monitor DLQ depth**; **process** (fix and resubmit or abandon) periodically; **alert** when depth exceeds a threshold.
- **Missing correlation IDs:** Cannot trace a business transaction end-to-end. **Fix:** **Propagate correlation ID** in message headers and logs; use **Application Insights** or OpenTelemetry with **distributed tracing**.
- **Over-relying on sync:** Mixing sync REST between services with events increases coupling and latency. **Fix:** **Prefer async** (Service Bus, Event Grid) for cross-service communication.

---
---

## Position & Rationale

I choose **Service Bus** when I need reliable, ordered messaging between our own services—order processing, workflow steps—where we cannot afford to lose a message. I use **Event Grid** when we are reacting to events with fan-out (many subscribers) or integrating with Azure resource events; I do not use it as a long-term queue. I use **Event Hubs** only for high-throughput ingestion (telemetry, logs) and stream processing; I never use it as a general-purpose queue. I reject using Event Hubs for transactional workflows—throughput and partitioning are wrong for that. I insist on **idempotency keys** and **correlation IDs** on every event and message; without them, debugging and duplicate handling are unsustainable. I avoid fire-and-forget publishing without at-least-once semantics and a clear DLQ story for Service Bus.

---

## Trade-Offs & Failure Modes

- **What this sacrifices:** Event-driven systems trade synchronous consistency for eventual consistency; you give up simple request–response debugging and must design for replay and duplicates.
- **Where it degrades:** Wrong service choice (e.g. Event Hubs as a queue) leads to cost and complexity. Non-idempotent handlers cause duplicate charges or duplicate records under retry. Ignoring the DLQ means failed messages are never fixed.
- **How it fails when misapplied:** Using Service Bus for millions of events per second, or Event Hubs for ordered workflow steps. Missing correlation IDs make cross-service tracing impossible. Sync coupling between services alongside events increases latency and coupling.
- **Early warning signs:** "We can't trace a single order across services"; DLQ depth growing without a process to fix; handlers that assume exactly-once delivery.

---

## What Most Guides Miss

Most guides show publishing and subscribing but skip **idempotency** and **DLQ handling**. In production, at-least-once delivery means every handler will see duplicates; without an idempotency key and a store of processed IDs (or upsert semantics), you get duplicate side effects. Few tutorials emphasise **monitoring the DLQ** and having a clear process to fix, resubmit, or abandon—so teams discover too late that failed messages pile up. Correlation ID propagation in headers and logs is also underplayed; without it, debugging a single business transaction across Event Grid, Service Bus, and multiple handlers is painful.

---

## Decision Framework

- **If you need reliable messaging between your services (orders, workflows)** → Use **Service Bus** (queue or topic); set MaxDeliveryCount and use the DLQ; use idempotency keys and correlation ID.
- **If you need fan-out to many subscribers or Azure resource events** → Use **Event Grid**; make handlers idempotent; do not use it as a long-term queue.
- **If you need to ingest telemetry or logs at high throughput** → Use **Event Hubs** with consumer groups; use Stream Analytics or your own processors; do not use it as a general queue.
- **If you are unsure** → Match the service to the pattern (messaging vs routing vs ingestion); avoid using one service for another's job.
- **If handlers are not idempotent** → Add idempotency key and processed-key check (or upsert) before any side effect; treat this as non-negotiable.

---

## Key Takeaways

- Service Bus for reliable queues/topics; Event Grid for event routing and fan-out; Event Hubs for ingestion and streaming—do not swap their roles.
- Design every handler for at-least-once: idempotency key, skip or upsert on replay, correlation ID for tracing.
- Configure and monitor the DLQ on Service Bus; have a process to fix and resubmit or abandon.
- Revisit service choice when requirements change (e.g. scale, ordering, or consistency needs).


## Summary

- **Event-driven architecture** on Azure uses **Service Bus** (reliable queues/topics), **Event Grid** (event routing, fan-out), and **Event Hubs** (ingestion, stream processing). Choose the right service for the pattern.
- **Service Bus:** Reliable, ordered messaging between your services; queues and topics; dead-letter; use for order processing, workflows.
- **Event Grid:** High-throughput event routing; Azure resource events; fan-out to many subscribers; push-based; use for notifications, integrations, low-latency reactions.
- **Event Hubs:** High-throughput ingestion; consumer groups; use for telemetry, logs, stream processing (Stream Analytics, Spark).
- **Design for at-least-once:** **Idempotent handlers** (idempotency key, skip or upsert); **correlation ID** for tracing; **dead-letter queues** and **monitoring** so that failures are visible and recoverable. Avoid wrong service choice, non-idempotent handlers, and ignoring the DLQ.

---

## When I Would Use This Again — and When I Wouldn't

I would use Service Bus again for any system that needs reliable, ordered messaging between our services and can invest in idempotency and DLQ handling. I would use Event Grid again for Azure resource events and custom event routing with fan-out. I would use Event Hubs again for telemetry and stream processing. I wouldn't use Event Hubs as a queue, or Service Bus for millions-of-events-per-second ingestion—wrong tool, wrong cost and behaviour. I wouldn't go event-driven if the team cannot own idempotency, correlation, and DLQ monitoring; sync APIs or a simple queue may be better. If the domain does not need decoupling or replay, a straightforward request–response API is simpler.


---

## Frequently Asked Questions

### When should I use Service Bus vs Event Grid vs Event Hubs?

**Service Bus:** Reliable **queues** and **topics** between your services; ordered, durable; dead-letter. **Event Grid:** High-throughput **event routing**, Azure resource events, **fan-out** to many subscribers. **Event Hubs:** High-throughput **ingestion** (telemetry, logs) and **stream processing**. Do not use Event Hubs as a general queue.

### How do I make my event handler idempotent?

Use an **idempotency key** (e.g. in the message) and **store processed keys** (cache or DB); if the key exists, **skip** or return success. For updates, use **upsert** (insert or update by key) so that replay does not duplicate. Design so that processing the same message twice has the **same effect** as once.

### What happens when a message fails in Service Bus?

After **max delivery count** (configurable), the message is moved to the **dead-letter queue (DLQ)**. **Process the DLQ**: fix the bug or data, then **resubmit** to the main queue or **abandon**. **Alert on DLQ depth** so that failures are visible.

### How do I trace a request across event-driven services?

**Propagate correlation ID** (and trace ID) in **message headers**; each service **logs** the correlation ID. Use **Application Insights** or **OpenTelemetry** with **distributed tracing** so that you can follow a single business transaction across Service Bus, Event Grid, and your handlers.

### What are common mistakes with event-driven architecture on Azure?

**Wrong service choice** (e.g. Event Hubs as a queue). **Non-idempotent handlers** leading to duplicate processing. **Ignoring DLQ** so that failed messages are never fixed. **Sync coupling** between services instead of async. **Missing correlation** so that debugging is impossible.

### How do I handle late-arriving or out-of-order events?

Design for **eventual consistency**. In **stream processing**, use **watermarks** or **event time** so that late data can be incorporated. For **batch**, use **idempotent merge** (e.g. upsert by key) so that late arrivals overwrite or append correctly.

### When should I use Service Bus?

Use Service Bus when you need **reliable messaging between your own services**: order processing, workflow steps, or any scenario where you **cannot afford to lose a message** and where **processing order** may matter. Supports **queues** (point-to-point) and **topics** (publish-subscribe with filters); **sessions** for ordering; **dead-letter** and **deferral**.

### When should I use Event Grid?

Use Event Grid when you are **reacting to events** and need **fan-out** to many subscribers with **low latency**; **Azure resource events** (blob created, resource changes); **custom topics** for your own events. Push-based delivery; at-least-once; subscribers must be **idempotent**. Not for long-term queuing.

### When should I use Event Hubs?

Use Event Hubs when you are **ingesting** large volumes of data (**telemetry**, **logs**) and processing with **Stream Analytics**, **Spark**, or your own consumers. **Millions of events per second**; **consumer groups** for multiple independent consumers. Not a general-purpose queue.

### What is at-least-once delivery?

**At-least-once** means the message or event **may be delivered more than once** (e.g. after a retry or replay). Your handler must be **idempotent**: processing the same message twice must not cause duplicate side effects (e.g. double charge, duplicate record). Use **idempotency key** and **skip or upsert** on replay.

### How do I monitor event-driven systems?

Use **Application Insights** (or similar) for **logs** and **metrics**; **DLQ depth** alerts on Service Bus; **correlation ID** and **distributed tracing** to follow a transaction across producers and consumers. Alert on **processing failures** and **DLQ depth** so that issues are visible.

### What is a correlation ID?

A **correlation ID** is an identifier (e.g. GUID) that **traces a single business transaction** across services. **Propagate** it in message **headers** and **logs** so that when debugging, you can find all related logs and spans for that transaction. Use with **Application Insights** or **OpenTelemetry** for distributed tracing.

### How do I handle failures and retries?

**Service Bus:** Configure **max delivery count**; failed messages go to **DLQ**. Process DLQ to fix and **resubmit** or **abandon**. Use **AbandonMessageAsync** in the handler to trigger retry. **Event Grid:** Subscriber returns 2xx on success; Event Grid **retries** with backoff on failure. **Event Hubs:** No built-in DLQ; implement retry or write failed events to a store for replay.

### Event Grid vs webhooks?

**Event Grid** is a **managed** event routing service: **retries**, **filters**, **Azure integration**, and **multiple subscribers**. **Webhooks** are a simple HTTP callback—you implement the endpoint; no built-in retry or filtering. Event Grid is more robust for production event-driven workflows.

### How do I replay events?

**Event Hubs:** Events are stored for **retention** (configurable). **Replay** by creating a new **consumer group** or **resetting the consumer offset** to an earlier position. **Service Bus:** No built-in replay; use **deferral** or **schedule** messages for later. For replay of past events, store events in Event Hubs or a store and replay by re-reading.
`,
  faqs: [
  {
    "question": "When should I use Service Bus vs Event Grid vs Event Hubs?",
    "answer": "Service Bus: reliable queues and topics between your services; ordered, durable. Event Grid: high-throughput event routing, Azure resource events, fan-out. Event Hubs: high-throughput ingestion (telemetry, logs) and stream processing. Do not use Event Hubs as a general queue."
  },
  {
    "question": "How do I make my event handler idempotent?",
    "answer": "Use an idempotency key (e.g. in the message) and store processed keys (cache or DB); if the key exists, skip or return success. For updates, use upsert (insert or update by key) so that replay does not duplicate."
  },
  {
    "question": "What happens when a message fails in Service Bus?",
    "answer": "After max delivery count (configurable), the message is moved to the dead-letter queue (DLQ). Process the DLQ: fix the bug or data, then resubmit to the main queue or abandon. Alert on DLQ depth."
  },
  {
    "question": "How do I trace a request across event-driven services?",
    "answer": "Propagate correlation ID (and trace ID) in message headers; each service logs the correlation ID. Use Application Insights or OpenTelemetry with distributed tracing."
  },
  {
    "question": "What are common mistakes with event-driven architecture on Azure?",
    "answer": "Wrong service choice (e.g. Event Hubs as a queue). Non-idempotent handlers leading to duplicate processing. Ignoring DLQ so that failed messages are never fixed. Sync coupling between services instead of async. Missing correlation so that debugging is impossible."
  },
  {
    "question": "How do I handle late-arriving or out-of-order events?",
    "answer": "Design for eventual consistency. In stream processing, use watermarks or event time so that late data can be incorporated. For batch, use idempotent merge (e.g. upsert by key)."
  },
  {
    "question": "When should I use Service Bus?",
    "answer": "Use Service Bus when you need reliable messaging between your own services: order processing, workflow steps, or any scenario where you cannot afford to lose a message and where processing order may matter. Queues, topics, sessions, dead-letter."
  },
  {
    "question": "When should I use Event Grid?",
    "answer": "Use Event Grid when you are reacting to events and need fan-out to many subscribers with low latency; Azure resource events; custom topics. Push-based; at-least-once; subscribers must be idempotent."
  },
  {
    "question": "When should I use Event Hubs?",
    "answer": "Use Event Hubs when you are ingesting large volumes of data (telemetry, logs) and processing with Stream Analytics, Spark, or your own consumers. Millions of events per second; consumer groups. Not a general-purpose queue."
  },
  {
    "question": "What is at-least-once delivery?",
    "answer": "At-least-once means the message or event may be delivered more than once. Your handler must be idempotent: processing the same message twice must not cause duplicate side effects. Use idempotency key and skip or upsert on replay."
  },
  {
    "question": "How do I monitor event-driven systems?",
    "answer": "Use Application Insights for logs and metrics; DLQ depth alerts on Service Bus; correlation ID and distributed tracing to follow a transaction across producers and consumers. Alert on processing failures and DLQ depth."
  },
  {
    "question": "What is a correlation ID?",
    "answer": "A correlation ID is an identifier that traces a single business transaction across services. Propagate it in message headers and logs so you can find all related logs and spans. Use with Application Insights or OpenTelemetry."
  },
  {
    "question": "How do I handle failures and retries?",
    "answer": "Service Bus: max delivery count; failed messages go to DLQ. Process DLQ to fix and resubmit or abandon. Event Grid: subscriber returns 2xx; Event Grid retries with backoff. Event Hubs: implement retry or write failed events for replay."
  },
  {
    "question": "Event Grid vs webhooks?",
    "answer": "Event Grid is a managed event routing service: retries, filters, Azure integration, multiple subscribers. Webhooks are a simple HTTP callback with no built-in retry or filtering. Event Grid is more robust for production."
  },
  {
    "question": "How do I replay events?",
    "answer": "Event Hubs: events stored for retention. Replay by creating a new consumer group or resetting the consumer offset. Service Bus: no built-in replay; use deferral or schedule. For past events, store in Event Hubs or a store and re-read."
  }
]
}
