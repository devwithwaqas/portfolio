/**
 * Blog article: owasp-api-security-top-10
 * Auto-generated by scripts/split-blog-articles.js. Do not edit the content here by hand if you run the split script again.
 */

export default {
  slug: "owasp-api-security-top-10",
  title: "OWASP API Security Top 10: What .NET Developers Must Know",
  excerpt: "Broken object level authorization, broken authentication, and the rest of OWASP API Top 10. Mitigations in .NET and Azure.",
  date: "2025-07-02",
  topic: "Full-Stack",
  keywords: ["OWASP API Security Top 10: What .NET Developers Must Know", "Owasp Api Security Top 10", "Owasp Api Security Top 10 best practices", "how to owasp api security top 10", "owasp api security top 10 in .NET", "owasp api security top 10 guide", "owasp api security top 10 for enterprise", "owasp api security top 10 patterns", "when to use owasp api security top 10", "owasp api security top 10 tutorial", "owasp api security top 10 examples", "owasp api security top 10 in C#", "owasp api security top 10 overview", "owasp api security top 10 implementation", "understanding owasp api security top 10", "owasp api security top 10 for developers", "owasp api security top 10 checklist", "owasp api security top 10 tips", "owasp api security top 10 deep dive", "owasp api security top 10 comparison", "owasp api security top 10 vs alternatives", "owasp api security top 10 .NET Core", "owasp api security top 10 Azure", "owasp api security top 10 explained", "owasp api security top 10 when to use", "owasp api security top 10 enterprise", "owasp api security top 10 .NET", "what is owasp api security top 10", "owasp api security top 10 summary", "owasp api security top 10 introduction", "owasp api security top 10 fundamentals", "owasp api security top 10 step by step", "owasp api security top 10 complete guide", "owasp api security top 10 for beginners", "owasp api security top 10 advanced", "owasp api security top 10 production", "owasp api security top 10 real world", "owasp api security top 10 example code", "owasp api security top 10 C# example", "owasp api security top 10 .NET example", "learn owasp api security top 10", "owasp api security top 10 learn", "owasp api security top 10 reference", "owasp api security top 10 cheat sheet", "owasp api security top 10 pitfalls", "owasp api security top 10 common mistakes", "owasp api security top 10 performance", "owasp api security top 10 optimization", "owasp api security top 10 security", "owasp api security top 10 testing", "owasp api security top 10 unit test", "owasp api security top 10 integration", "owasp api security top 10 migration", "owasp api security top 10 from scratch", "owasp api security top 10 2024", "owasp api security top 10 2025", "best owasp api security top 10", "owasp api security top 10 best", "pro owasp api security top 10", "owasp api security top 10 expert", "owasp api security top 10 consultant", "owasp api security top 10 services", "owasp api security top 10 course", "owasp api security top 10 workshop", "owasp api security top 10 webinar", "owasp api security top 10 blog", "owasp api security top 10 article", "owasp api security top 10 post", "why owasp api security top 10", "when owasp api security top 10", "where owasp api security top 10", "owasp api security top 10 in .NET 6", "owasp api security top 10 in .NET 7", "owasp api security top 10 in .NET 8", "owasp api security top 10 for C#", "owasp api security top 10 for Angular", "owasp api security top 10 for Vue", "owasp api security top 10 for React", "owasp api security top 10 for Azure", "owasp api security top 10 for microservices", "owasp api security top 10 for API", "owasp api security top 10 for database", "owasp api security top 10 for testing", "owasp api security top 10 for DevOps", "owasp api security top 10 for senior developers", "owasp api security top 10 for team", "owasp api security top 10 for production", "owasp api security top 10 for scale", "owasp api security top 10 for refactoring", "owasp api security top 10 for enterprise applications", "owasp api security top 10 for startup", "owasp api security top 10 in 2024", "owasp api security top 10 in 2025", "owasp api security top 10 in 2026", "owasp api security top 10 code sample", "owasp api security top 10 code example", "owasp api security top 10 sample code", "owasp api security top 10 full example", "owasp api security top 10 working example", "owasp api security top 10 practical owasp api security top 10", "owasp api security top 10 real world example", "owasp api security top 10 use case", "owasp api security top 10 use cases", "owasp api security top 10 scenario", "owasp api security top 10 scenarios", "owasp api security top 10 pattern", "owasp api security top 10 approach", "owasp api security top 10 approaches", "owasp api security top 10 strategy", "owasp api security top 10 strategies", "owasp api security top 10 technique", "owasp api security top 10 techniques", "owasp api security top 10 method", "owasp api security top 10 methods", "owasp api security top 10 solution", "owasp api security top 10 solutions", "owasp api security top 10 implementation guide", "owasp api security top 10 getting started", "owasp api security top 10 quick start", "owasp api security top 10 overview guide", "owasp api security top 10 comprehensive guide", "owasp api security top 10 detailed guide", "owasp api security top 10 practical guide", "owasp api security top 10 developer guide", "owasp api security top 10 engineer guide", "owasp api security top 10 architect guide", "owasp api security top 10 for architects", "owasp api security top 10 for backend", "owasp api security top 10 for tech leads", "owasp api security top 10 for senior devs", "benefits of owasp api security top 10", "advantages of owasp api security top 10", "alternatives to owasp api security top 10", "compared to owasp api security top 10", "intro to owasp api security top 10", "basics of owasp api security top 10", "owasp api security top 10 tips and tricks", "owasp api security top 10 production-ready", "owasp api security top 10 enterprise-grade", "owasp api security top 10 with Docker", "owasp api security top 10 with Kubernetes", "owasp api security top 10 in ASP.NET Core", "owasp api security top 10 with Entity Framework", "owasp api security top 10 with EF Core", "owasp api security top 10 modern", "owasp api security top 10 updated", "owasp api security top 10 latest", "owasp api security top 10 walkthrough", "owasp api security top 10 hands-on", "owasp api security top 10 practical examples", "owasp api security top 10 real-world examples", "owasp api security top 10 common pitfalls", "owasp api security top 10 gotchas", "owasp api security top 10 FAQ", "owasp api security top 10 FAQs", "owasp api security top 10 Q&A", "owasp api security top 10 interview questions", "owasp api security top 10 interview", "owasp api security top 10 certification", "owasp api security top 10 training", "owasp api security top 10 video", "owasp api security top 10 series", "owasp api security top 10 part 1", "owasp api security top 10 core concepts", "owasp api security top 10 key concepts", "owasp api security top 10 recap", "owasp api security top 10 takeaways", "owasp api security top 10 conclusion", "owasp api security top 10 next steps", "owasp api security top 10 further reading", "owasp api security top 10 resources", "owasp api security top 10 tools", "owasp api security top 10 libraries", "owasp api security top 10 frameworks", "owasp api security top 10 NuGet", "owasp api security top 10 package", "owasp api security top 10 GitHub", "owasp api security top 10 open source", "owasp api security top 10 community", "owasp api security top 10 Microsoft docs", "owasp api security top 10 documentation", "owasp api security top 10 official guide", "owasp api security top 10 official tutorial", "Owasp", "Owasp guide", "Owasp tutorial", "Owasp best practices", "Owasp in .NET", "Owasp in C#", "Owasp for developers", "Owasp examples", "Owasp patterns", "Owasp overview", "Owasp introduction", "Owasp deep dive", "Owasp explained", "Owasp how to", "Owasp what is", "Owasp when to use", "Owasp for enterprise", "Owasp .NET Core", "Owasp Azure", "Owasp C#", "Owasp with .NET", "Owasp with C#", "Owasp with Azure", "Owasp with Angular", "Owasp with Vue", "Owasp with React", "Owasp with Entity Framework", "Owasp with SQL Server", "Owasp step by step", "Owasp complete guide", "Owasp from scratch", "Owasp 2024", "Owasp 2025", "Owasp 2026", "Owasp code example", "Owasp sample code", "Owasp implementation", "Owasp real world", "Owasp production", "Owasp for beginners", "Owasp advanced", "Owasp for architects", "Owasp for backend", "Owasp for API", "Owasp in ASP.NET Core", "Owasp with EF Core", "Owasp tutorial 2024", "Owasp guide 2025", "Owasp best practices 2024", "Owasp C# examples", "Owasp .NET examples", "Owasp implementation guide", "Owasp how to implement", "Owasp benefits", "Owasp advantages", "Owasp pitfalls", "Owasp alternatives", "Owasp compared", "Owasp intro", "Owasp basics", "Owasp tips and tricks", "Owasp production-ready", "Owasp enterprise-grade", "Owasp maintainable", "Owasp testable", "Owasp refactoring", "Owasp modern", "Owasp updated", "Owasp latest", "Owasp for tech leads", "Owasp for senior devs", "Owasp with Docker", "Owasp with Kubernetes", "Owasp in .NET 8", "Owasp in .NET 7", "Owasp in .NET 6", "Owasp Api", "Owasp Api guide", "Owasp Api tutorial", "Owasp Api best practices", "Owasp Api in .NET", "Owasp Api in C#", "Owasp Api for developers", "Owasp Api examples", "Owasp Api patterns", "Owasp Api overview", "Owasp Api introduction", "Owasp Api deep dive", "Owasp Api explained", "Owasp Api how to", "Owasp Api what is", "Owasp Api when to use", "Owasp Api for enterprise", "Owasp Api .NET Core", "Owasp Api Azure", "Owasp Api C#", "Owasp Api with .NET", "Owasp Api with C#", "Owasp Api with Azure", "Owasp Api with Angular", "Owasp Api with Vue", "Owasp Api with React", "Owasp Api with Entity Framework", "Owasp Api with SQL Server", "Owasp Api step by step", "Owasp Api complete guide", "Owasp Api from scratch", "Owasp Api 2024", "Owasp Api 2025", "Owasp Api 2026", "Owasp Api code example", "Owasp Api sample code", "Owasp Api implementation", "Owasp Api real world", "Owasp Api production", "Owasp Api for beginners", "Owasp Api advanced", "Owasp Api for architects", "Owasp Api for backend", "Owasp Api for API", "Owasp Api in ASP.NET Core", "Owasp Api with EF Core", "Owasp Api tutorial 2024", "Owasp Api guide 2025", "Owasp Api best practices 2024", "Owasp Api C# examples", "Owasp Api .NET examples", "Owasp Api implementation guide", "Owasp Api how to implement", "Owasp Api benefits", "Owasp Api advantages", "Owasp Api pitfalls", "Owasp Api alternatives", "Owasp Api compared", "Owasp Api intro", "Owasp Api basics", "Owasp Api tips and tricks", "Owasp Api production-ready", "Owasp Api enterprise-grade", "Owasp Api maintainable", "Owasp Api testable", "Owasp Api refactoring", "Owasp Api modern", "Owasp Api updated", "Owasp Api latest", "Owasp Api for tech leads", "Owasp Api for senior devs", "Owasp Api with Docker", "Owasp Api with Kubernetes", "Owasp Api in .NET 8", "Owasp Api in .NET 7", "Owasp Api in .NET 6", "Owasp Api Security", "Owasp Api Security guide", "Owasp Api Security tutorial", "Owasp Api Security best practices", "Owasp Api Security in .NET", "Owasp Api Security in C#", "Owasp Api Security for developers", "Owasp Api Security examples", "Owasp Api Security patterns", "Owasp Api Security overview", "Owasp Api Security introduction", "Owasp Api Security deep dive", "Owasp Api Security explained", "Owasp Api Security how to", "Owasp Api Security what is", "Owasp Api Security when to use", "Owasp Api Security for enterprise", "Owasp Api Security .NET Core", "Owasp Api Security Azure", "Owasp Api Security C#", "Owasp Api Security with .NET", "Owasp Api Security with C#", "Owasp Api Security with Azure", "Owasp Api Security with Angular", "Owasp Api Security with Vue", "Owasp Api Security with React", "Owasp Api Security with Entity Framework", "Owasp Api Security with SQL Server", "Owasp Api Security step by step", "Owasp Api Security complete guide", "Owasp Api Security from scratch", "Owasp Api Security 2024", "Owasp Api Security 2025", "Owasp Api Security 2026", "Owasp Api Security code example", "Owasp Api Security sample code", "Owasp Api Security implementation", "Owasp Api Security real world", "Owasp Api Security production", "Owasp Api Security for beginners", "Owasp Api Security advanced", "Owasp Api Security for architects", "Owasp Api Security for backend", "Owasp Api Security for API", "Owasp Api Security in ASP.NET Core", "Owasp Api Security with EF Core", "Owasp Api Security tutorial 2024", "Owasp Api Security guide 2025", "Owasp Api Security best practices 2024", "Owasp Api Security C# examples", "Owasp Api Security .NET examples", "Owasp Api Security implementation guide", "Owasp Api Security how to implement", "Owasp Api Security benefits", "Owasp Api Security advantages", "Owasp Api Security pitfalls", "Owasp Api Security alternatives", "Owasp Api Security compared", "Owasp Api Security intro", "Owasp Api Security basics", "Owasp Api Security tips and tricks", "Owasp Api Security production-ready", "Owasp Api Security enterprise-grade", "Owasp Api Security maintainable", "Owasp Api Security testable", "Owasp Api Security refactoring", "Owasp Api Security modern", "Owasp Api Security updated", "Owasp Api Security latest", "Owasp Api Security for tech leads", "Owasp Api Security for senior devs", "Owasp Api Security with Docker", "Owasp Api Security with Kubernetes", "Owasp Api Security in .NET 8", "Owasp Api Security in .NET 7", "Owasp Api Security in .NET 6", "Owasp Api Security Top", "Owasp Api Security Top guide", "Owasp Api Security Top tutorial", "Owasp Api Security Top best practices", "Owasp Api Security Top in .NET", "Owasp Api Security Top in C#", "Owasp Api Security Top for developers", "Owasp Api Security Top examples"],
  relatedServices: ["full-stack-development","technical-leadership"],
  relatedProjects: ["bat-inhouse-app","chubb-insurance-applications"],
  relatedArticleSlugs: ["securing-apis-dotnet","full-stack-net-angular-enterprise"],
  author: "Waqas Ahmad",
  content: `## Introduction

This guidance is relevant when the topic of this article applies to your system or design choices; it breaks down when constraints or context differ. I've applied it in real projects and refined the takeaways over time (as of 2026).

The **OWASP API Security Top 10** is a list of the most critical risks specific to REST, GraphQL, and other APIs—used worldwide as a checklist by developers and security teams. If you build or maintain .NET Web APIs, treat this list as your security baseline: each item is a real-world vulnerability that attackers exploit in production.

This article explains **what each of the ten risks is**, **why it matters**, and **how to fix it in .NET and Azure** with concrete code. We cover authorization (BOLA, function-level), authentication (JWT, OAuth2), data exposure (DTOs, mass assignment), rate limiting, SSRF, security headers, and more.

## Topics covered

- [Decision Context](#decision-context)
- [1. Broken Object Level Authorization (BOLA)](#1-broken-object-level-authorization-bola)
- [2. Broken Authentication](#2-broken-authentication)
- [3. Broken Object Property Level Authorization](#3-broken-object-property-level-authorization)
- [4. Unrestricted Resource Consumption](#4-unrestricted-resource-consumption)
- [5. Broken Function Level Authorization](#5-broken-function-level-authorization)
- [6. Unrestricted Access to Sensitive Business Flows](#6-unrestricted-access-to-sensitive-business-flows)
- [7. Server Side Request Forgery (SSRF)](#7-server-side-request-forgery-ssrf)
- [8. Security Misconfiguration](#8-security-misconfiguration)
- [9. Improper Inventory Management](#9-improper-inventory-management)
- [10. Unsafe Consumption of APIs](#10-unsafe-consumption-of-apis)
- [OWASP API Top 10 at a glance](#owasp-api-top-10-at-a-glance)
- [Enterprise best practices](#enterprise-best-practices)
- [Summary](#summary)
- [Position & Rationale](#position--rationale)
- [Trade-Offs & Failure Modes](#trade-offs--failure-modes)
- [What Most Guides Miss](#what-most-guides-miss)
- [Decision Framework](#decision-framework)
- [Key Takeaways](#key-takeaways)
- [When I Would Use This Again — and When I Wouldn't](#when-i-would-use-this-again--and-when-i-wouldnt)
- [Frequently Asked Questions](#frequently-asked-questions)

## Decision Context

- **System scale:** Any API (internal or public) that handles user data, business operations, or sensitive flows. Applies when you’re designing or hardening API security and want a structured checklist.
- **Team size:** Backend and security (or platform); someone must own auth, authorization, input validation, and rate limiting. Works when the team can map OWASP risks to real endpoints and fix them.
- **Time / budget pressure:** Fits when you’re building or refactoring APIs and can prioritise BOLA, auth, and config; breaks down when there’s no ownership for security—then at least fix BOLA and auth first.
- **Technical constraints:** .NET (ASP.NET Core); JWT, OAuth2; DTOs, rate limiting, security headers. Assumes you can enforce authorization per resource and per function.
- **Non-goals:** This article does not replace a full security programme; it focuses on the OWASP API Top 10 and how to address each in .NET.

## What is API security?

API security is the set of practices and controls that protect your API from unauthorized access, data theft, abuse, and misuse. Unlike traditional web apps (HTML forms and cookies), APIs are consumed by programs: mobile apps, SPAs, other services. That means **authentication** (who is calling?), **authorization** (what are they allowed to do?), **input validation**, **rate limiting**, and **secure configuration** all matter. The OWASP API Top 10 focuses on authorization and authentication failures, data exposure, misconfiguration, and inventory—the issues we see most often in production.

## 1. Broken Object Level Authorization (BOLA)

**What it is.** Broken Object Level Authorization (BOLA), also called **IDOR** (Insecure Direct Object Reference), means the API does not check that the caller is allowed to access the **specific** resource they requested. For example, a user changes the order ID in the URL from \`/orders/123\` to \`/orders/456\` and sees another user's order because the API only checked "is the user logged in?" and not "does this order belong to this user?"

**Why it matters.** BOLA is the most common API vulnerability. Attackers enumerate IDs (numbers, GUIDs) or guess predictable identifiers and access or modify other users' data. Every endpoint that takes an **object identifier** (order ID, profile ID, document ID) must verify that the current user (or client) is allowed to access that object.

**Mitigation in .NET.** After loading the resource, check ownership or permission before returning it. Use the authenticated user's ID (from JWT or session) and compare with the resource's owner or allowed list. Return \`404\` if not found and \`403 Forbid\` if found but not allowed (to avoid leaking existence).

\`\`\`csharp
// OrdersController.cs – authorise per resource (BOLA mitigation)
[HttpGet("{id}")]
public async Task<IActionResult> GetOrder(Guid id)
{
    var order = await _orderRepo.GetByIdAsync(id);
    if (order == null) return NotFound();
    if (order.UserId != _currentUser.Id) return Forbid();
    return Ok(_mapper.Map<OrderDto>(order));
}
\`\`\`

\`\`\`csharp
// Resource-based authorization with IAuthorizationHandler (alternative)
public class OrderOwnerRequirement : IAuthorizationRequirement { }
public class OrderOwnerHandler : AuthorizationHandler<OrderOwnerRequirement, Order>
{
    protected override Task HandleRequirementAsync(AuthorizationHandlerContext context,
        OrderOwnerRequirement requirement, Order resource)
    {
        var userId = context.User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
        if (userId != null && resource.UserId.ToString() == userId)
            context.Succeed(requirement);
        return Task.CompletedTask;
    }
}
\`\`\`

## 2. Broken Authentication

**What it is.** Broken Authentication means the API accepts weak or missing authentication: default credentials, API keys in URLs, missing or weak JWT validation, or session fixation. Attackers then impersonate users or gain access without valid credentials.

**Why it matters.** Once authentication is broken, authorization is meaningless. Attackers can act as any user, access tokens, or bypass login entirely.

**Mitigation in .NET.** Use **OAuth2 / OpenID Connect** for user sign-in; validate **JWT** (signature, issuer, audience, expiry). Never put API keys or secrets in URLs or client-side code. Use **HTTPS** only; store secrets in **Azure Key Vault** or environment variables. For machine-to-machine, use **client credentials** or **Managed Identity**; never share a single key across many clients.

\`\`\`csharp
// Program.cs – JWT validation
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        options.Authority = "https://your-tenant.b2clogin.com/...";
        options.Audience = "api://your-api";
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuer = true,
            ValidateAudience = true,
            ValidateLifetime = true,
            ClockSkew = TimeSpan.FromSeconds(30)
        };
    });
\`\`\`

## 3. Broken Object Property Level Authorization

**What it is.** This covers **excessive data exposure** (returning more fields than the client needs, including sensitive ones) and **mass assignment** (letting the client send any property and overwrite server state, e.g. \`isAdmin\` or \`balance\`). Both come from not defining a clear contract: what the API returns and what it accepts.

**Why it matters.** Over-exposure leaks internal fields, PII, or IDs. Mass assignment lets attackers elevate privileges or corrupt data by sending extra JSON properties.

**Mitigation in .NET.** Use **DTOs** and **projection** for responses: return only fields the client needs. For input, **bind only allowed fields** (input DTOs with explicit properties); ignore unknown properties; never bind directly to domain entities from the request body. Use \`[JsonIgnore]\` or allowlists.

\`\`\`csharp
// Response: DTO with only allowed fields (no internal IDs or PII)
public record OrderDto(Guid Id, string Status, decimal Total);

// Request: explicit input DTO – no IsAdmin, no Balance
public record CreateOrderRequest(string ProductId, int Quantity);
\`\`\`

\`\`\`csharp
// Controller – bind to DTO only; map to domain inside service
[HttpPost]
public async Task<IActionResult> Create([FromBody] CreateOrderRequest request)
{
    var order = await _orderService.CreateAsync(_currentUser.Id, request);
    return CreatedAtAction(nameof(GetOrder), new { id = order.Id }, order);
}
\`\`\`

## 4. Unrestricted Resource Consumption

**What it is.** The API does not limit how much clients can ask for: no rate limiting, no pagination caps, no cost limits. Attackers (or buggy clients) can send huge requests, enumerate millions of IDs, or trigger expensive operations and exhaust CPU, memory, or database.

**Why it matters.** Unrestricted consumption leads to **DoS**, **bill shock** (e.g. expensive downstream calls), and degraded service for everyone.

**Mitigation in .NET.** Add **rate limiting** (per IP, per user, per key) and return \`429 Too Many Requests\` with \`Retry-After\`. Cap **page size** and **max top** in list APIs. Use **Azure API Management** or middleware (e.g. \`AspNetCoreRateLimit\`) for rate limits. For expensive operations, use queues and quotas.

\`\`\`csharp
// Program.cs – rate limiting (e.g. AspNetCoreRateLimit)
builder.Services.AddInMemoryRateLimiting();
builder.Services.Configure<IpRateLimitOptions>(options =>
{
    options.GeneralRules = new List<RateLimitRule>
    {
        new() { Endpoint = "*", Limit = 100, Period = "1m" }
    };
});
\`\`\`

## 5. Broken Function Level Authorization

**What it is.** The API checks "is the user logged in?" but not "is this user allowed to call **this** function?" For example, a normal user calls an admin-only endpoint because the API only enforced authentication, not role or scope.

**Why it matters.** Attackers or curious users call privileged endpoints (delete user, export all data, change config) and escalate privileges.

**Mitigation in .NET.** Enforce **authorization per endpoint**: use \`[Authorize(Roles = "Admin")]\`, policy-based authorization, or resource-based checks. Validate **scopes** for OAuth2 (e.g. \`api.write\`). Never rely only on hiding URLs; always check on the server.

\`\`\`csharp
[Authorize(Roles = "Admin")]
[HttpDelete("{id}")]
public async Task<IActionResult> DeleteUser(Guid id) { ... }
\`\`\`

## 6. Unrestricted Access to Sensitive Business Flows

**What it is.** A sensitive flow (e.g. "place order", "transfer money", "send password reset") can be triggered without limit: no CAPTCHA, no step-up auth, no anti-automation. Bots or attackers automate abuse (bulk orders, credential stuffing, scraping).

**Why it matters.** Business logic abuse leads to fraud, spam, and unfair use. Sensitive flows need higher assurance and throttling.

**Mitigation in .NET.** Add **rate limits** and **CAPTCHA** (or similar) for sensitive flows; require **step-up authentication** (e.g. re-enter password) for high-value actions; log and alert on unusual patterns. Use **Azure Bot Protection** or custom heuristics.

\`\`\`csharp
// Example: step-up auth – require re-authentication for high-value action
[HttpPost("transfer")]
[Authorize]
public async Task<IActionResult> TransferMoney([FromBody] TransferRequest request)
{
    // Require recent auth (e.g. token issued within 5 minutes)
    var authTime = User.FindFirst("auth_time")?.Value;
    if (authTime == null || DateTimeOffset.FromUnixTimeSeconds(long.Parse(authTime)) < DateTimeOffset.UtcNow.AddMinutes(-5))
        return Unauthorized("Step-up authentication required");
    
    // Proceed with transfer...
    await _transferService.ExecuteAsync(request);
    return Ok();
}
\`\`\`

## 7. Server Side Request Forgery (SSRF)

**What it is.** The API takes a URL or host from the client and issues a server-side request to it. Attackers pass internal URLs (\`http://169.254.169.254/\`, \`http://localhost/admin\`) or open ports and read internal services or metadata.

**Why it matters.** SSRF can expose cloud metadata (e.g. IAM keys), internal APIs, or file systems. Never trust client-controlled URLs for outbound requests without strict allowlisting.

**Mitigation in .NET.** **Allowlist** allowed hosts or schemes; reject everything else. Do not use client input directly in \`HttpClient\` or \`WebRequest\`. Use **Azure Managed Identity** for internal calls so no secrets are in URLs. Validate and parse URLs; block private IP ranges and metadata endpoints.

\`\`\`csharp
// Validate URL before outbound request – allowlist scheme and host
var uri = new Uri(clientProvidedUrl);
if (uri.Scheme != "https" || !AllowedHosts.Contains(uri.Host))
    return BadRequest("URL not allowed");
\`\`\`

## 8. Security Misconfiguration

**What it is.** Default credentials, verbose errors (stack traces to client), missing security headers (HSTS, CSP, X-Content-Type-Options), debug mode in production, or permissive CORS. Small misconfigurations add up to big risk.

**Why it matters.** Attackers use default passwords, error messages that reveal paths or versions, and missing headers to probe and exploit.

**Mitigation in .NET.** Use **secure defaults**: turn off detailed errors in production; use custom error middleware. Add **security headers** (HSTS, X-Content-Type-Options, etc.). Restrict **CORS** to known origins. Store secrets in **Key Vault**; never in config files in source. Use **Azure App Service** or **AKS** hardening checklists.

\`\`\`csharp
// Add security headers
app.Use(async (context, next) =>
{
    context.Response.Headers.Append("Strict-Transport-Security", "max-age=31536000");
    context.Response.Headers.Append("X-Content-Type-Options", "nosniff");
    await next();
});
\`\`\`

## 9. Improper Inventory Management

**What it is.** No clear list of API endpoints, versions, or environments. Old or deprecated APIs stay exposed; dev/staging endpoints use production data; documentation is missing or wrong. Attackers and developers alike hit the wrong thing.

**Why it matters.** You cannot secure what you do not know exists. Shadow APIs, old versions, and undocumented endpoints become the attack surface.

**Mitigation in .NET.** **Document** all APIs (OpenAPI/Swagger); **version** APIs (URL or header) and retire old versions with a plan. Use **API Management** or gateway to expose only intended endpoints. Separate **environments** and do not point dev at production data. Track inventory in ADRs or a registry.

## 10. Unsafe Consumption of APIs

**What it is.** Your API calls **third-party or internal** APIs without validating responses, checking TLS, or handling errors safely. You trust the other service too much: you parse XML/JSON blindly, follow redirects, or leak data in logs. Attackers abuse the third party or man-in-the-middle to inject bad data or steal tokens.

**Why it matters.** Your API is only as strong as the weakest link. Unsafe consumption leads to **injection**, **data leakage**, and **downtime** when the other API changes or is compromised.

**Mitigation in .NET.** **Validate** and **sanitize** all data from external APIs; use **strong typing** and schema validation. Use **HTTPS** and **certificate validation**; do not disable SSL checks. **Limit** what you send (no sensitive data in URLs or logs). Use **timeouts** and **circuit breakers** (e.g. Polly) so a bad upstream does not take you down.

\`\`\`csharp
// HttpClient with timeout, circuit breaker, and response validation
services.AddHttpClient<IDownstreamApi, DownstreamApi>(client =>
{
    client.Timeout = TimeSpan.FromSeconds(10);
    client.DefaultRequestHeaders.Add("Accept", "application/json");
})
.AddPolicyHandler(Policy<HttpResponseMessage>
    .Handle<HttpRequestException>()
    .OrTransientHttpStatusCode()
    .WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromMilliseconds(200 * retryAttempt)))
.AddPolicyHandler(Policy<HttpResponseMessage>
    .Handle<HttpRequestException>()
    .CircuitBreakerAsync(5, TimeSpan.FromSeconds(30)));
\`\`\`

\`\`\`csharp
// Validate response from external API – never trust blindly
public async Task<OrderDto?> GetExternalOrderAsync(string orderId)
{
    var response = await _httpClient.GetAsync($"orders/{orderId}");
    response.EnsureSuccessStatusCode();
    
    var order = await response.Content.ReadFromJsonAsync<ExternalOrderDto>();
    if (order == null || string.IsNullOrEmpty(order.Id))
        throw new InvalidOperationException("Invalid response from external API");
    
    // Map to internal DTO – do not expose external structure
    return new OrderDto(order.Id, order.Status, order.Total);
}
\`\`\`

## OWASP API Top 10 at a glance

| # | Risk | What it is | Key mitigation |
|---|------|-----------|----------------|
| 1 | **BOLA** | API does not check if user owns the resource | Authorise per resource (check ownership) |
| 2 | **Broken Authentication** | Weak or missing auth (JWT, keys) | Validate JWT (issuer, audience, signature); use OAuth2 |
| 3 | **Broken Object Property Auth** | Over-exposure or mass assignment | Use DTOs; bind only allowed fields |
| 4 | **Unrestricted Resource Consumption** | No rate limits or pagination caps | Rate limiting (429); cap page size |
| 5 | **Broken Function Level Auth** | User calls admin endpoints | \`[Authorize(Roles = "Admin")]\`; check scopes |
| 6 | **Sensitive Business Flows** | No CAPTCHA or step-up for sensitive ops | Rate limit + step-up auth + CAPTCHA |
| 7 | **SSRF** | Server requests client-controlled URL | Allowlist hosts; block private IPs |
| 8 | **Security Misconfiguration** | Verbose errors, missing headers | Security headers; no stack traces in prod |
| 9 | **Improper Inventory** | Shadow/old APIs exposed | OpenAPI docs; version and retire |
| 10 | **Unsafe Consumption** | Trusting external API responses | Validate responses; HTTPS; timeouts |

## Enterprise best practices

**1. Treat OWASP API Top 10 as a checklist in design and code review.** For every new endpoint, ask: does it check ownership (BOLA)? Does it require the right role/scope (function-level)? Does it limit input size and rate? Add security stories to your backlog.

**2. Use middleware and policies for consistency.** Authorization policies (\`[Authorize(Policy = "...")]\`), rate-limiting middleware, and security headers middleware mean you do not repeat the same checks in every controller. One place to update, one place to audit.

**3. Centralise JWT validation and secrets.** Use a single \`AddAuthentication().AddJwtBearer()\` configuration with \`Authority\` and \`Audience\`. Store secrets in **Azure Key Vault** or a secrets manager; reference them by name, not in code.

**4. Log and alert on security events.** Log failed auth, failed authorization (403), rate-limit hits (429), and suspicious patterns (enumeration, repeated bad input). Send alerts to your SIEM or Azure Monitor so you catch attacks early.

**5. Run penetration tests and threat modelling.** Automate security scans (e.g. OWASP ZAP, SonarQube SAST) in CI. Do threat modelling for new features: draw the data flow, identify trust boundaries, and map to OWASP risks. Fix findings before shipping.

**6. Version and document.** Use **OpenAPI/Swagger** for every API; version via URL or header; retire old versions with a deprecation period. Improper inventory is real: if you do not know what is exposed, you cannot secure it.

## Summary

The OWASP API Security Top 10 gives you a concrete checklist: **BOLA**, **Broken Authentication**, **Object Property Authorization**, **Resource Consumption**, **Function Level Authorization**, **Sensitive Business Flows**, **SSRF**, **Security Misconfiguration**, **Inventory Management**, and **Unsafe Consumption**. For each, enforce **authorization per resource and per function**, **validate input and output**, **harden configuration**, and **document and version** your API. In .NET, use **JWT validation**, **DTOs**, **rate limiting**, **security headers**, and **Key Vault**; then iterate with threat modelling and penetration tests. Use the FAQs below as a quick reference.

## Position & Rationale

I treat **BOLA** as the first fix on every API: every endpoint that takes an object ID must check that the caller is allowed to access that object (e.g. order.UserId == currentUser.Id). I enforce **function-level authorization** so that “delete user” or “export data” is not callable by everyone. I use **DTOs** and avoid returning entities directly so we don’t leak properties (mass assignment, object property authorization). I add **rate limiting** and **input validation** so we don’t get DoS or injection. I avoid trusting the client for authorization (e.g. “role: admin” in the request body); the server must derive identity and permissions from the token or session. I don’t skip the “boring” items: security headers, inventory (OpenAPI, versioning), and logging security events.

## Trade-Offs & Failure Modes

**Strict authorization** adds checks on every request; you gain protection from BOLA and function-level abuse. **DTOs** add mapping code; you gain control over what is exposed. **Rate limiting** can block legitimate bursts if misconfigured; tune by endpoint and client. Failure modes: checking “is authenticated?” but not “can this user access this resource?” (BOLA); exposing internal IDs or fields (object property); no rate limit (resource consumption); trusting client-supplied URLs in server-side requests (SSRF).

## What Most Guides Miss

Most guides list the Top 10 but don’t stress that **BOLA is the most common**—fix “does this user own this resource?” first on every endpoint that takes an ID. Another gap: **403 vs 404**—return 404 when the resource doesn’t exist or the user isn’t allowed (to avoid leaking existence); some prefer 403 when the user is not allowed but the resource exists; document your policy. **Unsafe consumption** (calling downstream APIs without validating responses or handling errors) is underplayed; your API is only as secure as the weakest service it calls.

## Decision Framework

- **For every endpoint with an object ID** → After load, check ownership or permission; return 404 or 403 as appropriate.
- **For every sensitive operation** (delete, export, admin) → Enforce function-level authorization (role, scope, or policy).
- **For request/response** → Use DTOs; validate input; don’t expose internal fields or accept mass assignment.
- **For configuration** → Security headers, HTTPS, secrets in Key Vault; no default credentials or debug in production.
- **For inventory** → OpenAPI for every API; version and deprecate; log and alert on auth failures and abuse.

## Key Takeaways

- **BOLA** first: authorise every request against the resource owner; then function-level auth for sensitive operations.
- Use **DTOs** and validate input; rate limit and harden config.
- **403 vs 404**: decide and document; avoid leaking existence.
- **Inventory** (OpenAPI, versioning) and **logging** security events so you can detect and respond.

## When I Would Use This Again — and When I Wouldn't

I’d use the **OWASP API Top 10** again as a checklist for every new or refactored API—BOLA, auth, DTOs, rate limiting, config, inventory. I’d fix BOLA and broken authentication first; then object property, function-level, and the rest. I wouldn’t ship an API that takes resource IDs without ownership checks. I also wouldn’t treat the list as “one and done”; threat modelling and pen tests should revisit these risks as the API evolves.

## Frequently Asked Questions

### What is OWASP?

**OWASP** (Open Web Application Security Project) is a nonprofit that publishes security standards and risk lists, including the API Security Top 10 and Web Application Top 10. Use their lists as checklists for design and code review.

### What is BOLA?

**Broken Object Level Authorization (BOLA)**, also known as **IDOR**, means the API does not check that the caller is allowed to access the specific resource (e.g. another user's order). Mitigate by authorising every request against the resource owner: compare \`order.UserId\` with \`_currentUser.Id\`.

### What is the difference between BOLA and Broken Function Level Authorization?

**BOLA** is about **which object** (e.g. order 123 vs 456) the user can access. **Broken Function Level Authorization** is about **which operation** (e.g. delete user, export data) the user can call. Both require server-side checks.

### How do I validate JWT in .NET?

Use \`AddAuthentication(JwtBearerDefaults.AuthenticationScheme).AddJwtBearer(...)\` with \`Authority\`, \`Audience\`, and \`TokenValidationParameters\` (\`ValidateIssuer\`, \`ValidateAudience\`, \`ValidateLifetime\`). Never skip signature validation.

### Should I use API keys for user-facing APIs?

No. Use **OAuth2/OpenID Connect** and **JWT** for user authentication. API keys are hard to rotate per user and often leak. Use keys only for machine-to-machine or internal services, and store them in **Key Vault** or a secrets manager.

### How do I prevent mass assignment in .NET?

Use explicit **input DTOs** with only the properties you allow. Do not bind request body directly to domain entities. Ignore unknown JSON properties; use \`[JsonIgnore]\` on sensitive entity properties.

### What is rate limiting and why do I need it?

Rate limiting caps how many requests a client can send in a time window. It prevents abuse, DoS, and cost blowouts. Return \`429 Too Many Requests\` and \`Retry-After\` when the limit is exceeded. Use middleware (e.g. \`AspNetCoreRateLimit\`) or **Azure API Management**.

### What is SSRF and how do I prevent it?

**Server Side Request Forgery (SSRF)** is when the server makes a request to a URL supplied by the client, often to internal or metadata endpoints. Prevent by **allowlisting** hosts and schemes; block private IPs and metadata URLs (e.g. \`169.254.169.254\`); do not trust client input for outbound URLs.

### What security headers should I add?

At least \`Strict-Transport-Security\` (HSTS), \`X-Content-Type-Options: nosniff\`, and optionally \`Content-Security-Policy\`, \`X-Frame-Options\`. Add via middleware or web server config.

### How do I document and version my API?

Use **OpenAPI (Swagger)** for documentation. Version via URL path (\`/api/v1/orders\`) or header (\`Api-Version: 1\`). Retire old versions with a deprecation period and communicate to clients.

### What is "unsafe consumption of APIs"?

When your API calls another API and trusts its response without validation, or sends sensitive data in URLs or logs, or ignores TLS or timeouts. Mitigate by validating responses, using **HTTPS**, and applying **timeouts** and **circuit breakers** (e.g. Polly).

### Should I return 403 or 404 when the user is not allowed to access a resource?

Return \`404\` when the resource does not exist (to avoid leaking existence). Return \`403 Forbid\` when the resource exists but the user is not allowed—use this only when you do not leak information (e.g. admin views). Often \`404\` is safer for BOLA to avoid enumeration.

### How do I enforce authorization per endpoint in .NET?

Use \`[Authorize(Roles = "Admin")]\`, \`[Authorize(Policy = "RequireScope")]\`, or **resource-based authorization** (\`IAuthorizationHandler\` with the resource). Always authorize on the server; never rely on hiding URLs.

### What is the OWASP API Top 10 used for?

As a **checklist** for designing and reviewing APIs: ensure you have addressed each of the ten risks (authorization, authentication, data exposure, rate limiting, configuration, inventory, SSRF, unsafe consumption). Use it in **threat modelling** and **security training**.

### How do I implement resource-based authorization in .NET?

Create a custom \`IAuthorizationRequirement\` (e.g. \`OrderOwnerRequirement\`) and an \`AuthorizationHandler<TRequirement, TResource>\` that checks ownership. Register the handler in DI, then call \`IAuthorizationService.AuthorizeAsync(user, resource, requirement)\` in your controller before returning the resource.

### What tools can I use to automate OWASP checks?

Use **OWASP ZAP** (dynamic scanning), **SonarQube** or **Semgrep** (SAST), and **Snyk** or **Dependabot** (dependency scanning). Run these in CI so security issues are caught before deployment. Combine with manual penetration testing for full coverage.`,
  faqs: [
  {
    "question": "What is OWASP?",
    "answer": "OWASP (Open Web Application Security Project) is a nonprofit that publishes security standards and risk lists, including the API Security Top 10 and Web Application Top 10. Use their lists as checklists for design and code review."
  },
  {
    "question": "What is BOLA?",
    "answer": "Broken Object Level Authorization (BOLA), also known as IDOR, means the API does not check that the caller is allowed to access the specific resource (e.g. another user's order). Mitigate by authorising every request against the resource owner or permissions."
  },
  {
    "question": "What is the difference between BOLA and Broken Function Level Authorization?",
    "answer": "BOLA is about which object (e.g. order 123 vs 456) the user can access. Broken Function Level Authorization is about which operation (e.g. delete user, export data) the user can call. Both require server-side checks."
  },
  {
    "question": "How do I validate JWT in .NET?",
    "answer": "Use AddAuthentication(JwtBearerDefaults.AuthenticationScheme).AddJwtBearer(...) with Authority, Audience, and TokenValidationParameters (ValidateIssuer, ValidateAudience, ValidateLifetime). Never skip signature validation."
  },
  {
    "question": "Should I use API keys for user-facing APIs?",
    "answer": "No. Use OAuth2/OpenID Connect and JWT for user authentication. API keys are hard to rotate per user and often leak. Use keys only for machine-to-machine or internal services."
  },
  {
    "question": "How do I prevent mass assignment in .NET?",
    "answer": "Use explicit input DTOs with only the properties you allow. Do not bind request body directly to domain entities. Ignore unknown JSON properties."
  },
  {
    "question": "What is rate limiting and why do I need it?",
    "answer": "Rate limiting caps how many requests a client can send in a time window. It prevents abuse, DoS, and cost blowouts. Return 429 Too Many Requests and Retry-After when the limit is exceeded."
  },
  {
    "question": "What is SSRF and how do I prevent it?",
    "answer": "Server Side Request Forgery is when the server makes a request to a URL supplied by the client, often to internal or metadata endpoints. Prevent by allowlisting hosts and schemes; block private IPs and metadata URLs."
  },
  {
    "question": "What security headers should I add?",
    "answer": "At least Strict-Transport-Security (HSTS), X-Content-Type-Options (nosniff), and optionally Content-Security-Policy, X-Frame-Options."
  },
  {
    "question": "How do I document and version my API?",
    "answer": "Use OpenAPI (Swagger) for documentation. Version via URL path (/api/v1/orders) or header (Api-Version: 1). Retire old versions with a deprecation period."
  },
  {
    "question": "What is unsafe consumption of APIs?",
    "answer": "When your API calls another API and trusts its response without validation, or sends sensitive data in URLs or logs, or ignores TLS or timeouts. Mitigate by validating responses, using HTTPS, and applying timeouts and circuit breakers."
  },
  {
    "question": "Should I return 403 or 404 when the user is not allowed to access a resource?",
    "answer": "Return 404 when the resource does not exist (so you do not leak existence). Return 403 Forbid when the resource exists but the user is not allowed. Often 404 is safer for BOLA to avoid enumeration."
  },
  {
    "question": "How do I enforce authorization per endpoint in .NET?",
    "answer": "Use [Authorize(Roles = \"Admin\")], [Authorize(Policy = \"RequireScope\")], or resource-based authorization (IAuthorizationHandler with the resource). Always authorize on the server."
  },
  {
    "question": "What is the OWASP API Top 10 used for?",
    "answer": "As a checklist for designing and reviewing APIs: ensure you have addressed each of the ten risks. Use it in threat modelling and security training."
  },
  {
    "question": "How do I implement resource-based authorization in .NET?",
    "answer": "Create a custom IAuthorizationRequirement (e.g. OrderOwnerRequirement) and an AuthorizationHandler that checks ownership. Register the handler in DI, then call IAuthorizationService.AuthorizeAsync(user, resource, requirement) in your controller."
  },
  {
    "question": "What tools can I use to automate OWASP checks?",
    "answer": "Use OWASP ZAP (dynamic scanning), SonarQube or Semgrep (SAST), and Snyk or Dependabot (dependency scanning). Run these in CI so security issues are caught before deployment."
  }
]
}
