/**
 * Blog article: open-telemetry-distributed-tracing-dotnet
 * Auto-generated by scripts/split-blog-articles.js. Do not edit the content here by hand if you run the split script again.
 */

export default {
  slug: "open-telemetry-distributed-tracing-dotnet",
  title: "OpenTelemetry and Distributed Tracing in .NET",
  excerpt: "Adding OpenTelemetry to .NET apps: traces, metrics, and export to Azure Monitor or Jaeger. W3C Trace Context and correlation.",
  date: "2025-06-19",
  topic: "Cloud",
  keywords: ["OpenTelemetry and Distributed Tracing in .NET", "Open Telemetry Distributed Tracing Dotnet", "Open Telemetry Distributed Tracing Dotnet best practices", "how to open telemetry distributed tracing dotnet", "open telemetry distributed tracing dotnet in .NET", "open telemetry distributed tracing dotnet guide", "open telemetry distributed tracing dotnet for enterprise", "open telemetry distributed tracing dotnet patterns", "when to use open telemetry distributed tracing dotnet", "open telemetry distributed tracing dotnet tutorial", "open telemetry distributed tracing dotnet examples", "open telemetry distributed tracing dotnet in C#", "open telemetry distributed tracing dotnet overview", "open telemetry distributed tracing dotnet implementation", "understanding open telemetry distributed tracing dotnet", "open telemetry distributed tracing dotnet for developers", "open telemetry distributed tracing dotnet checklist", "open telemetry distributed tracing dotnet tips", "open telemetry distributed tracing dotnet deep dive", "open telemetry distributed tracing dotnet comparison", "open telemetry distributed tracing dotnet vs alternatives", "open telemetry distributed tracing dotnet .NET Core", "open telemetry distributed tracing dotnet Azure", "open telemetry distributed tracing dotnet explained", "open telemetry distributed tracing dotnet when to use", "open telemetry distributed tracing dotnet enterprise", "open telemetry distributed tracing dotnet .NET", "what is open telemetry distributed tracing dotnet", "open telemetry distributed tracing dotnet summary", "open telemetry distributed tracing dotnet introduction", "open telemetry distributed tracing dotnet fundamentals", "open telemetry distributed tracing dotnet step by step", "open telemetry distributed tracing dotnet complete guide", "open telemetry distributed tracing dotnet for beginners", "open telemetry distributed tracing dotnet advanced", "open telemetry distributed tracing dotnet production", "open telemetry distributed tracing dotnet real world", "open telemetry distributed tracing dotnet example code", "open telemetry distributed tracing dotnet C# example", "open telemetry distributed tracing dotnet .NET example", "learn open telemetry distributed tracing dotnet", "open telemetry distributed tracing dotnet learn", "open telemetry distributed tracing dotnet reference", "open telemetry distributed tracing dotnet cheat sheet", "open telemetry distributed tracing dotnet pitfalls", "open telemetry distributed tracing dotnet common mistakes", "open telemetry distributed tracing dotnet performance", "open telemetry distributed tracing dotnet optimization", "open telemetry distributed tracing dotnet security", "open telemetry distributed tracing dotnet testing", "open telemetry distributed tracing dotnet unit test", "open telemetry distributed tracing dotnet integration", "open telemetry distributed tracing dotnet migration", "open telemetry distributed tracing dotnet from scratch", "open telemetry distributed tracing dotnet 2024", "open telemetry distributed tracing dotnet 2025", "best open telemetry distributed tracing dotnet", "open telemetry distributed tracing dotnet best", "pro open telemetry distributed tracing dotnet", "open telemetry distributed tracing dotnet expert", "open telemetry distributed tracing dotnet consultant", "open telemetry distributed tracing dotnet services", "open telemetry distributed tracing dotnet course", "open telemetry distributed tracing dotnet workshop", "open telemetry distributed tracing dotnet webinar", "open telemetry distributed tracing dotnet blog", "open telemetry distributed tracing dotnet article", "open telemetry distributed tracing dotnet post", "why open telemetry distributed tracing dotnet", "when open telemetry distributed tracing dotnet", "where open telemetry distributed tracing dotnet", "open telemetry distributed tracing dotnet in .NET 6", "open telemetry distributed tracing dotnet in .NET 7", "open telemetry distributed tracing dotnet in .NET 8", "open telemetry distributed tracing dotnet for C#", "open telemetry distributed tracing dotnet for Angular", "open telemetry distributed tracing dotnet for Vue", "open telemetry distributed tracing dotnet for React", "open telemetry distributed tracing dotnet for Azure", "open telemetry distributed tracing dotnet for microservices", "open telemetry distributed tracing dotnet for API", "open telemetry distributed tracing dotnet for database", "open telemetry distributed tracing dotnet for testing", "open telemetry distributed tracing dotnet for DevOps", "open telemetry distributed tracing dotnet for senior developers", "open telemetry distributed tracing dotnet for team", "open telemetry distributed tracing dotnet for production", "open telemetry distributed tracing dotnet for scale", "open telemetry distributed tracing dotnet for refactoring", "open telemetry distributed tracing dotnet for enterprise applications", "open telemetry distributed tracing dotnet for startup", "open telemetry distributed tracing dotnet in 2024", "open telemetry distributed tracing dotnet in 2025", "open telemetry distributed tracing dotnet in 2026", "open telemetry distributed tracing dotnet code sample", "open telemetry distributed tracing dotnet code example", "open telemetry distributed tracing dotnet sample code", "open telemetry distributed tracing dotnet full example", "open telemetry distributed tracing dotnet working example", "open telemetry distributed tracing dotnet practical open telemetry distributed tracing dotnet", "open telemetry distributed tracing dotnet real world example", "open telemetry distributed tracing dotnet use case", "open telemetry distributed tracing dotnet use cases", "open telemetry distributed tracing dotnet scenario", "open telemetry distributed tracing dotnet scenarios", "open telemetry distributed tracing dotnet pattern", "open telemetry distributed tracing dotnet approach", "open telemetry distributed tracing dotnet approaches", "open telemetry distributed tracing dotnet strategy", "open telemetry distributed tracing dotnet strategies", "open telemetry distributed tracing dotnet technique", "open telemetry distributed tracing dotnet techniques", "open telemetry distributed tracing dotnet method", "open telemetry distributed tracing dotnet methods", "open telemetry distributed tracing dotnet solution", "open telemetry distributed tracing dotnet solutions", "open telemetry distributed tracing dotnet implementation guide", "open telemetry distributed tracing dotnet getting started", "open telemetry distributed tracing dotnet quick start", "open telemetry distributed tracing dotnet overview guide", "open telemetry distributed tracing dotnet comprehensive guide", "open telemetry distributed tracing dotnet detailed guide", "open telemetry distributed tracing dotnet practical guide", "open telemetry distributed tracing dotnet developer guide", "open telemetry distributed tracing dotnet engineer guide", "open telemetry distributed tracing dotnet architect guide", "open telemetry distributed tracing dotnet for architects", "open telemetry distributed tracing dotnet for backend", "open telemetry distributed tracing dotnet for tech leads", "open telemetry distributed tracing dotnet for senior devs", "benefits of open telemetry distributed tracing dotnet", "advantages of open telemetry distributed tracing dotnet", "alternatives to open telemetry distributed tracing dotnet", "compared to open telemetry distributed tracing dotnet", "intro to open telemetry distributed tracing dotnet", "basics of open telemetry distributed tracing dotnet", "open telemetry distributed tracing dotnet tips and tricks", "open telemetry distributed tracing dotnet production-ready", "open telemetry distributed tracing dotnet enterprise-grade", "open telemetry distributed tracing dotnet with Docker", "open telemetry distributed tracing dotnet with Kubernetes", "open telemetry distributed tracing dotnet in ASP.NET Core", "open telemetry distributed tracing dotnet with Entity Framework", "open telemetry distributed tracing dotnet with EF Core", "open telemetry distributed tracing dotnet modern", "open telemetry distributed tracing dotnet updated", "open telemetry distributed tracing dotnet latest", "open telemetry distributed tracing dotnet walkthrough", "open telemetry distributed tracing dotnet hands-on", "open telemetry distributed tracing dotnet practical examples", "open telemetry distributed tracing dotnet real-world examples", "open telemetry distributed tracing dotnet common pitfalls", "open telemetry distributed tracing dotnet gotchas", "open telemetry distributed tracing dotnet FAQ", "open telemetry distributed tracing dotnet FAQs", "open telemetry distributed tracing dotnet Q&A", "open telemetry distributed tracing dotnet interview questions", "open telemetry distributed tracing dotnet interview", "open telemetry distributed tracing dotnet certification", "open telemetry distributed tracing dotnet training", "open telemetry distributed tracing dotnet video", "open telemetry distributed tracing dotnet series", "open telemetry distributed tracing dotnet part 1", "open telemetry distributed tracing dotnet core concepts", "open telemetry distributed tracing dotnet key concepts", "open telemetry distributed tracing dotnet recap", "open telemetry distributed tracing dotnet takeaways", "open telemetry distributed tracing dotnet conclusion", "open telemetry distributed tracing dotnet next steps", "open telemetry distributed tracing dotnet further reading", "open telemetry distributed tracing dotnet resources", "open telemetry distributed tracing dotnet tools", "open telemetry distributed tracing dotnet libraries", "open telemetry distributed tracing dotnet frameworks", "open telemetry distributed tracing dotnet NuGet", "open telemetry distributed tracing dotnet package", "open telemetry distributed tracing dotnet GitHub", "open telemetry distributed tracing dotnet open source", "open telemetry distributed tracing dotnet community", "open telemetry distributed tracing dotnet Microsoft docs", "open telemetry distributed tracing dotnet documentation", "open telemetry distributed tracing dotnet official guide", "open telemetry distributed tracing dotnet official tutorial", "open telemetry distributed tracing with .NET Core", "open telemetry distributed tracing dotnet ASP.NET Core", "Open", "Open guide", "Open tutorial", "Open best practices", "Open in .NET", "Open in C#", "Open for developers", "Open examples", "Open patterns", "Open overview", "Open introduction", "Open deep dive", "Open explained", "Open how to", "Open what is", "Open when to use", "Open for enterprise", "Open .NET Core", "Open Azure", "Open C#", "Open with .NET", "Open with C#", "Open with Azure", "Open with Angular", "Open with Vue", "Open with React", "Open with Entity Framework", "Open with SQL Server", "Open step by step", "Open complete guide", "Open from scratch", "Open 2024", "Open 2025", "Open 2026", "Open code example", "Open sample code", "Open implementation", "Open real world", "Open production", "Open for beginners", "Open advanced", "Open for architects", "Open for backend", "Open for API", "Open in ASP.NET Core", "Open with EF Core", "Open tutorial 2024", "Open guide 2025", "Open best practices 2024", "Open C# examples", "Open .NET examples", "Open implementation guide", "Open how to implement", "Open benefits", "Open advantages", "Open pitfalls", "Open alternatives", "Open compared", "Open intro", "Open basics", "Open tips and tricks", "Open production-ready", "Open enterprise-grade", "Open maintainable", "Open testable", "Open refactoring", "Open modern", "Open updated", "Open latest", "Open for tech leads", "Open for senior devs", "Open with Docker", "Open with Kubernetes", "Open in .NET 8", "Open in .NET 7", "Open in .NET 6", "Open Telemetry", "Open Telemetry guide", "Open Telemetry tutorial", "Open Telemetry best practices", "Open Telemetry in .NET", "Open Telemetry in C#", "Open Telemetry for developers", "Open Telemetry examples", "Open Telemetry patterns", "Open Telemetry overview", "Open Telemetry introduction", "Open Telemetry deep dive", "Open Telemetry explained", "Open Telemetry how to", "Open Telemetry what is", "Open Telemetry when to use", "Open Telemetry for enterprise", "Open Telemetry .NET Core", "Open Telemetry Azure", "Open Telemetry C#", "Open Telemetry with .NET", "Open Telemetry with C#", "Open Telemetry with Azure", "Open Telemetry with Angular", "Open Telemetry with Vue", "Open Telemetry with React", "Open Telemetry with Entity Framework", "Open Telemetry with SQL Server", "Open Telemetry step by step", "Open Telemetry complete guide", "Open Telemetry from scratch", "Open Telemetry 2024", "Open Telemetry 2025", "Open Telemetry 2026", "Open Telemetry code example", "Open Telemetry sample code", "Open Telemetry implementation", "Open Telemetry real world", "Open Telemetry production", "Open Telemetry for beginners", "Open Telemetry advanced", "Open Telemetry for architects", "Open Telemetry for backend", "Open Telemetry for API", "Open Telemetry in ASP.NET Core", "Open Telemetry with EF Core", "Open Telemetry tutorial 2024", "Open Telemetry guide 2025", "Open Telemetry best practices 2024", "Open Telemetry C# examples", "Open Telemetry .NET examples", "Open Telemetry implementation guide", "Open Telemetry how to implement", "Open Telemetry benefits", "Open Telemetry advantages", "Open Telemetry pitfalls", "Open Telemetry alternatives", "Open Telemetry compared", "Open Telemetry intro", "Open Telemetry basics", "Open Telemetry tips and tricks", "Open Telemetry production-ready", "Open Telemetry enterprise-grade", "Open Telemetry maintainable", "Open Telemetry testable", "Open Telemetry refactoring", "Open Telemetry modern", "Open Telemetry updated", "Open Telemetry latest", "Open Telemetry for tech leads", "Open Telemetry for senior devs", "Open Telemetry with Docker", "Open Telemetry with Kubernetes", "Open Telemetry in .NET 8", "Open Telemetry in .NET 7", "Open Telemetry in .NET 6", "Open Telemetry Distributed", "Open Telemetry Distributed guide", "Open Telemetry Distributed tutorial", "Open Telemetry Distributed best practices", "Open Telemetry Distributed in .NET", "Open Telemetry Distributed in C#", "Open Telemetry Distributed for developers", "Open Telemetry Distributed examples", "Open Telemetry Distributed patterns", "Open Telemetry Distributed overview", "Open Telemetry Distributed introduction", "Open Telemetry Distributed deep dive", "Open Telemetry Distributed explained", "Open Telemetry Distributed how to", "Open Telemetry Distributed what is", "Open Telemetry Distributed when to use", "Open Telemetry Distributed for enterprise", "Open Telemetry Distributed .NET Core", "Open Telemetry Distributed Azure", "Open Telemetry Distributed C#", "Open Telemetry Distributed with .NET", "Open Telemetry Distributed with C#", "Open Telemetry Distributed with Azure", "Open Telemetry Distributed with Angular", "Open Telemetry Distributed with Vue", "Open Telemetry Distributed with React", "Open Telemetry Distributed with Entity Framework", "Open Telemetry Distributed with SQL Server", "Open Telemetry Distributed step by step", "Open Telemetry Distributed complete guide", "Open Telemetry Distributed from scratch", "Open Telemetry Distributed 2024", "Open Telemetry Distributed 2025", "Open Telemetry Distributed 2026", "Open Telemetry Distributed code example", "Open Telemetry Distributed sample code", "Open Telemetry Distributed implementation", "Open Telemetry Distributed real world", "Open Telemetry Distributed production", "Open Telemetry Distributed for beginners", "Open Telemetry Distributed advanced", "Open Telemetry Distributed for architects", "Open Telemetry Distributed for backend", "Open Telemetry Distributed for API", "Open Telemetry Distributed in ASP.NET Core", "Open Telemetry Distributed with EF Core", "Open Telemetry Distributed tutorial 2024", "Open Telemetry Distributed guide 2025", "Open Telemetry Distributed best practices 2024", "Open Telemetry Distributed C# examples", "Open Telemetry Distributed .NET examples", "Open Telemetry Distributed implementation guide", "Open Telemetry Distributed how to implement", "Open Telemetry Distributed benefits", "Open Telemetry Distributed advantages", "Open Telemetry Distributed pitfalls", "Open Telemetry Distributed alternatives", "Open Telemetry Distributed compared", "Open Telemetry Distributed intro", "Open Telemetry Distributed basics", "Open Telemetry Distributed tips and tricks", "Open Telemetry Distributed production-ready", "Open Telemetry Distributed enterprise-grade", "Open Telemetry Distributed maintainable", "Open Telemetry Distributed testable", "Open Telemetry Distributed refactoring", "Open Telemetry Distributed modern", "Open Telemetry Distributed updated", "Open Telemetry Distributed latest", "Open Telemetry Distributed for tech leads", "Open Telemetry Distributed for senior devs", "Open Telemetry Distributed with Docker", "Open Telemetry Distributed with Kubernetes", "Open Telemetry Distributed in .NET 8", "Open Telemetry Distributed in .NET 7", "Open Telemetry Distributed in .NET 6", "Open Telemetry Distributed Tracing", "Open Telemetry Distributed Tracing guide", "Open Telemetry Distributed Tracing tutorial", "Open Telemetry Distributed Tracing best practices", "Open Telemetry Distributed Tracing in .NET", "Open Telemetry Distributed Tracing in C#", "Open Telemetry Distributed Tracing for developers", "Open Telemetry Distributed Tracing examples", "Open Telemetry Distributed Tracing patterns", "Open Telemetry Distributed Tracing overview", "Open Telemetry Distributed Tracing introduction", "Open Telemetry Distributed Tracing deep dive", "Open Telemetry Distributed Tracing explained", "Open Telemetry Distributed Tracing how to", "Open Telemetry Distributed Tracing what is", "Open Telemetry Distributed Tracing when to use", "Open Telemetry Distributed Tracing for enterprise", "Open Telemetry Distributed Tracing .NET Core", "Open Telemetry Distributed Tracing Azure", "Open Telemetry Distributed Tracing C#", "Open Telemetry Distributed Tracing with .NET", "Open Telemetry Distributed Tracing with C#", "Open Telemetry Distributed Tracing with Azure", "Open Telemetry Distributed Tracing with Angular", "Open Telemetry Distributed Tracing with Vue", "Open Telemetry Distributed Tracing with React", "Open Telemetry Distributed Tracing with Entity Framework", "Open Telemetry Distributed Tracing with SQL Server", "Open Telemetry Distributed Tracing step by step", "Open Telemetry Distributed Tracing complete guide", "Open Telemetry Distributed Tracing from scratch", "Open Telemetry Distributed Tracing 2024", "Open Telemetry Distributed Tracing 2025", "Open Telemetry Distributed Tracing 2026", "Open Telemetry Distributed Tracing code example", "Open Telemetry Distributed Tracing sample code", "Open Telemetry Distributed Tracing implementation", "Open Telemetry Distributed Tracing real world", "Open Telemetry Distributed Tracing production", "Open Telemetry Distributed Tracing for beginners", "Open Telemetry Distributed Tracing advanced", "Open Telemetry Distributed Tracing for architects", "Open Telemetry Distributed Tracing for backend", "Open Telemetry Distributed Tracing for API", "Open Telemetry Distributed Tracing in ASP.NET Core", "Open Telemetry Distributed Tracing with EF Core", "Open Telemetry Distributed Tracing tutorial 2024", "Open Telemetry Distributed Tracing guide 2025", "Open Telemetry Distributed Tracing best practices 2024", "Open Telemetry Distributed Tracing C# examples", "Open Telemetry Distributed Tracing .NET examples", "Open Telemetry Distributed Tracing implementation guide", "Open Telemetry Distributed Tracing how to implement", "Open Telemetry Distributed Tracing benefits", "Open Telemetry Distributed Tracing advantages", "Open Telemetry Distributed Tracing pitfalls", "Open Telemetry Distributed Tracing alternatives", "Open Telemetry Distributed Tracing compared", "Open Telemetry Distributed Tracing intro", "Open Telemetry Distributed Tracing basics", "Open Telemetry Distributed Tracing tips and tricks", "Open Telemetry Distributed Tracing production-ready", "Open Telemetry Distributed Tracing enterprise-grade", "Open Telemetry Distributed Tracing maintainable", "Open Telemetry Distributed Tracing testable", "Open Telemetry Distributed Tracing refactoring", "Open Telemetry Distributed Tracing modern", "Open Telemetry Distributed Tracing updated", "Open Telemetry Distributed Tracing latest", "Open Telemetry Distributed Tracing for tech leads", "Open Telemetry Distributed Tracing for senior devs", "Open Telemetry Distributed Tracing with Docker", "Open Telemetry Distributed Tracing with Kubernetes", "Open Telemetry Distributed Tracing in .NET 8", "Open Telemetry Distributed Tracing in .NET 7", "Open Telemetry Distributed Tracing in .NET 6", "Telemetry", "Telemetry guide", "Telemetry tutorial", "Telemetry best practices", "Telemetry in .NET"],
  relatedServices: ["microservices-architecture","azure-cloud-architecture"],
  relatedProjects: ["bat-inhouse-app"],
  relatedArticleSlugs: ["observability-dotnet-azure","azure-microservices-best-practices"],
  author: "Waqas Ahmad",
  content: `## Introduction

This guidance is relevant when the topic of this article applies to your system or design choices; it breaks down when constraints or context differ. I've applied it in real projects and refined the takeaways over time (as of 2026).

OpenTelemetry (OTel) is the vendor-neutral standard for traces, metrics, and logs. In .NET you use the OTel SDK to instrument your app and export to Azure Monitor, Jaeger, Zipkin, or any OTLP backend. This article explains how it works, how to add it at application level in enterprise apps, and—most importantly—how to **query** your telemetry so support and platform teams can find failures and latency quickly.

## Topics covered

- [Decision Context](#decision-context)
- [What is OpenTelemetry and distributed tracing?](#what-is-opentelemetry-and-what-is-distributed-tracing)
- [The three types of telemetry](#the-three-and-a-half-types-of-telemetry-in-opentelemetry)
- [Adding OpenTelemetry to ASP.NET Core](#adding-opentelemetry-to-aspnet-core-full-setup)
- [Tracing API: ActivitySource and Activity](#tracing-api-in-net-activitysource-and-activity-spans)
- [Metrics API: Meter and instruments](#metrics-api-in-net-meter-and-instruments)
- [Logs and trace correlation](#logs-ilogger-and-trace-correlation)
- [W3C Trace Context and propagation](#w3c-trace-context-and-propagation)
- [Custom spans and sampling](#custom-spans-and-sampling)
- [Export: OTLP, Azure Monitor, Jaeger](#export-otlp-azure-monitor-jaeger)
- [How to query telemetry (enterprise focus)](#how-to-query-your-telemetry)
- [Enterprise best practices](#enterprise-best-practices)
- [Common issues](#common-issues-and-challenges)
- [Summary](#summary)
- [Position & Rationale](#position--rationale)
- [Trade-Offs & Failure Modes](#trade-offs--failure-modes)
- [What Most Guides Miss](#what-most-guides-miss)
- [Decision Framework](#decision-framework)
- [Key Takeaways](#key-takeaways)
- [When I Would Use This Again — and When I Wouldn't](#when-i-would-use-this-again--and-when-i-wouldnt)
- [Frequently Asked Questions](#frequently-asked-questions)

## Decision Context

- **System scale:** One service to many; microservices or monoliths that need observability (traces, metrics, logs). Applies when you're adding or standardising on OpenTelemetry in .NET.
- **Team size:** Dev and ops; someone must own instrumentation, sampling, and export (OTLP, Azure Monitor). Works when the team can add ActivitySource/Meter and configure exporters.
- **Time / budget pressure:** Fits when you need to debug cross-service flows or meet SLOs; breaks down when there's no backend to query (then instrument but plan where data goes). Cost of full tracing can be high—sampling matters.
- **Technical constraints:** .NET (ASP.NET Core, HttpClient, EF Core); OpenTelemetry SDK; OTLP or Azure Monitor (or Jaeger, Zipkin). Assumes you can run an exporter and query traces.
- **Non-goals:** This article does not optimise for a specific vendor only; it focuses on vendor-neutral OTel and distributed tracing in .NET.

## What is OpenTelemetry and what is distributed tracing?

OTel is an open standard for observability: you instrument once with its APIs and SDKs, then export to whatever backend you use (Azure Monitor, Jaeger, Zipkin, Prometheus). Swap backends without changing code.

Distributed tracing means following a single request as it crosses services. Each service creates **spans**—e.g. "HTTP request", "DB call", "ProcessOrder". Trace ID and span ID are sent in HTTP (or message) headers so every span links into one **trace**. You get one timeline: API Gateway → Order Service → SQL → Billing. In .NET the SDK sits on top of \`System.Diagnostics.Activity\`; you plug in instrumentation (ASP.NET Core, HttpClient, EF Core) and an exporter, and data flows out.

## The three (and a half) types of telemetry in OpenTelemetry

OpenTelemetry defines three main **signals** (types of telemetry), plus **baggage** and **span events** that support them. Understanding each type helps you choose what to emit and how to query it.

### 1. Traces

**Traces** answer: *What path did this request take, and how long did each step take?* A **trace** is a **tree of spans**. Each **span** represents one unit of work: an HTTP request, a database call, a call to another service, or a business operation like "ValidateOrder". A span has:

- **Name** (e.g. \`GET /orders/123\`, \`ProcessOrder\`)
- **Start and end time** (duration is derived)
- **Trace ID** (same for all spans in one request)
- **Span ID** (unique for this span)
- **Parent span ID** (links to the parent so the tree can be built)
- **Attributes** (key-value pairs: \`http.method=GET\`, \`order.id=123\`)
- **Status** (Ok, Error)
- **Events** (timestamped points in time within the span, e.g. "cache miss", "validation failed")

Traces are what you use for **distributed tracing**: following a request across services and seeing the full timeline. In .NET you create spans via **ActivitySource** and **Activity** (from \`System.Diagnostics\`).

### 2. Metrics

**Metrics** answer: *How many? How fast? What is the current value?* They are **aggregated numerical data**: request count, error count, latency histogram, queue length, CPU usage. OpenTelemetry defines four metric **instruments**:

| Instrument | Description | Example use |
|------------|-------------|-------------|
| **Counter** | Monotonically increasing value (only goes up) | Request count, errors total |
| **UpDownCounter** | Value that can go up or down | Queue length, active connections |
| **Histogram** | Distribution of values (e.g. latency) | Request duration, payload size |
| **ObservableGauge** | Current value, sampled when read | CPU %, memory, current queue depth |

In .NET you create and record metrics via **Meter** and instruments (e.g. \`CreateCounter\`, \`CreateHistogram\`). Metrics are exported separately from traces (same OTLP pipeline, but different signal).

### 3. Logs

**Logs** answer: *What happened, when, and in what context?* A **log record** has a timestamp, a severity (e.g. Info, Error), a body (message), and optional attributes. OpenTelemetry does not replace your logger; it **integrates** with **ILogger** so that logs are exported in OTLP format and can be correlated with **trace ID** and **span ID**. That way you can search logs by trace ID and see all log lines for a single request. In .NET you use your normal **ILogger**; the OpenTelemetry logging provider adds trace/span context and exports to your backend.

### 4. Baggage and span events

**Baggage** is key-value data that is **propagated** with the trace context (e.g. in \`tracestate\` or a \`baggage\` header). Use it for data that downstream services need (e.g. tenant ID, feature flags). **Span events** are timestamped events **inside** a span (e.g. "cache hit", "retry attempt 2"). They are part of the trace, not a separate log stream; useful for debugging the internal steps of one operation.

## Adding OpenTelemetry to ASP.NET Core: full setup

You need a few **NuGet packages**: \`OpenTelemetry\`, \`OpenTelemetry.Instrumentation.AspNetCore\`, \`OpenTelemetry.Instrumentation.Http\`, \`OpenTelemetry.Exporter.OpenTelemetryProtocol\` (or \`Azure.Monitor.OpenTelemetry.Exporter\` for Azure). Optionally add \`OpenTelemetry.Instrumentation.EntityFrameworkCore\` for EF Core and \`OpenTelemetry.Extensions.Hosting\` for the host integration.

Below is a **full Program.cs** that enables **Tracing**, **Metrics**, and **Logs**, with ASP.NET Core and HttpClient instrumentation and OTLP export. You can swap the exporter for Azure Monitor or Jaeger by changing the exporter configuration.

\`\`\`csharp
// Program.cs – OpenTelemetry with Traces, Metrics, and Logs
using OpenTelemetry.Resources;
using OpenTelemetry.Metrics;
using OpenTelemetry.Logs;

var builder = WebApplication.CreateBuilder(args);

// ---- 1. Tracing ----
builder.Services.AddOpenTelemetry()
    .ConfigureResource(resource => resource
        .AddService(serviceName: builder.Environment.ApplicationName))
    .WithTracing(tracing =>
    {
        tracing.AddAspNetCoreInstrumentation(options =>
        {
            options.RecordException = true; // capture exceptions on spans
        });
        tracing.AddHttpClientInstrumentation(options =>
        {
            options.RecordException = true;
        });
        // Add your custom ActivitySource so spans are exported
        tracing.AddSource("MyApp.Orders");
        tracing.AddOtlpExporter(options =>
        {
            options.Endpoint = new Uri(builder.Configuration["Otlp:Endpoint"] ?? "http://localhost:4317/v1/traces");
        });
    })
    .WithMetrics(metrics =>
    {
        metrics.AddAspNetCoreInstrumentation();
        metrics.AddHttpClientInstrumentation();
        metrics.AddMeter("MyApp.Orders"); // your custom meter
        metrics.AddOtlpExporter(options =>
        {
            options.Endpoint = new Uri(builder.Configuration["Otlp:Endpoint"] ?? "http://localhost:4317/v1/metrics");
        });
    });

// ---- 2. Logs (OpenTelemetry logger provider) ----
builder.Logging.AddOpenTelemetry(logging =>
{
    logging.SetResourceBuilder(ResourceBuilder.CreateDefault().AddService(builder.Environment.ApplicationName));
    logging.AddOtlpExporter(options =>
    {
        options.Endpoint = new Uri(builder.Configuration["Otlp:Endpoint"] ?? "http://localhost:4317/v1/logs");
    });
});

var app = builder.Build();
app.MapControllers();
app.Run();
\`\`\`

**What each part does:**

- **ConfigureResource**: Sets the service name (and optional version/environment) so that all telemetry is tagged with your app name.
- **AddAspNetCoreInstrumentation**: Creates a span for each incoming HTTP request (method, path, status code).
- **AddHttpClientInstrumentation**: Creates a child span for each outgoing HTTP call and **injects** W3C Trace Context headers so the downstream service continues the same trace.
- **AddSource("MyApp.Orders")**: Registers your custom **ActivitySource** name so that spans you create from that source are exported.
- **AddMeter("MyApp.Orders")**: Registers your custom **Meter** name so that metrics you record from that meter are exported.
- **AddOtlpExporter**: Sends traces/metrics/logs to an OTLP endpoint (e.g. collector, Jaeger, or Azure Monitor OTLP). For **Azure Monitor** you would use \`UseAzureMonitor()\` or the Azure Monitor exporter package and connection string instead.

## Tracing API in .NET: ActivitySource and Activity (spans)

In .NET, **spans** are represented by **System.Diagnostics.Activity**. You create them from an **ActivitySource**. The OpenTelemetry SDK listens to activities from sources you register (e.g. \`AddSource("MyApp.Orders")\`).

### Creating an ActivitySource and starting a span

\`\`\`csharp
// MyApp/Telemetry/OrderActivitySource.cs
using System.Diagnostics;

namespace MyApp.Telemetry;

public static class OrderActivitySource
{
    public static readonly ActivitySource Source = new("MyApp.Orders", "1.0.0");
}
\`\`\`

\`\`\`csharp
// Usage: start a span for a business operation
public class OrderService
{
    public async Task<Order> ProcessOrderAsync(int orderId, CancellationToken ct = default)
    {
        using var activity = OrderActivitySource.Source.StartActivity("ProcessOrder");
        if (activity is null) return await GetOrderFromDbAsync(orderId, ct);

        activity.SetTag("order.id", orderId);

        try
        {
            var order = await GetOrderFromDbAsync(orderId, ct);
            activity.SetTag("order.status", order?.Status ?? "unknown");
            return order;
        }
        catch (Exception ex)
        {
            activity.SetStatus(ActivityStatusCode.Error, ex.Message);
            activity.RecordException(ex);
            throw;
        }
    }
}
\`\`\`

**Important:** If no listener is attached (e.g. OpenTelemetry not configured or source not registered), \`StartActivity\` can return \`null\`. The pattern \`if (activity is null) return ...\` avoids doing work when tracing is disabled. **Using** the activity disposes it and sets the end time.

### Span functions: SetTag, AddEvent, SetStatus, RecordException

| Function | Purpose | Example |
|----------|---------|--------|
| **SetTag(key, value)** | Add attribute for filtering and debugging | \`activity.SetTag("order.id", orderId)\` |
| **AddEvent(name)** or **AddEvent(name, DateTimeOffset, attributes)** | Timestamped event inside the span | \`activity?.AddEvent("Cache miss")\` |
| **SetStatus(StatusCode, description)** | Mark span as Ok or Error | \`activity.SetStatus(ActivityStatusCode.Error, ex.Message)\` |
| **RecordException(exception)** | Attach exception to span (if RecordException enabled) | \`activity.RecordException(ex)\` |

\`\`\`csharp
// Example: span with tags, events, and status
using var activity = OrderActivitySource.Source.StartActivity("ValidateOrder");
activity?.SetTag("order.id", orderId);
activity?.AddEvent("Validation started");

bool valid = await ValidateAsync(orderId, ct);
activity?.AddEvent(valid ? "Validation passed" : "Validation failed");
activity?.SetTag("validation.result", valid);

if (!valid)
    activity?.SetStatus(ActivityStatusCode.Error, "Validation failed");
\`\`\`

**Attribute types:** \`SetTag\` accepts \`string\`, \`int\`, \`bool\`, and similar; they are serialised as strings in the backend. Use consistent key names (e.g. \`order.id\`, \`http.status_code\`) so that you can query by them later.

## Metrics API in .NET: Meter and instruments

**Metrics** are created from a **Meter**. You register the meter name in \`AddMeter("MyApp.Orders")\` so that the SDK exports your metrics. The main functions are **CreateCounter**, **CreateHistogram**, **CreateUpDownCounter**, and **CreateObservableGauge**.

\`\`\`csharp
// MyApp/Telemetry/OrderMetrics.cs
using System.Diagnostics.Metrics;

namespace MyApp.Telemetry;

public class OrderMetrics
{
    private readonly Meter _meter;
    private readonly Counter<long> _ordersProcessed;
    private readonly Counter<long> _ordersFailed;
    private readonly Histogram<double> _orderDuration;

    public OrderMetrics()
    {
        _meter = new Meter("MyApp.Orders", "1.0.0");
        _ordersProcessed = _meter.CreateCounter<long>("orders.processed", description: "Number of orders processed");
        _ordersFailed = _meter.CreateCounter<long>("orders.failed", description: "Number of failed orders");
        _orderDuration = _meter.CreateHistogram<double>("order.duration", unit: "ms", description: "Order processing duration");
    }

    public void RecordOrderProcessed(string status) =>
        _ordersProcessed.Add(1, new KeyValuePair<string, object?>("order.status", status));

    public void RecordOrderFailed(string reason) =>
        _ordersFailed.Add(1, new KeyValuePair<string, object?>("failure.reason", reason));

    public void RecordOrderDuration(double durationMs, string operation) =>
        _orderDuration.Record(durationMs, new KeyValuePair<string, object?>("operation", operation));
}
\`\`\`

**Usage in a service:**

\`\`\`csharp
// Inject OrderMetrics via DI; in ProcessOrderAsync:
var sw = Stopwatch.StartNew();
try
{
    var order = await ProcessOrderAsync(orderId, ct);
    _orderMetrics.RecordOrderProcessed(order.Status);
    return order;
}
catch (Exception ex)
{
    _orderMetrics.RecordOrderFailed(ex.Message);
    throw;
}
finally
{
    _orderMetrics.RecordOrderDuration(sw.ElapsedMilliseconds, "ProcessOrder");
}
\`\`\`

| Instrument | Create method | When to use |
|------------|---------------|-------------|
| **Counter** | \`CreateCounter<long>(name)\` | Things that only increase: request count, errors total |
| **UpDownCounter** | \`CreateUpDownCounter<long>(name)\` | Values that go up and down: queue length, active connections |
| **Histogram** | \`CreateHistogram<double>(name, unit)\` | Distributions: latency (ms), payload size (bytes) |
| **ObservableGauge** | \`CreateObservableGauge(name, callback)\` | Current value when scraped: CPU %, memory, queue depth |

**Tags (attributes):** Pass \`KeyValuePair<string, object?>\` to \`Add\` or \`Record\` so you can filter and group in the backend (e.g. by \`order.status\`, \`operation\`).

## Logs: ILogger and trace correlation

When you use **ILogger** and add the **OpenTelemetry logging provider** (\`builder.Logging.AddOpenTelemetry(...)\`), your log records are exported in OTLP format. The SDK adds **trace ID** and **span ID** to each log record (when there is an active span). That way, in your backend you can **search logs by trace ID** and see every log line for a single request.

\`\`\`csharp
// In a controller or service – just use ILogger as usual
_logger.LogInformation("Processing order {OrderId}", orderId);
_logger.LogWarning("Retry attempt {Attempt} for order {OrderId}", attempt, orderId);
_logger.LogError(ex, "Order {OrderId} failed", orderId);
\`\`\`

No extra code is needed for correlation: the OpenTelemetry logger provider attaches the current activity's trace ID and span ID to the log record. Ensure your backend (e.g. Application Insights, Jaeger with a log backend) indexes these fields so you can query by \`trace_id\` or \`traceId\`.

## W3C Trace Context and propagation

**W3C Trace Context** is the standard for propagating **trace ID** and **span ID** in HTTP headers. The header \`traceparent\` has the form \`version-traceId-spanId-flags\` (e.g. \`00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01\`). When your app calls another service with **HttpClient**, the **HTTP client instrumentation** automatically **injects** \`traceparent\` (and optionally \`tracestate\`) so that the downstream service creates **child spans** with the same trace ID. One request → one trace across all services.

For **message-based** calls (e.g. Azure Service Bus), you must **inject** and **extract** trace context in the message headers yourself (or use an instrumentation library that does it). The context is stored in \`Activity.Current\`; you read \`traceparent\` from \`Activity.Current?.Id\` and the standard W3C format, and add it to the message; on the consumer side you restore the context and start a new span as a child.

## Custom spans and sampling

**Custom spans**: Use \`ActivitySource\` and \`StartActivity\` for business operations (e.g. "ProcessOrder", "ValidateOrder") so that each step appears in the trace. **Sampling**: In high-throughput scenarios you may not want to export every trace. Use **head-based sampling** (decide at the start of the trace) or **tail-based** (decide after the request, e.g. always export errors). Configure a custom \`Sampler\` in \`WithTracing\`:

\`\`\`csharp
tracing.SetSampler(new ParentBasedSampler(new TraceIdRatioBasedSampler(0.1))); // 10% of traces
\`\`\`

Always **sample errors** (e.g. status code Error or exception) so that failures are visible; many backends support "sample 100% of errors, 10% of success".

## Export: OTLP, Azure Monitor, Jaeger

- **OTLP**: The default. Point \`AddOtlpExporter\` to your collector or backend (e.g. \`http://localhost:4317/v1/traces\`). Same for metrics and logs (different paths: \`/v1/metrics\`, \`/v1/logs\`).
- **Azure Monitor**: Use the package \`Azure.Monitor.OpenTelemetry.Exporter\` and \`UseAzureMonitor()\` (or configure the exporter with connection string). Traces appear in **Application Insights** as "Transaction search" and "Dependencies"; metrics and logs also flow there.
- **Jaeger**: Run Jaeger with OTLP ingestion (default in recent versions) and point your app's OTLP exporter to the Jaeger endpoint (e.g. \`http://localhost:4317\`). No extra exporter needed.

## How to query your telemetry

In enterprise apps the main consumers are **support** (find why a specific request failed), **platform/SRE** (find slow or failing operations, trends), and **developers** (debug a trace from a log line). You need: (1) find by trace ID, (2) find slow/failed requests, (3) correlate logs to a trace, (4) dashboards and alerts. Below: concrete queries in **Azure Monitor** and **Jaeger**, then how to wire this into runbooks and dashboards.

### Querying in Azure Monitor / Application Insights

Application Insights uses **KQL (Kusto Query Language)**. You query **traces** (and dependencies) in the \`dependencies\` and \`requests\` tables; **logs** in \`traces\` (or \`customEvents\`); **metrics** in \`customMetrics\` or built-in metrics.

**1. Find a trace by trace ID**

When you have a **trace ID** (e.g. from a log line or an error report), search for all telemetry with that trace ID:

\`\`\`kusto
union requests, dependencies
| where operation_Id == "0af7651916cd43dd8448eb211c80319c"
| order by timestamp asc
\`\`\`

\`operation_Id\` in Application Insights is the **trace ID**. This returns all requests and dependencies (spans) that belong to that trace, in time order.

**2. Find slow requests or failed requests**

\`\`\`kusto
requests
| where duration > 1000 or success == false
| project timestamp, name, duration, success, operation_Id, resultCode
| order by timestamp desc
\`\`\`

**3. Find all spans (dependencies) for a given operation**

\`\`\`kusto
dependencies
| where operation_Id == "0af7651916cd43dd8448eb211c80319c"
| project timestamp, name, data, duration, success
| order by timestamp asc
\`\`\`

**4. Search logs by trace ID**

\`\`\`kusto
traces
| where operation_Id == "0af7651916cd43dd8448eb211c80319c"
| project timestamp, message, severityLevel
| order by timestamp asc
\`\`\`

**5. Query custom metrics**

If you exported a counter or histogram (e.g. \`orders.processed\`, \`order.duration\`), they appear in \`customMetrics\`:

\`\`\`kusto
customMetrics
| where name == "order.duration" or name == "orders.processed"
| summarize avg(value), sum(value) by name, bin(timestamp, 1h)
\`\`\`

**6. Application Insights "Transaction search" and "Performance"**

In the Azure portal, use **Transaction search** (under Investigation) to search by operation name, trace ID, or time range. Use **Performance** to see slow operations and drill into the trace. The **Application map** shows dependencies between services when trace context is propagated.

### Querying in Jaeger

In the **Jaeger UI** (e.g. \`http://localhost:16686\`):

1. **Search by Service**: Select your service name (the one you set in \`ConfigureResource\` or \`AddService\`).
2. **Search by Operation**: e.g. \`ProcessOrder\`, \`GET /orders/{id}\`.
3. **Search by Trace ID**: If you have the trace ID, paste it in the "Trace ID" field and click Find. You get the full trace tree.
4. **Tags**: Add tags (e.g. \`order.id=123\`, \`error=true\`) to filter traces that have those span attributes.
5. **Min / Max Duration**: Filter by duration to find slow traces.

Clicking a trace shows the **timeline** (waterfall) of all spans and their attributes and events.

### Querying logs by trace ID (any backend)

Search logs where \`trace_id\` (or Application Insights \`operation_Id\`) equals the trace ID. You get every log line for that request in one place.

### Enterprise querying: runbooks and dashboards

- **Runbooks**: Document "when user reports error X, get trace ID from log/error report → run this KQL (or Jaeger search) → interpret by looking at failed span and its parent". Keep the KQL in the runbook so support or on-call can paste and run.
- **Dashboards**: Pin the queries that matter: failed requests last 24h, p95 latency by operation, error rate by service. Use Application Insights workbooks or Grafana; alert when thresholds break so platform teams act before users complain.
- **SLOs**: Use metrics (e.g. \`order.duration\` histogram, \`orders.failed\` counter) to define SLOs and burn-rate alerts. Traces then explain *why* a specific request failed when the alert fires.

## Enterprise best practices

- **Application-level setup**: Add OTel once in \`Program.cs\` (or \`Startup.cs\`) with a shared resource name (service name, version). Use a single \`AddOpenTelemetry()\` call for tracing and metrics; add the logging provider so logs get trace/span IDs. Keep exporter endpoint and sampling in config, not code.
- **Naming**: Use one \`ActivitySource\` and one \`Meter\` per bounded context or team (e.g. \`MyCompany.Orders\`, \`MyCompany.Billing\`). Register every source/meter name in \`AddSource\` / \`AddMeter\` or nothing from that code path is exported.
- **Attributes**: Stick to a small set of attribute names (e.g. \`order.id\`, \`http.status_code\`) so queries and dashboards are consistent. Avoid PII in span attributes; use in logs only where policy allows.
- **Propagation**: Enable HTTP client instrumentation everywhere you call another service. For queues or buses, add context to message headers and restore it in the consumer; otherwise you get broken traces across services.
- **Sampling**: In high-throughput apps use head-based sampling (e.g. 10%) and always sample errors. Tune by cost vs. need; document the choice in your runbook.
- **Queryability**: Design so support can find a trace from a trace ID (from error page, log, or support ticket). Standardise on "trace ID" in user-facing error messages or logs so runbooks work.

## Common Issues and Challenges

**Missing propagation**: Downstream HTTP or message calls without trace context create **orphan** spans (different trace ID). Fix: add **HttpClient** instrumentation and, for messaging, inject/extract context in message headers.

**Custom spans or metrics not showing**: You must **register** your \`ActivitySource\` name in \`AddSource("MyApp.Orders")\` and your \`Meter\` name in \`AddMeter("MyApp.Orders")\`. Otherwise the SDK ignores them.

**High volume / cost**: Export every trace only if you can afford it. Use **sampling** (e.g. 10% of traces, 100% of errors) and **batch** export. In Application Insights, use sampling and retention policies to control cost.

**Wrong OTLP endpoint**: Ensure the exporter endpoint is correct (e.g. \`http://localhost:4317/v1/traces\` for a local collector). For Azure Monitor, use the Azure Monitor exporter or the correct Azure OTLP endpoint and connection string.

**Logs not correlated**: Ensure the OpenTelemetry **logging** provider is added and that your backend indexes \`trace_id\` / \`operation_Id\` so you can search logs by trace.

## Summary

OTel gives vendor-neutral traces, metrics, and logs. In .NET: ActivitySource/Activity for spans, Meter for metrics, ILogger with the OTel logging provider for logs. Add the SDK once, register your sources and meters, instrument ASP.NET Core and HttpClient, export via OTLP or Azure Monitor. Propagate W3C Trace Context so one request = one trace across services. In enterprise apps, focus on querying: trace ID in runbooks and error messages, KQL/Jaeger for finding failures and slow paths, dashboards and SLOs for trends. FAQs below for quick reference.

## Position & Rationale

I use **OpenTelemetry** for new .NET observability so we’re not locked to one vendor; we can switch from Jaeger to Azure Monitor by changing the exporter. I add **ASP.NET Core** and **HttpClient** instrumentation first so every request and downstream call gets a span; then **EF Core** if we need DB visibility. I set **sampling** (e.g. 100% of errors, 10% of success) so we don’t blow cost; I avoid “trace everything” in high-volume production without a sampling strategy. I **propagate** W3C Trace Context so cross-service calls link into one trace. I put **trace ID** in error messages and runbooks so support can find the full path. I don’t add custom spans for every method—only for meaningful operations (e.g. “ProcessOrder”, “CallBilling”).

## Trade-Offs & Failure Modes

**OpenTelemetry** adds dependency on SDK and exporter; you gain vendor-neutral instrumentation. **Full tracing** can be expensive; sampling and retention policies are necessary. **Log correlation** (trace_id in logs) requires the logging provider and a backend that indexes it. Failure modes: no sampling and high export cost; wrong OTLP endpoint so no data appears; logs not correlated so you can’t jump from trace to logs; too many custom spans (noise).

## What Most Guides Miss

Most guides show “add OTel and export” but don’t stress **sampling**—in production you often can’t afford 100% of traces; use head-based or tail-based sampling and always sample errors. Another gap: **querying**—having traces is useless if no one uses trace ID to find failures or slow paths; runbooks and error pages should include trace ID. **Logs + trace_id** correlation is often missing; add the OTel logging provider and ensure the backend indexes trace_id so you can search logs by trace.

## Decision Framework

- **If adding observability to .NET** → Add OpenTelemetry SDK; instrument ASP.NET Core and HttpClient; export to OTLP or Azure Monitor.
- **For sampling** → Use a sampling strategy (e.g. 100% errors, 10% success) to control cost.
- **For cross-service** → Ensure W3C Trace Context is propagated (HttpClient instrumentation does this).
- **For debugging** → Put trace ID in error responses and runbooks; query by trace ID in your backend.
- **For logs** → Add OTel logging provider and index trace_id so logs and traces link.

## Key Takeaways

- **OpenTelemetry** = vendor-neutral traces, metrics, logs; instrument once, export to any backend.
- **Sampling** is essential in production to control cost; sample errors fully, sample success proportionally.
- **Trace ID** in error messages and runbooks so you can find the full request path.
- Correlate **logs** with traces (trace_id); use the OTel logging provider and index trace_id.

## When I Would Use This Again — and When I Wouldn't

I’d use **OpenTelemetry** again for any new .NET service that needs tracing or metrics—standard instrumentation and exporter, with sampling. I’d use **W3C propagation** so cross-service calls form one trace. I wouldn’t enable 100% trace sampling in high-throughput production without a cost plan. I also wouldn’t add observability without a way to query it (backend, dashboards, runbooks that use trace ID); otherwise the data is unused.

## Frequently Asked Questions

### What is OpenTelemetry?

OpenTelemetry (OTel) is an open standard for observability: traces, metrics, and logs. It provides SDKs and APIs so that you instrument once and export to any backend (Azure Monitor, Jaeger, Zipkin, Prometheus, etc.).

### What is a span?

A span represents one unit of work (e.g. HTTP request, DB call, ProcessOrder). It has a name, start/end time, trace ID, span ID, optional attributes, status, and events. Spans are linked by trace ID to form a trace.

### What is a trace?

A trace is the full path of a request across services; it is a tree of spans. The trace ID ties all spans together; use it in your backend to search and visualise the request flow.

### What are the types of telemetry in OpenTelemetry?

Traces (spans), metrics (counters, histograms, gauges, up/down counters), and logs (log records with severity and body). Baggage and span events support traces. Each type has its own API in .NET: \`ActivitySource\`/\`Activity\` for traces, \`Meter\` for metrics, \`ILogger\` for logs.

### What is W3C Trace Context?

W3C Trace Context is a standard for propagating trace ID and span ID in HTTP headers (\`traceparent\`, \`tracestate\`). Downstream services read these headers and create child spans with the same trace ID so that one request produces one trace across all services.

### How do I add OpenTelemetry to .NET?

Add packages \`OpenTelemetry.Instrumentation.AspNetCore\`, \`OpenTelemetry.Instrumentation.Http\`, and \`OpenTelemetry.Exporter.OpenTelemetryProtocol\` (or \`Azure.Monitor.OpenTelemetry.Exporter\`). In \`Program.cs\` call \`AddOpenTelemetry().WithTracing(...).WithMetrics(...)\`, add \`AddAspNetCoreInstrumentation()\`, \`AddHttpClientInstrumentation()\`, \`AddSource\` and \`AddMeter\` for your custom names, and \`AddOtlpExporter(...)\`. For logs, use \`builder.Logging.AddOpenTelemetry(...)\`.

### How do I create custom spans in .NET?

Use \`ActivitySource\` (e.g. \`new ActivitySource("MyApp.Orders", "1.0.0")\`) and register the name in \`AddSource("MyApp.Orders")\`. Start a span with \`source.StartActivity("OperationName")\`; use \`SetTag\`, \`AddEvent\`, \`SetStatus\`, \`RecordException\`. Dispose or end the activity when the operation completes.

### What functions can I use on a span (Activity)?

\`SetTag(key, value)\` for attributes, \`AddEvent(name)\` or \`AddEvent(name, timestamp, attributes)\` for events, \`SetStatus(ActivityStatusCode.Error, description)\` for errors, \`RecordException(exception)\` to attach an exception. Use consistent key names for querying.

### How do I create custom metrics in .NET?

Create a \`Meter\` (e.g. \`new Meter("MyApp.Orders", "1.0.0")\`) and register the name in \`AddMeter("MyApp.Orders")\`. Use \`CreateCounter\`, \`CreateHistogram\`, \`CreateUpDownCounter\`, or \`CreateObservableGauge\`. Call \`Add(amount, tags)\` on counters or \`Record(value, tags)\` on histograms. Pass \`KeyValuePair\` for tags.

### How do I export to Azure Monitor?

Use the package \`Azure.Monitor.OpenTelemetry.Exporter\` and call \`UseAzureMonitor()\` (or configure the exporter with your connection string). Traces appear in Application Insights as requests and dependencies; metrics and logs also flow there.

### How do I query traces in Azure Monitor?

Use KQL: \`union requests, dependencies | where operation_Id == "your-trace-id" | order by timestamp asc\`. \`operation_Id\` is the trace ID. Use **Transaction search** in the portal or **Performance** to drill into slow or failed requests.

### How do I query traces in Jaeger?

In the Jaeger UI, search by **Service**, **Operation**, or paste the Trace ID. Add tags (e.g. \`order.id=123\`) to filter. Use **Min / Max Duration** to find slow traces. Click a trace to see the full span tree and timeline.

### How do I correlate logs with traces?

Add the OpenTelemetry logging provider (\`builder.Logging.AddOpenTelemetry(...)\`). The SDK attaches the current trace ID and span ID to each log record. In your backend, search logs by \`trace_id\` (or \`operation_Id\` in Application Insights) to see all log lines for a request.

### What is sampling and when should I use it?

Sampling means exporting only a fraction of traces (e.g. 10%) to reduce cost and volume. Use head-based sampling (\`TraceIdRatioBasedSampler\`) or tail-based (decide after the request). Always sample errors so that failures are visible.

### Why are my custom spans or metrics not showing?

Register your \`ActivitySource\` name in \`AddSource("YourSourceName")\` and your \`Meter\` name in \`AddMeter("YourMeterName")\`. Without that, the SDK does not export them.

### What is the difference between Counter and Histogram?

**Counter** is for values that only increase (e.g. request count, errors total); you call \`Add(amount)\`. **Histogram** is for distributions (e.g. latency, payload size); you call \`Record(value)\` and the backend computes percentiles (p50, p95, p99).

### What are best practices for OpenTelemetry in enterprise apps?

Add OTel once in \`Program.cs\` with a single \`AddOpenTelemetry()\` for tracing and metrics; add the logging provider so logs get trace/span IDs. Use one \`ActivitySource\` and one \`Meter\` per bounded context (e.g. \`MyCompany.Orders\`) and register every name in \`AddSource\`/\`AddMeter\`. Keep attribute names consistent (e.g. \`order.id\`) and avoid PII in span attributes. Put trace ID in runbooks and user-facing error messages so support can find a trace quickly.

### How do I propagate trace context for message queues (e.g. Service Bus)?

HTTP client instrumentation injects \`traceparent\` automatically. For queues or buses you must inject and extract context in message headers yourself: read the current activity's trace ID/span ID (or the W3C \`traceparent\` string) and add it to the outbound message; in the consumer, restore the context and start a new span as a child. Some libraries (e.g. Azure Service Bus instrumentation) do this for you.

### How do I use OpenTelemetry for runbooks and dashboards in enterprise?

Document in runbooks: when user reports error X, get trace ID from log or error page → run this **KQL** (or Jaeger search) → interpret by failed span and parent. Pin the KQL or Jaeger query so support can paste and run. For dashboards use metrics (e.g. \`order.duration\` histogram, \`orders.failed\` counter) and alert when thresholds break; use traces to explain why a specific request failed when the alert fires.`,
  faqs: [
  {
    "question": "What is OpenTelemetry?",
    "answer": "OpenTelemetry (OTel) is an open standard for observability: traces, metrics, and logs. It provides SDKs and APIs so that you instrument once and export to any backend (Azure Monitor, Jaeger, Zipkin, Prometheus, etc.)."
  },
  {
    "question": "What is a span?",
    "answer": "A span represents one unit of work (e.g. HTTP request, DB call, ProcessOrder). It has a name, start/end time, trace ID, span ID, optional attributes, status, and events. Spans are linked by trace ID to form a trace."
  },
  {
    "question": "What is a trace?",
    "answer": "A trace is the full path of a request across services; it is a tree of spans. The trace ID ties all spans together; use it in your backend to search and visualise the request flow."
  },
  {
    "question": "What are the types of telemetry in OpenTelemetry?",
    "answer": "Traces (spans), metrics (counters, histograms, gauges, up/down counters), and logs (log records with severity and body). Baggage and span events support traces. Each type has its own API in .NET: ActivitySource/Activity for traces, Meter for metrics, ILogger for logs."
  },
  {
    "question": "What is W3C Trace Context?",
    "answer": "W3C Trace Context is a standard for propagating trace ID and span ID in HTTP headers (traceparent, tracestate). Downstream services read these headers and create child spans with the same trace ID so that one request produces one trace across all services."
  },
  {
    "question": "How do I add OpenTelemetry to .NET?",
    "answer": "Add packages OpenTelemetry.Instrumentation.AspNetCore, OpenTelemetry.Instrumentation.Http, and OpenTelemetry.Exporter.OpenTelemetryProtocol (or Azure.Monitor.OpenTelemetry.Exporter). In Program.cs call AddOpenTelemetry().WithTracing(...).WithMetrics(...), add AddAspNetCoreInstrumentation(), AddHttpClientInstrumentation(), AddSource and AddMeter for your custom names, and AddOtlpExporter(...). For logs, use builder.Logging.AddOpenTelemetry(...)."
  },
  {
    "question": "How do I create custom spans in .NET?",
    "answer": "Use ActivitySource (e.g. new ActivitySource(\"MyApp.Orders\", \"1.0.0\")) and register the name in AddSource(\"MyApp.Orders\"). Start a span with source.StartActivity(\"OperationName\"); use SetTag, AddEvent, SetStatus, RecordException. Dispose or end the activity when the operation completes."
  },
  {
    "question": "What functions can I use on a span (Activity)?",
    "answer": "SetTag(key, value) for attributes, AddEvent(name) or AddEvent(name, timestamp, attributes) for events, SetStatus(ActivityStatusCode.Error, description) for errors, RecordException(exception) to attach an exception. Use consistent key names for querying."
  },
  {
    "question": "How do I create custom metrics in .NET?",
    "answer": "Create a Meter (e.g. new Meter(\"MyApp.Orders\", \"1.0.0\")) and register the name in AddMeter(\"MyApp.Orders\"). Use CreateCounter, CreateHistogram, CreateUpDownCounter, or CreateObservableGauge. Call Add(amount, tags) on counters or Record(value, tags) on histograms. Pass KeyValuePair for tags."
  },
  {
    "question": "How do I export to Azure Monitor?",
    "answer": "Use the package Azure.Monitor.OpenTelemetry.Exporter and call UseAzureMonitor() (or configure the exporter with your connection string). Traces appear in Application Insights as requests and dependencies; metrics and logs also flow there."
  },
  {
    "question": "How do I query traces in Azure Monitor?",
    "answer": "Use KQL: union requests, dependencies | where operation_Id == \"your-trace-id\" | order by timestamp asc. operation_Id is the trace ID. Use Transaction search in the portal or Performance to drill into slow or failed requests."
  },
  {
    "question": "How do I query traces in Jaeger?",
    "answer": "In the Jaeger UI, search by Service, Operation, or paste the Trace ID. Add tags (e.g. order.id=123) to filter. Use Min/Max Duration to find slow traces. Click a trace to see the full span tree and timeline."
  },
  {
    "question": "How do I correlate logs with traces?",
    "answer": "Add the OpenTelemetry logging provider (builder.Logging.AddOpenTelemetry(...)). The SDK attaches the current trace ID and span ID to each log record. In your backend, search logs by trace_id (or operation_Id in Application Insights) to see all log lines for a request."
  },
  {
    "question": "What is sampling and when should I use it?",
    "answer": "Sampling means exporting only a fraction of traces (e.g. 10%) to reduce cost and volume. Use head-based sampling (TraceIdRatioBasedSampler) or tail-based (decide after the request). Always sample errors so that failures are visible."
  },
  {
    "question": "Why are my custom spans or metrics not showing?",
    "answer": "Register your ActivitySource name in AddSource(\"YourSourceName\") and your Meter name in AddMeter(\"YourMeterName\"). Without that, the SDK does not export them."
  },
  {
    "question": "What is the difference between Counter and Histogram?",
    "answer": "Counter is for values that only increase (e.g. request count, errors total); you call Add(amount). Histogram is for distributions (e.g. latency, payload size); you call Record(value) and the backend computes percentiles (p50, p95, p99)."
  },
  {
    "question": "What are best practices for OpenTelemetry in enterprise apps?",
    "answer": "Add OTel once in Program.cs with a single AddOpenTelemetry() for tracing and metrics; add the logging provider so logs get trace/span IDs. Use one ActivitySource and one Meter per bounded context and register every name in AddSource/AddMeter. Keep attribute names consistent and avoid PII in span attributes. Put trace ID in runbooks and user-facing error messages so support can find a trace quickly."
  },
  {
    "question": "How do I propagate trace context for message queues (e.g. Service Bus)?",
    "answer": "HTTP client instrumentation injects traceparent automatically. For queues or buses inject and extract context in message headers: add the current activity's traceparent to the outbound message; in the consumer restore the context and start a new span as a child. Some libraries (e.g. Azure Service Bus instrumentation) do this for you."
  },
  {
    "question": "How do I use OpenTelemetry for runbooks and dashboards in enterprise?",
    "answer": "In runbooks document: get trace ID from log or error page, run this KQL or Jaeger search, interpret by failed span and parent. Pin the query so support can paste and run. For dashboards use metrics (e.g. order.duration, orders.failed) and alert on thresholds; use traces to explain why a specific request failed when the alert fires."
  }
]
}
