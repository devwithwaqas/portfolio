/**
 * Blog article: database-optimization-entity-framework
 * Auto-generated by scripts/split-blog-articles.js. Do not edit the content here by hand if you run the split script again.
 */

export default {
  slug: "database-optimization-entity-framework",
  title: "Database Optimization with Entity Framework Core",
  excerpt: "In-depth EF Core optimization: N+1 and eager loading, projection (LINQ Select to DTOs), AsNoTracking, compiled queries, batching (ExecuteUpdate, ExecuteDelete, AddRange), pagination and streaming, raw SQL, indexing, and split queries. Maximum code examples for LINQ and EF Core extensions. Real-world tuning from high-throughput enterprise systems.",
  date: "2024-10-07",
  topic: "Data",
  keywords: ["Database Optimization with Entity Framework Core", "Database Optimization Entity Framework", "Database Optimization Entity Framework best practices", "how to database optimization entity framework", "database optimization entity framework in .NET", "database optimization entity framework guide", "database optimization entity framework for enterprise", "database optimization entity framework patterns", "when to use database optimization entity framework", "database optimization entity framework tutorial", "database optimization entity framework examples", "database optimization entity framework in C#", "database optimization entity framework overview", "database optimization entity framework implementation", "understanding database optimization entity framework", "database optimization entity framework for developers", "database optimization entity framework checklist", "database optimization entity framework tips", "database optimization entity framework deep dive", "database optimization entity framework comparison", "database optimization entity framework vs alternatives", "database optimization entity framework .NET Core", "database optimization entity framework Azure", "database optimization entity framework explained", "database optimization entity framework when to use", "database optimization entity framework enterprise", "database optimization entity framework .NET", "what is database optimization entity framework", "database optimization entity framework summary", "database optimization entity framework introduction", "database optimization entity framework fundamentals", "database optimization entity framework step by step", "database optimization entity framework complete guide", "database optimization entity framework for beginners", "database optimization entity framework advanced", "database optimization entity framework production", "database optimization entity framework real world", "database optimization entity framework example code", "database optimization entity framework C# example", "database optimization entity framework .NET example", "learn database optimization entity framework", "database optimization entity framework learn", "database optimization entity framework reference", "database optimization entity framework cheat sheet", "database optimization entity framework pitfalls", "database optimization entity framework common mistakes", "database optimization entity framework performance", "database optimization entity framework optimization", "database optimization entity framework security", "database optimization entity framework testing", "database optimization entity framework unit test", "database optimization entity framework integration", "database optimization entity framework migration", "database optimization entity framework from scratch", "database optimization entity framework 2024", "database optimization entity framework 2025", "best database optimization entity framework", "database optimization entity framework best", "pro database optimization entity framework", "database optimization entity framework expert", "database optimization entity framework consultant", "database optimization entity framework services", "database optimization entity framework course", "database optimization entity framework workshop", "database optimization entity framework webinar", "database optimization entity framework blog", "database optimization entity framework article", "database optimization entity framework post", "why database optimization entity framework", "when database optimization entity framework", "where database optimization entity framework", "database optimization entity framework in .NET 6", "database optimization entity framework in .NET 7", "database optimization entity framework in .NET 8", "database optimization entity framework for C#", "database optimization entity framework for Angular", "database optimization entity framework for Vue", "database optimization entity framework for React", "database optimization entity framework for Azure", "database optimization entity framework for microservices", "database optimization entity framework for API", "database optimization entity framework for database", "database optimization entity framework for testing", "database optimization entity framework for DevOps", "database optimization entity framework for senior developers", "database optimization entity framework for team", "database optimization entity framework for production", "database optimization entity framework for scale", "database optimization entity framework for refactoring", "database optimization entity framework for enterprise applications", "database optimization entity framework for startup", "database optimization entity framework in 2024", "database optimization entity framework in 2025", "database optimization entity framework in 2026", "database optimization entity framework code sample", "database optimization entity framework code example", "database optimization entity framework sample code", "database optimization entity framework full example", "database optimization entity framework working example", "database optimization entity framework practical database optimization entity framework", "database optimization entity framework real world example", "database optimization entity framework use case", "database optimization entity framework use cases", "database optimization entity framework scenario", "database optimization entity framework scenarios", "database optimization entity framework pattern", "database optimization entity framework approach", "database optimization entity framework approaches", "database optimization entity framework strategy", "database optimization entity framework strategies", "database optimization entity framework technique", "database optimization entity framework techniques", "database optimization entity framework method", "database optimization entity framework methods", "database optimization entity framework solution", "database optimization entity framework solutions", "database optimization entity framework implementation guide", "database optimization entity framework getting started", "database optimization entity framework quick start", "database optimization entity framework overview guide", "database optimization entity framework comprehensive guide", "database optimization entity framework detailed guide", "database optimization entity framework practical guide", "database optimization entity framework developer guide", "database optimization entity framework engineer guide", "database optimization entity framework architect guide", "database optimization entity framework for architects", "database optimization entity framework for backend", "database optimization entity framework for tech leads", "database optimization entity framework for senior devs", "benefits of database optimization entity framework", "advantages of database optimization entity framework", "alternatives to database optimization entity framework", "compared to database optimization entity framework", "intro to database optimization entity framework", "basics of database optimization entity framework", "database optimization entity framework tips and tricks", "database optimization entity framework production-ready", "database optimization entity framework enterprise-grade", "database optimization entity framework with Docker", "database optimization entity framework with Kubernetes", "database optimization entity framework in ASP.NET Core", "database optimization entity framework with Entity Framework", "database optimization entity framework with EF Core", "database optimization entity framework modern", "database optimization entity framework updated", "database optimization entity framework latest", "database optimization entity framework walkthrough", "database optimization entity framework hands-on", "database optimization entity framework practical examples", "database optimization entity framework real-world examples", "database optimization entity framework common pitfalls", "database optimization entity framework gotchas", "database optimization entity framework FAQ", "database optimization entity framework FAQs", "database optimization entity framework Q&A", "database optimization entity framework interview questions", "database optimization entity framework interview", "database optimization entity framework certification", "database optimization entity framework training", "database optimization entity framework video", "database optimization entity framework series", "database optimization entity framework part 1", "database optimization entity framework core concepts", "database optimization entity framework key concepts", "database optimization entity framework recap", "database optimization entity framework takeaways", "database optimization entity framework conclusion", "database optimization entity framework next steps", "database optimization entity framework further reading", "database optimization entity framework resources", "database optimization entity framework tools", "database optimization entity framework libraries", "database optimization entity framework frameworks", "database optimization entity framework NuGet", "database optimization entity framework package", "database optimization entity framework GitHub", "database optimization entity framework open source", "database optimization entity framework community", "database optimization entity framework Microsoft docs", "database optimization entity framework documentation", "database optimization entity framework official guide", "database optimization entity framework official tutorial", "Database", "Database guide", "Database tutorial", "Database best practices", "Database in .NET", "Database in C#", "Database for developers", "Database examples", "Database patterns", "Database overview", "Database introduction", "Database deep dive", "Database explained", "Database how to", "Database what is", "Database when to use", "Database for enterprise", "Database .NET Core", "Database Azure", "Database C#", "Database with .NET", "Database with C#", "Database with Azure", "Database with Angular", "Database with Vue", "Database with React", "Database with Entity Framework", "Database with SQL Server", "Database step by step", "Database complete guide", "Database from scratch", "Database 2024", "Database 2025", "Database 2026", "Database code example", "Database sample code", "Database implementation", "Database real world", "Database production", "Database for beginners", "Database advanced", "Database for architects", "Database for backend", "Database for API", "Database in ASP.NET Core", "Database with EF Core", "Database tutorial 2024", "Database guide 2025", "Database best practices 2024", "Database C# examples", "Database .NET examples", "Database implementation guide", "Database how to implement", "Database benefits", "Database advantages", "Database pitfalls", "Database alternatives", "Database compared", "Database intro", "Database basics", "Database tips and tricks", "Database production-ready", "Database enterprise-grade", "Database maintainable", "Database testable", "Database refactoring", "Database modern", "Database updated", "Database latest", "Database for tech leads", "Database for senior devs", "Database with Docker", "Database with Kubernetes", "Database in .NET 8", "Database in .NET 7", "Database in .NET 6", "Database Optimization", "Database Optimization guide", "Database Optimization tutorial", "Database Optimization best practices", "Database Optimization in .NET", "Database Optimization in C#", "Database Optimization for developers", "Database Optimization examples", "Database Optimization patterns", "Database Optimization overview", "Database Optimization introduction", "Database Optimization deep dive", "Database Optimization explained", "Database Optimization how to", "Database Optimization what is", "Database Optimization when to use", "Database Optimization for enterprise", "Database Optimization .NET Core", "Database Optimization Azure", "Database Optimization C#", "Database Optimization with .NET", "Database Optimization with C#", "Database Optimization with Azure", "Database Optimization with Angular", "Database Optimization with Vue", "Database Optimization with React", "Database Optimization with Entity Framework", "Database Optimization with SQL Server", "Database Optimization step by step", "Database Optimization complete guide", "Database Optimization from scratch", "Database Optimization 2024", "Database Optimization 2025", "Database Optimization 2026", "Database Optimization code example", "Database Optimization sample code", "Database Optimization implementation", "Database Optimization real world", "Database Optimization production", "Database Optimization for beginners", "Database Optimization advanced", "Database Optimization for architects", "Database Optimization for backend", "Database Optimization for API", "Database Optimization in ASP.NET Core", "Database Optimization with EF Core", "Database Optimization tutorial 2024", "Database Optimization guide 2025", "Database Optimization best practices 2024", "Database Optimization C# examples", "Database Optimization .NET examples", "Database Optimization implementation guide", "Database Optimization how to implement", "Database Optimization benefits", "Database Optimization advantages", "Database Optimization pitfalls", "Database Optimization alternatives", "Database Optimization compared", "Database Optimization intro", "Database Optimization basics", "Database Optimization tips and tricks", "Database Optimization production-ready", "Database Optimization enterprise-grade", "Database Optimization maintainable", "Database Optimization testable", "Database Optimization refactoring", "Database Optimization modern", "Database Optimization updated", "Database Optimization latest", "Database Optimization for tech leads", "Database Optimization for senior devs", "Database Optimization with Docker", "Database Optimization with Kubernetes", "Database Optimization in .NET 8", "Database Optimization in .NET 7", "Database Optimization in .NET 6", "Database Optimization Entity", "Database Optimization Entity guide", "Database Optimization Entity tutorial", "Database Optimization Entity best practices", "Database Optimization Entity in .NET", "Database Optimization Entity in C#", "Database Optimization Entity for developers", "Database Optimization Entity examples", "Database Optimization Entity patterns", "Database Optimization Entity overview", "Database Optimization Entity introduction", "Database Optimization Entity deep dive", "Database Optimization Entity explained", "Database Optimization Entity how to", "Database Optimization Entity what is", "Database Optimization Entity when to use", "Database Optimization Entity for enterprise", "Database Optimization Entity .NET Core", "Database Optimization Entity Azure", "Database Optimization Entity C#", "Database Optimization Entity with .NET", "Database Optimization Entity with C#", "Database Optimization Entity with Azure", "Database Optimization Entity with Angular", "Database Optimization Entity with Vue", "Database Optimization Entity with React", "Database Optimization Entity with Entity Framework", "Database Optimization Entity with SQL Server", "Database Optimization Entity step by step", "Database Optimization Entity complete guide", "Database Optimization Entity from scratch", "Database Optimization Entity 2024", "Database Optimization Entity 2025", "Database Optimization Entity 2026", "Database Optimization Entity code example", "Database Optimization Entity sample code", "Database Optimization Entity implementation", "Database Optimization Entity real world", "Database Optimization Entity production", "Database Optimization Entity for beginners", "Database Optimization Entity advanced", "Database Optimization Entity for architects", "Database Optimization Entity for backend", "Database Optimization Entity for API", "Database Optimization Entity in ASP.NET Core", "Database Optimization Entity with EF Core", "Database Optimization Entity tutorial 2024", "Database Optimization Entity guide 2025", "Database Optimization Entity best practices 2024", "Database Optimization Entity C# examples", "Database Optimization Entity .NET examples", "Database Optimization Entity implementation guide", "Database Optimization Entity how to implement", "Database Optimization Entity benefits", "Database Optimization Entity advantages", "Database Optimization Entity pitfalls", "Database Optimization Entity alternatives", "Database Optimization Entity compared", "Database Optimization Entity intro", "Database Optimization Entity basics", "Database Optimization Entity tips and tricks", "Database Optimization Entity production-ready", "Database Optimization Entity enterprise-grade", "Database Optimization Entity maintainable", "Database Optimization Entity testable", "Database Optimization Entity refactoring", "Database Optimization Entity modern", "Database Optimization Entity updated", "Database Optimization Entity latest", "Database Optimization Entity for tech leads", "Database Optimization Entity for senior devs", "Database Optimization Entity with Docker", "Database Optimization Entity with Kubernetes", "Database Optimization Entity in .NET 8", "Database Optimization Entity in .NET 7", "Database Optimization Entity in .NET 6", "Database Optimization Entity Framework how to", "Database Optimization Entity Framework what is", "Database Optimization Entity Framework C#", "Database Optimization Entity Framework with .NET", "Database Optimization Entity Framework with C#", "Database Optimization Entity Framework with Azure", "Database Optimization Entity Framework with Angular", "Database Optimization Entity Framework with Vue", "Database Optimization Entity Framework with React", "Database Optimization Entity Framework with SQL Server", "Database Optimization Entity Framework 2026", "Database Optimization Entity Framework tutorial 2024", "Database Optimization Entity Framework guide 2025", "Database Optimization Entity Framework best practices 2024", "Database Optimization Entity Framework C# examples", "Database Optimization Entity Framework .NET examples", "Database Optimization Entity Framework how to implement", "Database Optimization Entity Framework benefits", "Database Optimization Entity Framework advantages", "Database Optimization Entity Framework alternatives", "Database Optimization Entity Framework compared", "Database Optimization Entity Framework intro", "Database Optimization Entity Framework basics", "Database Optimization Entity Framework maintainable", "Database Optimization Entity Framework testable", "Database Optimization Entity Framework refactoring", "Optimization", "Optimization guide", "Optimization tutorial", "Optimization best practices", "Optimization in .NET", "Optimization in C#", "Optimization for developers", "Optimization examples", "Optimization patterns", "Optimization overview", "Optimization introduction", "Optimization deep dive", "Optimization explained", "Optimization how to", "Optimization what is", "Optimization when to use", "Optimization for enterprise", "Optimization .NET Core", "Optimization Azure", "Optimization C#", "Optimization with .NET", "Optimization with C#", "Optimization with Azure", "Optimization with Angular", "Optimization with Vue", "Optimization with React", "Optimization with Entity Framework", "Optimization with SQL Server", "Optimization step by step", "Optimization complete guide", "Optimization from scratch", "Optimization 2024", "Optimization 2025", "Optimization 2026", "Optimization code example", "Optimization sample code", "Optimization implementation", "Optimization real world", "Optimization production", "Optimization for beginners", "Optimization advanced", "Optimization for architects", "Optimization for backend", "Optimization for API", "Optimization in ASP.NET Core", "Optimization with EF Core", "Optimization tutorial 2024", "Optimization guide 2025", "Optimization best practices 2024", "Optimization C# examples", "Optimization .NET examples", "Optimization implementation guide", "Optimization how to implement", "Optimization benefits", "Optimization advantages", "Optimization pitfalls", "Optimization alternatives", "Optimization compared", "Optimization intro", "Optimization basics", "Optimization tips and tricks", "Optimization production-ready", "Optimization enterprise-grade", "Optimization maintainable", "Optimization testable", "Optimization refactoring", "Optimization modern"],
  relatedServices: ["database-design-optimization","full-stack-development"],
  relatedProjects: ["bat-inhouse-app","g5-pos"],
  relatedArticleSlugs: ["sql-server-performance-tuning","database-transactions-isolation-levels","clean-architecture-dotnet"],
  author: "Waqas Ahmad",
  content: `## Introduction

This guidance is relevant when the topic of this article applies to your system or design choices; it breaks down when constraints or context differ. I've applied it in real projects and refined the takeaways over time (as of 2026).

**Entity Framework Core** is the standard **ORM (object-relational mapper)** for .NET: you write **LINQ** and work with **entities** instead of raw SQL. That abstraction is powerful but can introduce **N+1 queries**, **slow LINQ execution**, **unnecessary data transfer**, and **memory pressure** if not used carefully. In high-throughput enterprise systems—from e-commerce to internal platforms—I have repeatedly seen EF Core become the bottleneck when developers rely on default behaviour without measuring. This article is a **full, in-depth** guide to **database optimization with Entity Framework Core**: what EF Core is, what **N+1** and **compiled queries** are, and how to write **LINQ** and use **EF Core extensions** (e.g. \`AsNoTracking\`, \`Include\`, \`Select\`, compiled queries, batching, raw SQL) so that your database layer scales.

The golden rule: **measure first**. Use EF Core logging, Application Insights, or SQL profiling to see what is actually executed before you optimise. We cover **N+1** and eager loading, **projection** (LINQ \`Select\` to DTOs), **AsNoTracking** for read-only paths, **compiled queries** for hot paths, **batching** (\`ExecuteUpdate\`, \`ExecuteDelete\`, \`AddRange\`), **pagination** and **streaming**, **indexing** strategy, and **raw SQL** when LINQ is not enough. Every section includes **concrete C# and LINQ examples** so you can apply the patterns directly. If you are new to EF Core or to database optimization, we start with the basics and then go through each technique with maximum code examples.

If you are new to EF Core optimization, start with [Topics covered](#topics-covered) and [EF Core optimization at a glance](#ef-core-optimization-at-a-glance). We explain **EF Core**, **N+1**, **tracking**, **compiled queries**, **projection**, and **indexing** with concrete LINQ and C# examples.

## Topics covered

- [Decision Context](#decision-context)
- [What is Entity Framework Core and why does tuning matter?](#what-is-entity-framework-core-and-why-does-tuning-matter)
- [What is the N+1 problem?](#what-is-the-n-1-problem)
- [What is a compiled query?](#what-is-a-compiled-query)
- [EF Core optimization at a glance](#ef-core-optimization-at-a-glance)
- [DbContext and logging: see the SQL](#dbcontext-and-logging-see-the-sql)
- [N+1: bad vs eager loading vs projection](#n-1-bad-vs-eager-loading-vs-projection)
- [AsNoTracking for read-only queries](#asnotracking-for-read-only-queries)
- [Include and ThenInclude: eager loading in depth](#include-and-theninclude-eager-loading-in-depth)
- [Projection with Select: LINQ to DTOs](#projection-with-select-linq-to-dtos)
- [Compiled queries for hot paths](#compiled-queries-for-hot-paths)
- [Batching: ExecuteUpdate, ExecuteDelete, AddRange](#batching-executeupdate-executedelete-addrange)
- [Pagination and streaming](#pagination-and-streaming)
- [Raw SQL when LINQ is not enough](#raw-sql-when-linq-is-not-enough)
- [Indexing and query shape](#indexing-and-query-shape)
- [Split queries for large graphs](#split-queries-for-large-graphs)
- [Common issues and challenges](#common-issues-and-challenges)
- [Best practices and pitfalls](#best-practices-and-pitfalls)
- [Summary](#summary)
- [Position & Rationale](#position--rationale)
- [Trade-Offs & Failure Modes](#trade-offs--failure-modes)
- [What Most Guides Miss](#what-most-guides-miss)
- [Decision Framework](#decision-framework)
- [Key Takeaways](#key-takeaways)
- [When I Would Use This Again — and When I Wouldn't](#when-i-would-use-this-again--and-when-i-wouldnt)
- [Frequently Asked Questions](#frequently-asked-questions)

------

## Decision Context

- **System scale:** Apps using Entity Framework Core against SQL Server (or compatible); from small to large datasets; applies when you're tuning queries, reducing N+1, or improving EF-generated SQL.
- **Team size:** Backend or full-stack team; someone must own query patterns and indexing so performance doesn't regress.
- **Time / budget pressure:** Fits when you have time to profile and fix; breaks down when "we'll optimize later" and the app is already slow in production.
- **Technical constraints:** EF Core, SQL Server (or Azure SQL, PostgreSQL with EF); assumes you can add indexes, change queries, and use async.
- **Non-goals:** This article does not optimize for raw ADO or non-EF stacks; it optimises for EF Core and related tooling.


## What is Entity Framework Core and why does tuning matter?

**Entity Framework Core (EF Core)** is the **object-relational mapper (ORM)** for .NET. It lets you work with the database using **LINQ** and **entities** instead of raw SQL: you write \`context.Orders.Where(o => o.CustomerId == id)\` and EF Core **translates** that into SQL, runs it, and **materialises** the results as objects. That abstraction is convenient but it can **hide cost**. EF Core **tracks** entities by default (for change detection), loads **related data** only when you access it (lazy loading, if enabled), and generates SQL that may not match what you would write by hand. In high-throughput systems, small inefficiencies—an **N+1** here, a **table scan** there, or loading **full graphs** when you only need a few columns—add up. **Tuning EF Core** is not about abandoning it; it is about using it **deliberately**: eager loading and **projection** to control what gets loaded, **compiled queries** for hot paths, **AsNoTracking** for read-only scenarios, and aligning **indexes** with the SQL EF Core produces. This article covers those patterns with **maximum code examples** so your database layer scales.

---

## What is the N+1 problem?

The **N+1 problem** occurs when you load a **list** of entities and then **access a navigation property** on each: EF Core issues **one query** for the list and then **one query per item** for the related data. So for 100 orders you get 1 + 100 = **101 queries**. That blows up latency and load. The fix is **eager loading** with \`.Include()\` / \`.ThenInclude()\` (load related data in the same query) or **projection** with \`.Select()\` (load only the columns you need in a single query). We show both with code below.

---

## What is a compiled query?

A **compiled query** is a LINQ expression that EF Core **parses and compiles once** and **reuses** for every call. For code paths that run frequently (e.g. get order by ID on every request), that reduces the overhead of **parsing and compiling** the query tree on each invocation. You define it with \`EF.CompileQuery\` or \`EF.CompileAsyncQuery\` and call it with the context and parameters. Use compiled queries for **hot paths** with a **fixed shape**; avoid for highly dynamic filters that would require many variants.

---

## EF Core optimization at a glance

| Technique | What it is | When to use |
|-----------|------------|-------------|
| **Eager loading** | \`.Include()\` / \`.ThenInclude()\` load related entities in one query | When you need full related entities (e.g. Order + Customer) and will use them |
| **Projection** | \`.Select()\` to a DTO or anonymous type; only selected columns are queried | When you only need a subset of columns; often removes N+1 and reduces data transfer |
| **AsNoTracking()** | EF Core does not track loaded entities | **Read-only** queries (APIs, reports); reduces memory and CPU |
| **Compiled query** | \`EF.CompileAsyncQuery\` caches the compiled query | **Hot paths** (e.g. get by ID) with fixed shape |
| **Batching** | \`ExecuteUpdate\` / \`ExecuteDelete\` / \`AddRange\` | Bulk updates, deletes, or inserts with fewer round-trips |
| **Pagination** | \`.Skip().Take()\` before \`.ToListAsync()\` | Large result sets; only one page is read from the DB |
| **Streaming** | \`.AsAsyncEnumerable()\` | Process large sets without loading all into memory |
| **Raw SQL** | \`FromSqlRaw\` / \`ExecuteSqlRaw\` | When LINQ cannot express the query efficiently or you need full control |
| **Indexes** | Match \`WHERE\`, \`JOIN\`, \`ORDER BY\` columns | After capturing SQL and checking execution plans |

\`\`\`mermaid
flowchart LR
  A[LINQ query] --> B[EF Core]
  B --> C[SQL]
  C --> D[Index seek / scan]
  D --> E[Result set]
  style A fill:#2563eb,color:#fff
  style B fill:#7c3aed,color:#fff
  style C fill:#059669,color:#fff
\`\`\`

---

## DbContext and logging: see the SQL

Before optimising, you must **see** what EF Core sends to the database. Enable **logging** for executed commands.

\`\`\`csharp
// Program.cs or Startup – enable EF Core command logging
using Microsoft.EntityFrameworkCore;

var builder = WebApplication.CreateBuilder(args);
builder.Services.AddDbContext<MyDbContext>(options =>
{
    options.UseSqlServer(builder.Configuration.GetConnectionString("Default"));
    // Log every SQL command (disable in production or use level based on config)
    options.LogTo(Console.WriteLine, LogLevel.Information);
    // Or only when debugging: options.EnableSensitiveDataLogging();
});
\`\`\`

**What this does:** \`LogTo(Console.WriteLine, LogLevel.Information)\` prints every SQL command and its duration. In production, use **Application Insights** or your APM with EF Core telemetry so you can correlate slow requests with the SQL they execute. Once you see the SQL, run it in **SSMS** or **Azure Data Studio** and check the **execution plan** to find missing indexes or inefficient shapes.

---

## N+1: bad vs eager loading vs projection

**Step 1: Bad – N+1**

\`\`\`csharp
// BAD: N+1 – one query for orders, then one per order for Customer
// MyApp.Services/OrderService.cs
public async Task<List<Order>> GetOrdersWithCustomerNamesAsync(CancellationToken ct = default)
{
    var orders = await _context.Orders.ToListAsync(ct);
    foreach (var order in orders)
        _ = order.Customer.Name; // Triggers a separate query each time!
    return orders;
}
\`\`\`

**What goes wrong:** \`ToListAsync\` runs one \`SELECT * FROM Orders\`. Then each \`order.Customer.Name\` triggers another \`SELECT * FROM Customers WHERE Id = @p0\`. For 100 orders you get **101 queries**.

**Step 2: Good – eager loading with Include**

\`\`\`csharp
// GOOD: Eager load – one query with JOIN
public async Task<List<Order>> GetOrdersWithCustomerAsync(CancellationToken ct = default)
{
    return await _context.Orders
        .Include(o => o.Customer)
        .Include(o => o.LineItems)
        .ToListAsync(ct);
}
\`\`\`

**What this does:** EF Core generates a single query (or a few if using split queries) that **JOINs** Orders, Customers, and LineItems so that all data is loaded in one round-trip. Use **only** when you need the **full** Customer and LineItems entities.

**Step 3: Better – projection when you only need a few columns**

\`\`\`csharp
// BETTER: Projection – single query, only the columns you need
public async Task<List<OrderSummaryDto>> GetOrderSummariesAsync(CancellationToken ct = default)
{
    return await _context.Orders
        .Select(o => new OrderSummaryDto
        {
            Id = o.Id,
            OrderDate = o.OrderDate,
            CustomerName = o.Customer.Name,
            Total = o.LineItems.Sum(l => l.Amount)
        })
        .ToListAsync(ct);
}
\`\`\`

**What this does:** EF Core translates the \`Select\` into a **single SQL query** with the needed columns and JOINs/aggregates. No N+1, and **less data** transferred than loading full entities. Prefer **projection** when you do not need full entities.

---

## AsNoTracking for read-only queries

By default, EF Core **tracks** every entity it loads so it can detect **changes** and persist them on \`SaveChanges\`. Tracking costs **memory** and **CPU**. For **read-only** scenarios (e.g. APIs that return data, reports), use \`AsNoTracking()\`.

\`\`\`csharp
// Read-only: no change tracking
public async Task<OrderDto?> GetOrderByIdAsync(int id, CancellationToken ct = default)
{
    return await _context.Orders
        .AsNoTracking()
        .Where(o => o.Id == id)
        .Select(o => new OrderDto
        {
            Id = o.Id,
            CustomerName = o.Customer.Name,
            LineItems = o.LineItems.Select(l => new LineItemDto { ProductName = l.ProductName, Amount = l.Amount }).ToList()
        })
        .FirstOrDefaultAsync(ct);
}
\`\`\`

**What this does:** \`AsNoTracking()\` tells EF Core not to put entities in the change tracker. Queries run faster and use less memory. Use **tracking** only when you need to **modify** and **save** the same entities in the same context.

**Global default for read-only DbContext (optional):**

\`\`\`csharp
// DbContext for read-only queries – disable tracking by default
public class ReadOnlyDbContext : DbContext
{
    public ReadOnlyDbContext(DbContextOptions<ReadOnlyDbContext> options) : base(options) { }

    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        => optionsBuilder.UseQueryTrackingBehavior(QueryTrackingBehavior.NoTracking);
}
\`\`\`

---

## Include and ThenInclude: eager loading in depth

When you **do** need full related entities, use \`Include\` and \`ThenInclude\` so that they are loaded in **one (or a few) queries**, not N+1.

\`\`\`csharp
// One level: Order + Customer
var ordersWithCustomer = await _context.Orders
    .Include(o => o.Customer)
    .ToListAsync(ct);

// Two levels: Order + Customer + Customer.Address
var ordersWithCustomerAndAddress = await _context.Orders
    .Include(o => o.Customer)
        .ThenInclude(c => c.Address)
    .ToListAsync(ct);

// Multiple includes: Order + Customer and Order + LineItems
var ordersFull = await _context.Orders
    .Include(o => o.Customer)
    .Include(o => o.LineItems)
        .ThenInclude(l => l.Product)
    .ToListAsync(ct);
\`\`\`

**What this does:** Each \`Include\` / \`ThenInclude\` adds **related data** to the same (or split) query. Do **not** over-include: only load what you **use**. If you only need \`Customer.Name\`, prefer **projection** (\`Select\`) instead of loading the full \`Customer\` entity.

---

## Projection with Select: LINQ to DTOs

**Projection** means using \`.Select()\` to shape the result into a **DTO** or anonymous type. EF Core translates it into SQL that **only selects the columns** you need; often a **single query** with JOINs.

\`\`\`csharp
// Project to DTO – single query, no N+1, minimal data
public async Task<List<OrderListDto>> GetOrderListAsync(int customerId, CancellationToken ct = default)
{
    return await _context.Orders
        .AsNoTracking()
        .Where(o => o.CustomerId == customerId)
        .Select(o => new OrderListDto
        {
            Id = o.Id,
            OrderDate = o.OrderDate,
            CustomerName = o.Customer.Name,
            ItemCount = o.LineItems.Count,
            Total = o.LineItems.Sum(l => l.Amount)
        })
        .ToListAsync(ct);
}
\`\`\`

**What this does:** \`Customer.Name\` and \`LineItems.Count\` / \`Sum\` are evaluated **in the database**; EF Core generates a single SQL query with the appropriate JOINs and aggregates. No N+1, and only the required columns are returned.

**Projection with nested DTOs:**

\`\`\`csharp
return await _context.Orders
    .AsNoTracking()
    .Where(o => o.Id == orderId)
    .Select(o => new OrderDetailDto
    {
        Id = o.Id,
        Customer = new CustomerSummaryDto { Id = o.Customer.Id, Name = o.Customer.Name },
        LineItems = o.LineItems.Select(l => new LineItemDto { ProductName = l.ProductName, Amount = l.Amount }).ToList()
    })
    .FirstOrDefaultAsync(ct);
\`\`\`

**What this does:** Nested \`Select\` for \`Customer\` and \`LineItems\` is translated into a single query (or split query if the provider chooses). You get a DTO graph without loading full entities or N+1.

---

## Compiled queries for hot paths

For code paths that run **very frequently** (e.g. get order by ID on every request), **compiled queries** avoid re-parsing and re-compiling the query tree on each call.

\`\`\`csharp
// Static field – compiled once per process
private static readonly Func<MyDbContext, int, Task<Order?>> GetOrderByIdAsync =
    EF.CompileAsyncQuery((MyDbContext ctx, int id) =>
        ctx.Orders
            .Include(o => o.Customer)
            .Include(o => o.LineItems)
            .FirstOrDefault(o => o.Id == id));

// Usage
public async Task<Order?> GetOrderAsync(int id, CancellationToken ct = default)
{
    return await GetOrderByIdAsync(_context, id);
}
\`\`\`

**What this does:** \`EF.CompileAsyncQuery\` compiles the LINQ expression **once**; subsequent calls reuse the compiled delegate. Use for **hot paths** with a **fixed shape**. Avoid for highly dynamic queries (e.g. many optional filters) because each distinct shape can become a separate compiled query.

**Sync compiled query:**

\`\`\`csharp
private static readonly Func<MyDbContext, int, Order?> GetOrderById =
    EF.CompileQuery((MyDbContext ctx, int id) =>
        ctx.Orders
            .AsNoTracking()
            .Include(o => o.Customer)
            .FirstOrDefault(o => o.Id == id));
\`\`\`

---

## Batching: ExecuteUpdate, ExecuteDelete, AddRange

**Bulk update and delete (EF Core 7+)** reduce round-trips by executing a single statement instead of one per entity.

\`\`\`csharp
// Bulk update – one UPDATE statement
await _context.Orders
    .Where(o => o.Status == OrderStatus.Pending && o.CreatedAt < cutoff)
    .ExecuteUpdateAsync(s => s.SetProperty(o => o.Status, OrderStatus.Expired), ct);

// Bulk delete – one DELETE statement
await _context.Orders
    .Where(o => o.Status == OrderStatus.Cancelled)
    .ExecuteDeleteAsync(ct);
\`\`\`

**What this does:** \`ExecuteUpdateAsync\` and \`ExecuteDeleteAsync\` generate a single \`UPDATE\` or \`DELETE\` with a \`WHERE\` clause; no need to load entities into memory. Use when you are updating or deleting **many rows** by condition.

**Bulk insert with AddRange:**

\`\`\`csharp
// Batch insert – more efficient than Add() in a loop
var newOrders = new List<Order>();
for (int i = 0; i < 1000; i++)
    newOrders.Add(new Order { ... });

_context.Orders.AddRange(newOrders);
await _context.SaveChangesAsync(ct);
\`\`\`

**What this does:** \`AddRange\` attaches all entities in one go; \`SaveChangesAsync\` can batch the inserts (depending on the provider). For very large inserts, consider **bulk copy** (e.g. SqlBulkCopy) or raw SQL.

---

## Pagination and streaming

**Pagination:** Use \`.Skip().Take()\` **before** \`.ToListAsync()\` so that only one page is read from the database.

\`\`\`csharp
public async Task<List<OrderListDto>> GetOrdersPageAsync(int page, int pageSize, CancellationToken ct = default)
{
    return await _context.Orders
        .AsNoTracking()
        .OrderBy(o => o.OrderDate)
        .Skip((page - 1) * pageSize)
        .Take(pageSize)
        .Select(o => new OrderListDto { Id = o.Id, OrderDate = o.OrderDate, CustomerName = o.Customer.Name })
        .ToListAsync(ct);
}
\`\`\`

**What this does:** EF Core translates \`Skip\` and \`Take\` into \`OFFSET ... FETCH\` (or equivalent) so the database returns only one page. **Never** load the full set and then skip/take in memory.

**Streaming for very large result sets:**

\`\`\`csharp
await foreach (var dto in _context.Orders
    .AsNoTracking()
    .Select(o => new OrderListDto { Id = o.Id, CustomerName = o.Customer.Name })
    .AsAsyncEnumerable())
{
    await ProcessAsync(dto, ct);
}
\`\`\`

**What this does:** \`AsAsyncEnumerable()\` streams rows instead of loading all into memory. Use when you need to **process** a large set without holding it all in memory.

---

## Raw SQL when LINQ is not enough

When LINQ cannot express the query efficiently (e.g. complex CTEs, vendor-specific features) or you need **full control**, use **raw SQL** with **parameters** so that plans are reused and **injection** is avoided.

\`\`\`csharp
// Query with raw SQL – use parameters!
var customerId = 42;
var orders = await _context.Orders
    .FromSqlRaw(
        "SELECT * FROM Orders WHERE CustomerId = {0} AND Status = {1}",
        customerId,
        (int)OrderStatus.Active)
    .AsNoTracking()
    .ToListAsync(ct);
\`\`\`

**What this does:** \`FromSqlRaw\` runs the given SQL; \`{0}\` and \`{1}\` are replaced by **parameters** so the plan is reused and the query is safe. Prefer **LINQ** when it produces acceptable SQL; use raw SQL when **profiling** shows a need.

**Execute raw (non-query):**

\`\`\`csharp
await _context.Database.ExecuteSqlRawAsync(
    "UPDATE Orders SET Status = {0} WHERE CreatedAt < {1}",
    (int)OrderStatus.Expired,
    cutoff,
    ct);
\`\`\`

---

## Indexing and query shape

**Indexes** should match your **query predicates** and **sort** columns. Use **EF Core logging** to capture the SQL, then run it in SSMS or Azure Data Studio and look at the **execution plan**. Add indexes for columns used in \`WHERE\`, \`JOIN\`, and \`ORDER BY\`. Avoid indexing every column; focus on **slow** or **frequent** queries.

**Index in EF Core model (fluent):**

\`\`\`csharp
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<Order>()
        .HasIndex(o => o.CustomerId);
    modelBuilder.Entity<Order>()
        .HasIndex(o => new { o.Status, o.CreatedAt });
}
\`\`\`

**What this does:** \`HasIndex\` creates an index when you generate a migration. For **covering** indexes (INCLUDE columns), use raw SQL in a migration or provider-specific APIs. Align indexes with the **actual SQL** EF Core produces after you apply the patterns above.

---

## Split queries for large graphs

When you \`Include\` many or large collections, EF Core may generate a single query with many JOINs that returns **duplicate rows** (cartesian explosion). Use \`AsSplitQuery()\` so that EF Core runs **multiple queries** (one for the main entity, one per collection) and **composes** the result in memory.

\`\`\`csharp
var order = await _context.Orders
    .Include(o => o.Customer)
    .Include(o => o.LineItems)
        .ThenInclude(l => l.Product)
    .AsSplitQuery()
    .FirstOrDefaultAsync(o => o.Id == orderId, ct);
\`\`\`

**What this does:** Instead of one big JOIN, EF Core runs e.g. one query for Order+Customer and one for LineItems+Product, then merges the results. Use when a **single query** would return too many duplicated rows. Default in EF Core 5+ for multiple \`Include\` of collections can be configured globally; use \`AsSplitQuery()\` when needed.

---

## Common issues and challenges

**N+1 in production:** The most common EF Core performance pitfall. Always **measure** (logging, profiler) before and after; use **eager loading** and **projection** so that related data is loaded in one query or not loaded at all when not needed.

**Over-including:** \`.Include()\` loads **entire** related entities. If you only need a few columns, use **projection** (\`.Select()\`) instead; it reduces data transfer and often produces a single, efficient query.

**Compiled query misuse:** Compiled queries are cached per context type; avoid dynamic filters that would require many variants. Use them for **hot paths** (e.g. get by ID) and keep them simple.

**Index bloat:** Adding too many indexes slows **writes** and increases storage. Add indexes based on **actual query plans** and **usage**; remove unused indexes.

**Ignoring execution plans:** Without profiling, you cannot know if the engine is doing index seeks or table scans. Use **EF Core logging** or **SQL Profiler** to capture SQL and analyse plans; fix the worst offenders first.

**Loading huge result sets:** \`.ToListAsync()\` on a query that returns millions of rows can exhaust memory. Use **pagination** (\`.Skip().Take()\`), **streaming** (\`AsAsyncEnumerable()\`), or **projection** to limit data.

---

## Best practices and pitfalls

**Do:**

- **Measure first**: enable EF Core logging or APM; capture SQL and execution plans.
- Use **AsNoTracking()** for read-only queries.
- Prefer **projection** (\`.Select()\` to DTO) when you do not need full entities.
- Use **Include** / **ThenInclude** only when you need full related entities; otherwise project.
- Use **compiled queries** for hot paths with fixed shape.
- Use **Skip().Take()** for pagination; never load all and slice in memory.
- Use **ExecuteUpdate** / **ExecuteDelete** for bulk updates/deletes (EF Core 7+).
- Use **parameters** in raw SQL (\`FromSqlRaw\` with \`{0}\`, \`{1}\`, or \`FromSqlInterpolated\` carefully).
- Align **indexes** with the SQL your queries produce.

**Don't:**

- Don't **loop** and access navigation properties without having **included** or **projected** them (N+1).
- Don't **over-include**; load only what you use.
- Don't **ignore** change tracking cost for read-only paths; use \`AsNoTracking()\`.
- Don't load **millions of rows** with \`ToListAsync()\` without pagination or streaming.
- Don't use **raw SQL** with string concatenation (injection risk); use parameters.
- Don't add **indexes** without checking execution plans; too many indexes hurt writes.

---
---

## Position & Rationale

I **log and profile** EF Core SQL first—I don't add indexes or rewrite queries without seeing the actual statements and plans. I fix **N+1** with **eager loading** (\`.Include()\` / \`.ThenInclude()\`) or **projection** (\`.Select()\` to DTO); I prefer projection when the client needs a subset of fields so we get one efficient query and less data. I use **AsNoTracking()** for read-only queries to reduce memory and CPU. I use **compiled queries** for hot paths (e.g. get by ID) with fixed shape. I use **ExecuteUpdate** / **ExecuteDelete** / **AddRange** for bulk operations instead of loading and saving one by one. I **paginate** (\`.Skip().Take()\`) or **stream** (\`AsAsyncEnumerable()\`) for large result sets. I add **indexes** only after checking execution plans; I avoid over-indexing so writes don't suffer. I reject optimising without measuring; I reject loading full entities when a projection would do.

---

## Trade-Offs & Failure Modes

- **What this sacrifices:** Eager loading can over-fetch if we Include too much; compiled queries are less flexible. Raw SQL bypasses LINQ and needs manual maintenance.
- **Where it degrades:** When we don't profile—we guess and add indexes that don't help or hurt writes. When we use tracking for read-only—wasted memory. When we load full entities for lists—N+1 or huge payloads.
- **How it fails when misapplied:** Adding indexes without execution plans. Using tracking for every query. Fixing N+1 with Include when projection would be simpler and faster. Skipping pagination on large result sets so the app runs out of memory.
- **Early warning signs:** "The query is slow but we're not sure which"; "we have 50 Includes"; "the API returns 10MB for a list"; "writes got slow after we added indexes."

---

## What Most Guides Miss

Guides often show one technique (e.g. Include) and skip **when to use projection vs Include**—projection (\`.Select()\` to DTO) often gives one query and less data than loading full entities and mapping. **AsNoTracking()** for read-only is underplayed; tracking adds overhead we don't need when we're not updating. **Compiled queries** for hot paths (e.g. get by ID) are rarely shown; they avoid repeated plan compilation. **Batching** (ExecuteUpdate, ExecuteDelete, AddRange) vs one-by-one is a big win that many tutorials don't stress. The discipline of **measure first** (log SQL, check plans) before adding indexes or rewriting is also underplayed—we should never guess.

---

## Decision Framework

- **If a query is slow** → Enable EF logging or use a profiler; check for N+1, missing indexes, or over-fetching; fix with Include, projection, or index as appropriate.
- **If the query is read-only** → Use AsNoTracking(); use projection if the client needs a subset of fields.
- **If you have a hot path with fixed shape** → Use compiled queries.
- **If you're doing bulk updates or deletes** → Use ExecuteUpdate / ExecuteDelete; for bulk insert use AddRange and SaveChanges in batches.
- **If the result set is large** → Paginate (Skip/Take) or stream (AsAsyncEnumerable); don't load everything into memory.
- **If you need an index** → Check the execution plan first; add only what the plan suggests; avoid over-indexing.

---

## Key Takeaways

- Measure first (log SQL, execution plans); fix N+1 with Include or projection; use AsNoTracking for read-only; use projection when the client needs a subset.
- Use compiled queries for hot paths; use ExecuteUpdate/ExecuteDelete/AddRange for bulk; paginate or stream large result sets.
- Add indexes based on plans; don't over-index. Revisit when query shapes or data volume change.


## Summary

- **EF Core** is a powerful ORM; use **logging** and **profiling** to see the SQL and then optimise.
- **N+1**: fix with **eager loading** (\`.Include()\` / \`.ThenInclude()\`) or **projection** (\`.Select()\` to DTO).
- **AsNoTracking()** for read-only queries to reduce memory and CPU.
- **Projection** (\`.Select()\`) often gives a single, efficient query and less data transfer than loading full entities.
- **Compiled queries** for hot paths (e.g. get by ID) with fixed shape.
- **Batching**: \`ExecuteUpdate\` / \`ExecuteDelete\` / \`AddRange\` for bulk operations.
- **Pagination** (\`.Skip().Take()\`) and **streaming** (\`AsAsyncEnumerable()\`) for large result sets.
- **Raw SQL** when LINQ is not enough; always use **parameters**.
- **Indexes** should match \`WHERE\`, \`JOIN\`, \`ORDER BY\`; add based on **execution plans**. Use the FAQs below as a quick reference when tuning EF Core.

---

## When I Would Use This Again — and When I Wouldn't

I would use these optimisations again when I'm tuning EF Core apps that hit SQL Server (or compatible) and see slow queries, N+1, or high memory. I wouldn't optimise without profiling first—assumptions (e.g. "Include is always bad") can be wrong. I also wouldn't skip indexes and then add raw SQL everywhere; fix the data model and indexes first. Alternative: for small datasets or low traffic, default EF behaviour may be fine; add AsNoTracking and projection when you scale or profile shows need.


---

## Frequently Asked Questions

### How do I find N+1 queries in my EF Core application?

Enable **EF Core logging** (e.g. \`LogLevel.Microsoft.EntityFrameworkCore.Database.Command\`) or use **Application Insights** with EF Core telemetry to see every SQL statement. Look for **repeated** queries with the same pattern (e.g. one per order for customer).

### When should I use compiled queries?

Use compiled queries for **hot paths** that run frequently (e.g. get order by ID) and have a **fixed shape**. Avoid for ad-hoc or highly dynamic queries; the cache is per context type and query shape.

### What is the difference between Include and projection?

\`.Include()\` loads **full** related entities (e.g. Order + Customer + LineItems). **Projection** (\`.Select()\` to a DTO) loads **only the columns** you need and often produces a single, efficient query. Prefer projection when you do not need full entities.

### How do I choose which indexes to add?

Capture the **actual SQL** from EF Core logging; run it in SSMS or Azure Data Studio and look at the **execution plan**. Add indexes for columns used in WHERE, JOIN, and ORDER BY; use **covering indexes** (INCLUDE) when the query only needs a few columns.

### Can EF Core cause memory issues with large result sets?

Yes. Loading millions of rows with \`.ToListAsync()\` can exhaust memory. Use **pagination** (\`.Skip().Take()\`), **streaming** (\`AsAsyncEnumerable()\`), or **projection** to limit data; avoid loading full entity graphs for large sets.

### How do I measure EF Core performance in production?

Use **Application Insights** (or your APM) with EF Core telemetry; add **custom metrics** for slow queries. Use **distributed tracing** so that you can correlate slow requests with the SQL they execute.

### What is AsNoTracking and when should I use it?

\`AsNoTracking()\` tells EF Core **not to track** the entities it loads. For **read-only** queries (e.g. reports, APIs that only return data), tracking adds overhead and memory; use \`AsNoTracking()\` so that EF Core only materialises the data. Use tracking only when you need to **update and save** the same entities.

### How do I avoid N+1 when I need related data in a list?

Use \`.Include()\` and \`.ThenInclude()\` to **eager load** the related data in one query, or use **projection** (\`.Select()\` to a DTO) so that the related columns are loaded in a **single** query. Never loop and access a navigation property for each item without having included or projected it.

### What is the difference between FirstOrDefault and SingleOrDefault?

\`FirstOrDefault\` returns the **first** match (or null); \`SingleOrDefault\` returns the **single** match (or null) and **throws** if there is more than one. Use \`FirstOrDefault\` when you expect at most one but do not want to pay for a uniqueness check; use \`SingleOrDefault\` when you want to enforce "exactly one" and catch data errors.

### When should I use raw SQL with EF Core?

Use raw SQL when EF Core **cannot express** the query efficiently (e.g. complex CTEs, bulk operations, vendor-specific features) or when you need **full control**. Use \`FromSqlRaw\` or \`ExecuteSqlRaw\` with **parameters** so that plans are reused and injection is avoided. Prefer LINQ when it produces acceptable SQL; use raw SQL when **profiling** shows a need.

### How do I paginate with EF Core without loading everything?

Use \`.Skip((page - 1) * pageSize).Take(pageSize)\` **before** \`.ToListAsync()\`. EF Core translates that into \`OFFSET ... FETCH\` (or equivalent) so that **only one page** of rows is read from the database. Never load the full set and then skip/take in memory.

### What is change tracking and when does it hurt performance?

**Change tracking** is EF Core's mechanism for detecting **updates** and **deletes**. It adds **memory** and **CPU** for every entity you load. For **read-only** scenarios, use \`AsNoTracking()\` so that EF Core does not track. Use tracking only when you need to **modify and save** entities in the same context.

### How do I use EF Core with Azure SQL and connection resilience?

Use **connection resilience** (e.g. \`EnableRetryOnFailure\`) in your DbContext configuration so that **transient failures** (e.g. throttling) are retried. Use **Managed Identity** or a connection string from **Key Vault** so that credentials are not in config. Align **connection timeout** and **command timeout** with your SLA.

### What is the difference between Add and Update in EF Core?

\`Add\` marks an entity as **new** (insert); \`Update\` marks an entity as **modified** (update). For existing entities loaded from the database, **change the properties** and save; EF Core detects changes if tracking is enabled. For **new** entities, use \`Add\`. Avoid \`Update\` on entities that were not loaded from the same context unless you are doing a disconnected update with the correct state.

### How do I run migrations in production safely?

Run migrations as part of your **deployment pipeline** (e.g. \`dotnet ef database update\` or a script step). Prefer **backward-compatible** migrations (e.g. add column as **nullable** first, backfill, then add constraint) so that old and new app versions can run during deployment. **Test** migrations on a copy of production data before applying to production.

### What is ExecuteUpdate and ExecuteDelete?

\`ExecuteUpdateAsync\` and \`ExecuteDeleteAsync\` (EF Core 7+) execute a **single** \`UPDATE\` or \`DELETE\` statement with a \`WHERE\` clause **without loading** entities into memory. Use them for **bulk** updates or deletes by condition instead of loading, modifying, and saving each entity.

### When should I use AsSplitQuery?

Use \`AsSplitQuery()\` when you \`Include\` **multiple collections** or large collections and a **single query** would produce too many **duplicate rows** (cartesian explosion). EF Core then runs **multiple queries** (e.g. one for main entity, one per collection) and composes the result. Use when the default single-query behaviour is slow or returns too much data.

### How do I project to a DTO with nested collections in LINQ?

Use a **nested** \`.Select()\` inside the main \`.Select()\`: e.g. \`Select(o => new OrderDto { LineItems = o.LineItems.Select(l => new LineItemDto { ... }).ToList() })\`. EF Core translates it into a single query (or split query) that loads only the needed columns and shapes the DTO in memory.`,
  faqs: [
  {
    "question": "How do I find N+1 queries in my EF Core application?",
    "answer": "Enable EF Core logging (e.g. LogLevel.Microsoft.EntityFrameworkCore.Database.Command) or use Application Insights with EF Core telemetry to see every SQL statement. Look for repeated queries with the same pattern (e.g. one per order for customer)."
  },
  {
    "question": "When should I use compiled queries?",
    "answer": "Use compiled queries for hot paths that run frequently (e.g. get order by ID) and have a fixed shape. Avoid for ad-hoc or highly dynamic queries; the cache is per context type and query shape."
  },
  {
    "question": "What is the difference between Include and projection?",
    "answer": "Include loads full related entities (e.g. Order + Customer + LineItems). Projection (Select to a DTO) loads only the columns you need and often produces a single, efficient query. Prefer projection when you do not need full entities."
  },
  {
    "question": "How do I choose which indexes to add?",
    "answer": "Capture the actual SQL from EF Core logging; run it in SSMS or Azure Data Studio and look at the execution plan. Add indexes for columns used in WHERE, JOIN, and ORDER BY; use covering indexes (INCLUDE) when the query only needs a few columns."
  },
  {
    "question": "Can EF Core cause memory issues with large result sets?",
    "answer": "Yes. Loading millions of rows with ToListAsync() can exhaust memory. Use pagination (Skip/Take), streaming (AsAsyncEnumerable()), or projection to limit data; avoid loading full entity graphs for large sets."
  },
  {
    "question": "How do I measure EF Core performance in production?",
    "answer": "Use Application Insights (or your APM) with EF Core telemetry; add custom metrics for slow queries. Use distributed tracing so that you can correlate slow requests with the SQL they execute."
  },
  {
    "question": "What is AsNoTracking and when should I use it?",
    "answer": "AsNoTracking() tells EF Core not to track loaded entities. Use it for read-only queries (reports, APIs that only return data) to reduce overhead and memory; use tracking only when you need to update and save."
  },
  {
    "question": "How do I avoid N+1 when I need related data in a list?",
    "answer": "Use Include() and ThenInclude() to eager load the related data in one query, or use projection (Select to a DTO) so that related columns are loaded in a single query. Never loop and access navigation properties without including or projecting."
  },
  {
    "question": "What is the difference between FirstOrDefault and SingleOrDefault?",
    "answer": "FirstOrDefault returns the first match (or null); SingleOrDefault returns the single match and throws if more than one. Use FirstOrDefault when you expect at most one without enforcing uniqueness."
  },
  {
    "question": "When should I use raw SQL with EF Core?",
    "answer": "Use raw SQL when EF Core cannot express the query efficiently (complex CTEs, bulk ops, vendor-specific features) or you need full control. Use FromSqlRaw/ExecuteSqlRaw with parameters for plan reuse and security."
  },
  {
    "question": "How do I paginate with EF Core without loading everything?",
    "answer": "Use Skip((page - 1) * pageSize).Take(pageSize) before ToListAsync(); EF Core translates to OFFSET/FETCH so only one page is read from the database."
  },
  {
    "question": "What is change tracking and when does it hurt performance?",
    "answer": "Change tracking detects updates/deletes; it adds memory and CPU. For read-only queries use AsNoTracking(); use tracking only when you need to modify and save."
  },
  {
    "question": "How do I use EF Core with Azure SQL and connection resilience?",
    "answer": "Use EnableRetryOnFailure for transient failures; use Managed Identity or Key Vault for credentials. Align connection and command timeouts with your SLA."
  },
  {
    "question": "What is the difference between Add and Update in EF Core?",
    "answer": "Add marks an entity as new (insert); Update marks as modified (update). For existing entities, change properties and save; for new entities use Add."
  },
  {
    "question": "How do I run migrations in production safely?",
    "answer": "Run migrations in the deployment pipeline. Prefer backward-compatible migrations (e.g. add nullable column, backfill, then constrain). Test on a copy of production first."
  },
  {
    "question": "What is ExecuteUpdate and ExecuteDelete?",
    "answer": "ExecuteUpdateAsync and ExecuteDeleteAsync (EF Core 7+) run a single UPDATE or DELETE with a WHERE clause without loading entities. Use for bulk updates or deletes by condition."
  },
  {
    "question": "When should I use AsSplitQuery?",
    "answer": "Use AsSplitQuery() when you Include multiple or large collections and a single query would produce too many duplicate rows (cartesian explosion). EF Core then runs multiple queries and composes the result."
  },
  {
    "question": "How do I project to a DTO with nested collections in LINQ?",
    "answer": "Use a nested Select inside the main Select, e.g. Select(o => new OrderDto { LineItems = o.LineItems.Select(l => new LineItemDto { ... }).ToList() }). EF Core translates it into a single or split query that loads only needed columns."
  }
]
}
