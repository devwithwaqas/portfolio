/**
 * Blog article: grpc-vs-rest-dotnet-apis
 * Auto-generated by scripts/split-blog-articles.js. Do not edit the content here by hand if you run the split script again.
 */

export default {
  slug: "grpc-vs-rest-dotnet-apis",
  title: "gRPC vs REST for .NET APIs: When to Choose Which",
  excerpt: "In-depth comparison of gRPC and REST in .NET: performance, contract-first design, and when to use each for microservices and high-throughput APIs.",
  date: "2025-03-09",
  topic: "Full-Stack",
  keywords: ["gRPC vs REST for .NET APIs: When to Choose Which", "Grpc Vs Rest Dotnet Apis", "Grpc Vs Rest Dotnet Apis best practices", "how to grpc vs rest dotnet apis", "grpc vs rest dotnet apis in .NET", "grpc vs rest dotnet apis guide", "grpc vs rest dotnet apis for enterprise", "grpc vs rest dotnet apis patterns", "when to use grpc vs rest dotnet apis", "grpc vs rest dotnet apis tutorial", "grpc vs rest dotnet apis examples", "grpc vs rest dotnet apis in C#", "grpc vs rest dotnet apis overview", "grpc vs rest dotnet apis implementation", "understanding grpc vs rest dotnet apis", "grpc vs rest dotnet apis for developers", "grpc vs rest dotnet apis checklist", "grpc vs rest dotnet apis tips", "grpc vs rest dotnet apis deep dive", "grpc vs rest dotnet apis comparison", "grpc vs rest dotnet apis vs alternatives", "grpc vs rest dotnet apis .NET Core", "grpc vs rest dotnet apis Azure", "grpc vs rest dotnet apis explained", "grpc vs rest dotnet apis when to use", "grpc vs rest dotnet apis enterprise", "grpc vs rest dotnet apis .NET", "what is grpc vs rest dotnet apis", "grpc vs rest dotnet apis summary", "grpc vs rest dotnet apis introduction", "grpc vs rest dotnet apis fundamentals", "grpc vs rest dotnet apis step by step", "grpc vs rest dotnet apis complete guide", "grpc vs rest dotnet apis for beginners", "grpc vs rest dotnet apis advanced", "grpc vs rest dotnet apis production", "grpc vs rest dotnet apis real world", "grpc vs rest dotnet apis example code", "grpc vs rest dotnet apis C# example", "grpc vs rest dotnet apis .NET example", "learn grpc vs rest dotnet apis", "grpc vs rest dotnet apis learn", "grpc vs rest dotnet apis reference", "grpc vs rest dotnet apis cheat sheet", "grpc vs rest dotnet apis pitfalls", "grpc vs rest dotnet apis common mistakes", "grpc vs rest dotnet apis performance", "grpc vs rest dotnet apis optimization", "grpc vs rest dotnet apis security", "grpc vs rest dotnet apis testing", "grpc vs rest dotnet apis unit test", "grpc vs rest dotnet apis integration", "grpc vs rest dotnet apis migration", "grpc vs rest dotnet apis from scratch", "grpc vs rest dotnet apis 2024", "grpc vs rest dotnet apis 2025", "best grpc vs rest dotnet apis", "grpc vs rest dotnet apis best", "pro grpc vs rest dotnet apis", "grpc vs rest dotnet apis expert", "grpc vs rest dotnet apis consultant", "grpc vs rest dotnet apis services", "grpc vs rest dotnet apis course", "grpc vs rest dotnet apis workshop", "grpc vs rest dotnet apis webinar", "grpc vs rest dotnet apis blog", "grpc vs rest dotnet apis article", "grpc vs rest dotnet apis post", "why grpc vs rest dotnet apis", "when grpc vs rest dotnet apis", "where grpc vs rest dotnet apis", "grpc vs rest dotnet apis in .NET 6", "grpc vs rest dotnet apis in .NET 7", "grpc vs rest dotnet apis in .NET 8", "grpc vs rest dotnet apis for C#", "grpc vs rest dotnet apis for Angular", "grpc vs rest dotnet apis for Vue", "grpc vs rest dotnet apis for React", "grpc vs rest dotnet apis for Azure", "grpc vs rest dotnet apis for microservices", "grpc vs rest dotnet apis for API", "grpc vs rest dotnet apis for database", "grpc vs rest dotnet apis for testing", "grpc vs rest dotnet apis for DevOps", "grpc vs rest dotnet apis for senior developers", "grpc vs rest dotnet apis for team", "grpc vs rest dotnet apis for production", "grpc vs rest dotnet apis for scale", "grpc vs rest dotnet apis for refactoring", "grpc vs rest dotnet apis for enterprise applications", "grpc vs rest dotnet apis for startup", "grpc vs rest dotnet apis in 2024", "grpc vs rest dotnet apis in 2025", "grpc vs rest dotnet apis in 2026", "grpc vs rest dotnet apis code sample", "grpc vs rest dotnet apis code example", "grpc vs rest dotnet apis sample code", "grpc vs rest dotnet apis full example", "grpc vs rest dotnet apis working example", "grpc vs rest dotnet apis practical grpc vs rest dotnet apis", "grpc vs rest dotnet apis real world example", "grpc vs rest dotnet apis use case", "grpc vs rest dotnet apis use cases", "grpc vs rest dotnet apis scenario", "grpc vs rest dotnet apis scenarios", "grpc vs rest dotnet apis pattern", "grpc vs rest dotnet apis approach", "grpc vs rest dotnet apis approaches", "grpc vs rest dotnet apis strategy", "grpc vs rest dotnet apis strategies", "grpc vs rest dotnet apis technique", "grpc vs rest dotnet apis techniques", "grpc vs rest dotnet apis method", "grpc vs rest dotnet apis methods", "grpc vs rest dotnet apis solution", "grpc vs rest dotnet apis solutions", "grpc vs rest dotnet apis implementation guide", "grpc vs rest dotnet apis getting started", "grpc vs rest dotnet apis quick start", "grpc vs rest dotnet apis overview guide", "grpc vs rest dotnet apis comprehensive guide", "grpc vs rest dotnet apis detailed guide", "grpc vs rest dotnet apis practical guide", "grpc vs rest dotnet apis developer guide", "grpc vs rest dotnet apis engineer guide", "grpc vs rest dotnet apis architect guide", "grpc vs rest dotnet apis for architects", "grpc vs rest dotnet apis for backend", "grpc vs rest dotnet apis for tech leads", "grpc vs rest dotnet apis for senior devs", "benefits of grpc vs rest dotnet apis", "advantages of grpc vs rest dotnet apis", "alternatives to grpc vs rest dotnet apis", "compared to grpc vs rest dotnet apis", "intro to grpc vs rest dotnet apis", "basics of grpc vs rest dotnet apis", "grpc vs rest dotnet apis tips and tricks", "grpc vs rest dotnet apis production-ready", "grpc vs rest dotnet apis enterprise-grade", "grpc vs rest dotnet apis with Docker", "grpc vs rest dotnet apis with Kubernetes", "grpc vs rest dotnet apis in ASP.NET Core", "grpc vs rest dotnet apis with Entity Framework", "grpc vs rest dotnet apis with EF Core", "grpc vs rest dotnet apis modern", "grpc vs rest dotnet apis updated", "grpc vs rest dotnet apis latest", "grpc vs rest dotnet apis walkthrough", "grpc vs rest dotnet apis hands-on", "grpc vs rest dotnet apis practical examples", "grpc vs rest dotnet apis real-world examples", "grpc vs rest dotnet apis common pitfalls", "grpc vs rest dotnet apis gotchas", "grpc vs rest dotnet apis FAQ", "grpc vs rest dotnet apis FAQs", "grpc vs rest dotnet apis Q&A", "grpc vs rest dotnet apis interview questions", "grpc vs rest dotnet apis interview", "grpc vs rest dotnet apis certification", "grpc vs rest dotnet apis training", "grpc vs rest dotnet apis video", "grpc vs rest dotnet apis series", "grpc vs rest dotnet apis part 1", "grpc vs rest dotnet apis core concepts", "grpc vs rest dotnet apis key concepts", "grpc vs rest dotnet apis recap", "grpc vs rest dotnet apis takeaways", "grpc vs rest dotnet apis conclusion", "grpc vs rest dotnet apis next steps", "grpc vs rest dotnet apis further reading", "grpc vs rest dotnet apis resources", "grpc vs rest dotnet apis tools", "grpc vs rest dotnet apis libraries", "grpc vs rest dotnet apis frameworks", "grpc vs rest dotnet apis NuGet", "grpc vs rest dotnet apis package", "grpc vs rest dotnet apis GitHub", "grpc vs rest dotnet apis open source", "grpc vs rest dotnet apis community", "grpc vs rest dotnet apis Microsoft docs", "grpc vs rest dotnet apis documentation", "grpc vs rest dotnet apis official guide", "grpc vs rest dotnet apis official tutorial", "grpc vs rest apis with .NET Core", "grpc vs rest dotnet apis ASP.NET Core", "Grpc", "Grpc guide", "Grpc tutorial", "Grpc best practices", "Grpc in .NET", "Grpc in C#", "Grpc for developers", "Grpc examples", "Grpc patterns", "Grpc overview", "Grpc introduction", "Grpc deep dive", "Grpc explained", "Grpc how to", "Grpc what is"],
  relatedServices: ["full-stack-development","microservices-architecture"],
  relatedProjects: ["bat-inhouse-app"],
  relatedArticleSlugs: ["securing-apis-dotnet","rest-api-versioning-idempotency"],
  author: "Waqas Ahmad",
  content: `## Introduction

This guidance is relevant when the topic of this article applies to your system or design choices; it breaks down when constraints or context differ. I've applied it in real projects and refined the takeaways over time (as of 2026).

**REST** and **gRPC** are both valid choices for building APIs in .NET. REST—using HTTP and JSON—is the default for public APIs, browser clients, and situations where you need maximum compatibility. gRPC—using HTTP/2 and Protocol Buffers—excels in service-to-service communication, high throughput scenarios, and when you need streaming.

This article compares gRPC and REST in depth. We cover what each is, their strengths and weaknesses, how to implement both in ASP.NET Core, and when to choose which. By the end, you will understand the trade-offs and be able to make an informed decision for your architecture.

## Topics covered

- [Decision Context](#decision-context)
- [What is REST?](#what-is-rest)
- [What is gRPC?](#what-is-grpc)
- [What are Protocol Buffers?](#what-are-protocol-buffers)
- [gRPC vs REST: comparison table](#grpc-vs-rest-comparison-table)
- [REST implementation in ASP.NET Core](#rest-implementation-in-aspnet-core)
- [gRPC implementation in ASP.NET Core](#grpc-implementation-in-aspnet-core)
- [Streaming with gRPC](#streaming-with-grpc)
- [When to choose REST](#when-to-choose-rest)
- [When to choose gRPC](#when-to-choose-grpc)
- [Enterprise best practices](#enterprise-best-practices)
- [Common issues](#common-issues)
- [Summary](#summary)
- [Position & Rationale](#position--rationale)
- [Trade-Offs & Failure Modes](#trade-offs--failure-modes)
- [What Most Guides Miss](#what-most-guides-miss)
- [Decision Framework](#decision-framework)
- [Key Takeaways](#key-takeaways)
- [When I Would Use This Again — and When I Wouldn't](#when-i-would-use-this-again--and-when-i-wouldnt)
- [Frequently Asked Questions](#frequently-asked-questions)

## Decision Context

- **System scale:** APIs serving internal services, external clients, or both; from a few endpoints to many. Applies when you’re choosing the API style and transport for .NET services.
- **Team size:** Backend and sometimes front-end teams; someone must own .proto contracts (gRPC) or OpenAPI/contracts (REST). Works when clients can use HTTP/JSON (REST) or HTTP/2 + protobuf (gRPC).
- **Time / budget pressure:** Fits greenfield and “we need performance” or “we need browser compatibility”; breaks down when the team has no gRPC experience and must ship quickly—then REST is safer.
- **Technical constraints:** .NET (ASP.NET Core); REST with JSON or gRPC with Protocol Buffers; HTTP/1.1 or HTTP/2. Browser clients typically need REST (or gRPC-Web); server-to-server can use gRPC.
- **Non-goals:** This article does not optimise for GraphQL or other styles; it focuses on REST vs gRPC in .NET and when to choose which.

## What is REST?

**REST** (Representational State Transfer) is an architectural style for APIs. You expose resources as URLs and use HTTP methods to operate on them:

| Method | Purpose | Example |
|--------|---------|---------|
| GET | Read | \`GET /api/orders/123\` |
| POST | Create | \`POST /api/orders\` |
| PUT | Replace | \`PUT /api/orders/123\` |
| PATCH | Update | \`PATCH /api/orders/123\` |
| DELETE | Delete | \`DELETE /api/orders/123\` |

**Key characteristics:**
- **Stateless:** Each request contains all information needed
- **Cacheable:** GET responses can be cached (CDN, browser, proxy)
- **Human-readable:** JSON payloads are easy to inspect
- **Tool-friendly:** curl, Postman, Swagger all work out of the box
- **Ubiquitous:** Every language and platform supports HTTP/JSON

## What is gRPC?

**gRPC** (gRPC Remote Procedure Calls) is a high-performance RPC framework developed by Google. It uses:
- **HTTP/2** for transport (multiplexing, header compression)
- **Protocol Buffers** for serialisation (binary, strongly typed)
- **Contract-first design** via \`.proto\` files

**Key characteristics:**
- **Fast:** Binary serialisation is 5-10x smaller than JSON; HTTP/2 multiplexing reduces latency
- **Streaming:** Supports client, server, and bidirectional streaming
- **Strongly typed:** \`.proto\` files define contracts; code is generated
- **Cross-platform:** Clients and servers in any language (C#, Go, Java, Python, etc.)

## What are Protocol Buffers?

**Protocol Buffers (protobuf)** are a binary serialisation format with a schema definition language. You define messages in a \`.proto\` file:

\`\`\`protobuf
// orders.proto
syntax = "proto3";

package orders;

service OrderService {
  rpc CreateOrder (CreateOrderRequest) returns (CreateOrderResponse);
  rpc GetOrder (GetOrderRequest) returns (Order);
  rpc ListOrders (ListOrdersRequest) returns (stream Order); // server streaming
}

message CreateOrderRequest {
  string customer_id = 1;
  repeated OrderItem items = 2;
}

message CreateOrderResponse {
  string order_id = 1;
}

message GetOrderRequest {
  string order_id = 1;
}

message Order {
  string id = 1;
  string customer_id = 2;
  string status = 3;
  repeated OrderItem items = 4;
}

message OrderItem {
  string product_id = 1;
  int32 quantity = 2;
  double price = 3;
}

message ListOrdersRequest {
  string customer_id = 1;
}
\`\`\`

From this \`.proto\` file, the tooling generates C# classes and service stubs. The binary format is compact and fast to serialise/deserialise.

## gRPC vs REST: comparison table

| Aspect | REST | gRPC |
|--------|------|------|
| **Transport** | HTTP/1.1 or HTTP/2 | HTTP/2 only |
| **Serialisation** | JSON (text) | Protocol Buffers (binary) |
| **Contract** | OpenAPI/Swagger (optional) | \`.proto\` (required) |
| **Streaming** | Limited (SSE, WebSocket) | Built-in (client, server, bidirectional) |
| **Browser support** | Native | gRPC-Web (proxy required) |
| **Caching** | HTTP caching works | No HTTP caching |
| **Debugging** | Easy (JSON is readable) | Needs tooling (binary) |
| **Code generation** | Optional | Required |
| **Performance** | Good | Excellent |
| **Adoption** | Universal | Growing |

## REST implementation in ASP.NET Core

A typical REST API in ASP.NET Core:

\`\`\`csharp
// OrdersController.cs
[ApiController]
[Route("api/[controller]")]
public class OrdersController : ControllerBase
{
    private readonly IOrderService _orderService;

    public OrdersController(IOrderService orderService)
        => _orderService = orderService;

    [HttpGet("{id}")]
    public async Task<ActionResult<OrderDto>> GetOrder(string id)
    {
        var order = await _orderService.GetByIdAsync(id);
        return order == null ? NotFound() : Ok(order);
    }

    [HttpPost]
    public async Task<ActionResult<OrderDto>> CreateOrder(CreateOrderRequest request)
    {
        var order = await _orderService.CreateAsync(request);
        return CreatedAtAction(nameof(GetOrder), new { id = order.Id }, order);
    }

    [HttpGet]
    public async Task<ActionResult<IEnumerable<OrderDto>>> ListOrders([FromQuery] string customerId)
        => Ok(await _orderService.ListByCustomerAsync(customerId));
}
\`\`\`

\`\`\`csharp
// Program.cs
builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

var app = builder.Build();
app.UseSwagger();
app.UseSwaggerUI();
app.MapControllers();
app.Run();
\`\`\`

## gRPC implementation in ASP.NET Core

A typical gRPC service in ASP.NET Core:

**1. Add the NuGet package:**

\`\`\`bash
dotnet add package Grpc.AspNetCore
\`\`\`

**2. Add the .proto file to your project:**

\`\`\`xml
<!-- In .csproj -->
<ItemGroup>
  <Protobuf Include="Protosorders.proto" GrpcServices="Server" />
</ItemGroup>
\`\`\`

**3. Implement the service:**

\`\`\`csharp
// OrderServiceImpl.cs
public class OrderServiceImpl : OrderService.OrderServiceBase
{
    private readonly IOrderRepository _repository;
    private readonly ILogger<OrderServiceImpl> _logger;

    public OrderServiceImpl(IOrderRepository repository, ILogger<OrderServiceImpl> logger)
    {
        _repository = repository;
        _logger = logger;
    }

    public override async Task<CreateOrderResponse> CreateOrder(
        CreateOrderRequest request, ServerCallContext context)
    {
        _logger.LogInformation("Creating order for customer {CustomerId}", request.CustomerId);
        
        var orderId = await _repository.CreateAsync(request);
        return new CreateOrderResponse { OrderId = orderId };
    }

    public override async Task<Order> GetOrder(
        GetOrderRequest request, ServerCallContext context)
    {
        var order = await _repository.GetByIdAsync(request.OrderId);
        if (order == null)
        {
            throw new RpcException(new Status(StatusCode.NotFound, "Order not found"));
        }
        return order;
    }
}
\`\`\`

**4. Register in Program.cs:**

\`\`\`csharp
// Program.cs
builder.Services.AddGrpc();

var app = builder.Build();
app.MapGrpcService<OrderServiceImpl>();
app.Run();
\`\`\`

## Streaming with gRPC

gRPC supports three streaming modes:

| Mode | Description | Use case |
|------|-------------|----------|
| **Server streaming** | Server sends multiple messages | List large datasets, real-time updates |
| **Client streaming** | Client sends multiple messages | Upload batches, aggregations |
| **Bidirectional** | Both send multiple messages | Chat, real-time collaboration |

**Server streaming example:**

\`\`\`csharp
public override async Task ListOrders(
    ListOrdersRequest request,
    IServerStreamWriter<Order> responseStream,
    ServerCallContext context)
{
    await foreach (var order in _repository.GetOrdersAsync(request.CustomerId))
    {
        if (context.CancellationToken.IsCancellationRequested)
            break;
            
        await responseStream.WriteAsync(order);
    }
}
\`\`\`

**Client code for server streaming:**

\`\`\`csharp
using var call = client.ListOrders(new ListOrdersRequest { CustomerId = "cust-123" });

await foreach (var order in call.ResponseStream.ReadAllAsync())
{
    Console.WriteLine($"Order: {order.Id} - {order.Status}");
}
\`\`\`

## When to choose REST

**Choose REST when:**
- Clients are browsers or third-party consumers
- You need HTTP caching (CDN, browser cache)
- Maximum interoperability is required
- Payloads are small and latency is not critical
- You want easy debugging and inspection
- Team is more familiar with REST

**REST is the default** for public APIs and web applications.

## When to choose gRPC

**Choose gRPC when:**
- Clients are your own services (microservices communication)
- You need low latency and high throughput
- You want streaming (real-time data, large result sets)
- You prefer contract-first with strong typing
- You control both client and server
- Performance is critical

**gRPC excels** in service-to-service communication within a microservices architecture.

## Enterprise best practices

**1. Use REST at the edge, gRPC internally.** Expose REST APIs for external consumers and browsers; use gRPC for internal service-to-service communication. An API Gateway can translate.

**2. Version your contracts.** REST: URL versioning (\`/api/v1/orders\`) or header versioning. gRPC: evolve \`.proto\` files backward-compatibly (add fields, do not remove).

**3. Handle errors consistently.** REST: use HTTP status codes and problem details (RFC 7807). gRPC: use \`StatusCode\` and \`RpcException\`.

**4. Add deadlines and timeouts.** gRPC supports deadlines natively (\`context.Deadline\`). For REST, use \`HttpClient\` timeouts and cancellation tokens.

**5. Implement retries and circuit breakers.** Use Polly with \`HttpClient\` for REST. gRPC supports retry policies via \`GrpcChannelOptions\`.

**6. Secure with TLS.** Both REST and gRPC should use TLS in production. gRPC requires HTTP/2, which typically means TLS.

**7. Add observability.** Trace requests with OpenTelemetry. Log with structured logging. gRPC integrates with \`Grpc.AspNetCore\` instrumentation.

**8. Use gRPC-Web for browsers.** If you must call gRPC from browsers, use gRPC-Web with an Envoy proxy or ASP.NET Core gRPC-Web middleware.

## Common issues

| Issue | REST | gRPC |
|-------|------|------|
| **Browser support** | Native | Needs gRPC-Web proxy |
| **Firewall/proxy** | Works everywhere | Some proxies block HTTP/2 |
| **Debugging** | Easy (JSON) | Needs tooling (grpcurl, Bloom) |
| **Contract changes** | Can be implicit | Must update \`.proto\` |
| **Error handling** | HTTP status codes | \`StatusCode\` enum |
| **Caching** | HTTP caching works | No HTTP caching |
| **Learning curve** | Low | Medium |

## Summary

REST and gRPC serve different purposes. REST is the universal choice for public APIs, browser clients, and maximum compatibility. gRPC is the high-performance choice for internal services, streaming, and scenarios where you control both ends.

Many architectures use both: REST at the edge (API Gateway, public APIs) and gRPC internally (microservices). Choose based on your clients, performance requirements, and team expertise.

## Position & Rationale

I use **REST** when the API is public, consumed by browsers or third parties, or when I need HTTP caching and broad tooling support—it’s the default for “API that anyone can call.” I use **gRPC** when the callers are internal services, when I need streaming (client, server, or bidirectional), or when performance and strong typing matter and both ends are under our control. I avoid gRPC for browser-facing APIs unless we’re prepared for gRPC-Web and the extra setup. I prefer **REST at the edge and gRPC internally** in microservices: public or partner-facing APIs stay REST; service-to-service can be gRPC for efficiency. I don’t choose gRPC just for “it’s faster” if the team has no .proto experience and the latency requirement doesn’t justify the learning curve.

## Trade-Offs & Failure Modes

**REST** sacrifices some performance and compactness; you gain universal support, caching, and simplicity. **gRPC** sacrifices browser-friendliness and “curl-ability”; you gain performance, streaming, and contract-first with protobuf. **Both** in one system (REST edge, gRPC internal) adds two stacks to maintain but is common. Failure modes: using gRPC for a public API and then struggling with browser support; using REST for high-frequency internal calls and then hitting latency limits; ignoring contract versioning (both need a strategy for breaking changes).

## What Most Guides Miss

Most guides compare REST vs gRPC on features but don’t stress that **client type** is the first filter—browser or third party → REST (or gRPC-Web with effort); internal service → gRPC is often better. Another gap: **streaming** is a strong reason for gRPC (client/server/bidi streams) but is underused; many teams use request-response only and could stay with REST. **Contract evolution** (.proto and OpenAPI versioning) is rarely discussed; both need a policy for backward-compatible changes.

## Decision Framework

- **If clients are browsers or external partners** → Prefer REST; use JSON and HTTP caching.
- **If clients are internal services and you need performance or streaming** → Prefer gRPC; use .proto and HTTP/2.
- **If you have both public and internal consumers** → REST at the edge (gateway, BFF); gRPC between internal services.
- **For new internal service-to-service** → gRPC if the team can maintain .proto; REST if simplicity and familiarity matter more.
- **For contract changes** → Version .proto or API; support backward compatibility or document breaking changes.

## Key Takeaways

- **REST** for public APIs, browsers, and broad compatibility; **gRPC** for internal services, streaming, and performance.
- Choose by **client type** first: browser/external → REST; internal + performance/streaming → gRPC.
- **REST at edge, gRPC internal** is a common and valid split.
- gRPC needs .proto and HTTP/2; avoid for browser-only unless you use gRPC-Web.
- Plan contract versioning for both REST and gRPC.

## When I Would Use This Again — and When I Wouldn't

I’d use **REST** again for any public or browser-facing API and for partner integrations where HTTP/JSON is the norm. I’d use **gRPC** again for internal .NET-to-.NET or service-to-service APIs where we need throughput or streaming. I wouldn’t choose gRPC for a public API without a clear need (e.g. streaming) and gRPC-Web or proxy in place. I also wouldn’t force gRPC on a team that has no protobuf experience and a tight deadline—REST is the safer default when in doubt.

## Frequently Asked Questions

### What is REST?

**REST** (Representational State Transfer) is an architectural style using HTTP methods and URLs to expose resources. Responses are typically JSON. It is stateless, cacheable, and widely supported.

### What is gRPC?

**gRPC** is a high-performance RPC framework using HTTP/2 and Protocol Buffers. It supports streaming and strong typing via \`.proto\` files.

### What are Protocol Buffers?

**Protocol Buffers (protobuf)** are a binary serialisation format with a schema definition language (\`.proto\` files). They are compact and fast.

### Is gRPC faster than REST?

Generally yes. Binary serialisation (protobuf) is smaller and faster to parse than JSON. HTTP/2 multiplexing reduces latency. Benchmarks show 5-10x improvement in some scenarios.

### Can I use gRPC in browsers?

Not natively. Browsers do not support the HTTP/2 trailers gRPC requires. Use **gRPC-Web** with a proxy (Envoy) or middleware (ASP.NET Core \`Grpc.AspNetCore.Web\`).

### When should I use REST over gRPC?

Use REST for public APIs, browser clients, when you need HTTP caching, or when interoperability is paramount.

### When should I use gRPC over REST?

Use gRPC for internal service-to-service communication, high-throughput scenarios, streaming, or when you want contract-first development.

### How do I version gRPC APIs?

Evolve \`.proto\` files backward-compatibly: add new fields (do not reuse field numbers), do not remove fields, deprecate instead. For breaking changes, create a new service version.

### How do I handle errors in gRPC?

Throw \`RpcException\` with a \`StatusCode\` (e.g. \`NotFound\`, \`InvalidArgument\`, \`Internal\`). The client catches and handles based on the status code.

### What is gRPC streaming?

gRPC supports three streaming modes: **server streaming** (server sends multiple messages), **client streaming** (client sends multiple messages), and **bidirectional** (both send). Use for real-time data, large result sets, or chat-like scenarios.

### How do I secure gRPC?

Use TLS. gRPC over HTTP/2 typically requires TLS. Add authentication via interceptors (e.g. JWT token in metadata).

### Can I use REST and gRPC together?

Yes. Many architectures expose REST at the edge (API Gateway) and use gRPC internally between microservices. The gateway translates.

### What tools help debug gRPC?

Use \`grpcurl\` (command-line), **Bloom RPC** (GUI), or **Postman** (now supports gRPC). Reflection can be enabled for discovery.

### What is the N+1 problem in gRPC?

Same as in REST: making many small requests instead of one batch. Use batch endpoints or streaming to avoid.

### How do I add gRPC to an existing ASP.NET Core project?

Add \`Grpc.AspNetCore\` NuGet package, add \`.proto\` files to the project, implement service classes, and call \`MapGrpcService<T>()\` in \`Program.cs\`.`,
  faqs: [
  {
    "question": "What is REST?",
    "answer": "REST (Representational State Transfer) is an architectural style using HTTP methods and URLs. Responses are typically JSON. Stateless, cacheable, widely supported."
  },
  {
    "question": "What is gRPC?",
    "answer": "gRPC is a high-performance RPC framework using HTTP/2 and Protocol Buffers. Supports streaming and strong typing via .proto files."
  },
  {
    "question": "What are Protocol Buffers?",
    "answer": "Protocol Buffers (protobuf) are a binary serialisation format with a schema (.proto files). Compact and fast."
  },
  {
    "question": "Is gRPC faster than REST?",
    "answer": "Generally yes. Binary serialisation is smaller and faster than JSON. HTTP/2 multiplexing reduces latency. 5-10x improvement in some scenarios."
  },
  {
    "question": "Can I use gRPC in browsers?",
    "answer": "Not natively. Use gRPC-Web with a proxy (Envoy) or ASP.NET Core middleware."
  },
  {
    "question": "When should I use REST?",
    "answer": "For public APIs, browser clients, when you need HTTP caching, or when interoperability is paramount."
  },
  {
    "question": "When should I use gRPC?",
    "answer": "For internal service-to-service communication, high-throughput scenarios, streaming, or contract-first development."
  },
  {
    "question": "How do I version gRPC APIs?",
    "answer": "Evolve .proto files backward-compatibly: add new fields, do not remove. For breaking changes, create a new service version."
  },
  {
    "question": "How do I handle errors in gRPC?",
    "answer": "Throw RpcException with a StatusCode (NotFound, InvalidArgument, Internal). Client catches and handles."
  },
  {
    "question": "What is gRPC streaming?",
    "answer": "gRPC supports server streaming, client streaming, and bidirectional. Use for real-time data or large result sets."
  },
  {
    "question": "How do I secure gRPC?",
    "answer": "Use TLS. Add authentication via interceptors (e.g. JWT token in metadata)."
  },
  {
    "question": "Can I use REST and gRPC together?",
    "answer": "Yes. REST at the edge (API Gateway), gRPC internally between microservices. Gateway translates."
  },
  {
    "question": "What tools debug gRPC?",
    "answer": "grpcurl (CLI), Bloom RPC (GUI), Postman (now supports gRPC). Enable reflection for discovery."
  },
  {
    "question": "What is the N+1 problem in gRPC?",
    "answer": "Making many small requests instead of one batch. Use batch endpoints or streaming to avoid."
  },
  {
    "question": "How do I add gRPC to ASP.NET Core?",
    "answer": "Add Grpc.AspNetCore NuGet, add .proto files, implement services, call MapGrpcService<T>() in Program.cs."
  }
]
}
