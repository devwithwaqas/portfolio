/**
 * Blog article: structural-design-patterns-dotnet
 * Auto-generated by scripts/split-blog-articles.js. Do not edit the content here by hand if you run the split script again.
 */

export default {
  slug: "structural-design-patterns-dotnet",
  title: "Structural Design Patterns in .NET: All 7 Patterns with Full Working Code",
  excerpt: "All seven GoF structural patterns in .NET: Adapter, Bridge, Composite, Decorator, Facade, Flyweight, Proxy. Class diagrams, full C# examples, and when to use each.",
  date: "2025-10-24",
  topic: "Architecture",
  keywords: ["Structural Design Patterns in .NET: All 7 Patterns with Full Working Code", "Structural Design Patterns Dotnet", "Structural Design Patterns Dotnet best practices", "how to structural design patterns dotnet", "structural design patterns dotnet in .NET", "structural design patterns dotnet guide", "structural design patterns dotnet for enterprise", "structural design patterns dotnet patterns", "when to use structural design patterns dotnet", "structural design patterns dotnet tutorial", "structural design patterns dotnet examples", "structural design patterns dotnet in C#", "structural design patterns dotnet overview", "structural design patterns dotnet implementation", "understanding structural design patterns dotnet", "structural design patterns dotnet for developers", "structural design patterns dotnet checklist", "structural design patterns dotnet tips", "structural design patterns dotnet deep dive", "structural design patterns dotnet comparison", "structural design patterns dotnet vs alternatives", "structural design patterns dotnet .NET Core", "structural design patterns dotnet Azure", "structural design patterns dotnet explained", "structural design patterns dotnet when to use", "structural design patterns dotnet enterprise", "structural design patterns dotnet .NET", "what is structural design patterns dotnet", "structural design patterns dotnet summary", "structural design patterns dotnet introduction", "structural design patterns dotnet fundamentals", "structural design patterns dotnet step by step", "structural design patterns dotnet complete guide", "structural design patterns dotnet for beginners", "structural design patterns dotnet advanced", "structural design patterns dotnet production", "structural design patterns dotnet real world", "structural design patterns dotnet example code", "structural design patterns dotnet C# example", "structural design patterns dotnet .NET example", "learn structural design patterns dotnet", "structural design patterns dotnet learn", "structural design patterns dotnet reference", "structural design patterns dotnet cheat sheet", "structural design patterns dotnet pitfalls", "structural design patterns dotnet common mistakes", "structural design patterns dotnet performance", "structural design patterns dotnet optimization", "structural design patterns dotnet security", "structural design patterns dotnet testing", "structural design patterns dotnet unit test", "structural design patterns dotnet integration", "structural design patterns dotnet migration", "structural design patterns dotnet from scratch", "structural design patterns dotnet 2024", "structural design patterns dotnet 2025", "best structural design patterns dotnet", "structural design patterns dotnet best", "pro structural design patterns dotnet", "structural design patterns dotnet expert", "structural design patterns dotnet consultant", "structural design patterns dotnet services", "structural design patterns dotnet course", "structural design patterns dotnet workshop", "structural design patterns dotnet webinar", "structural design patterns dotnet blog", "structural design patterns dotnet article", "structural design patterns dotnet post", "why structural design patterns dotnet", "when structural design patterns dotnet", "where structural design patterns dotnet", "structural design patterns dotnet in .NET 6", "structural design patterns dotnet in .NET 7", "structural design patterns dotnet in .NET 8", "structural design patterns dotnet for C#", "structural design patterns dotnet for Angular", "structural design patterns dotnet for Vue", "structural design patterns dotnet for React", "structural design patterns dotnet for Azure", "structural design patterns dotnet for microservices", "structural design patterns dotnet for API", "structural design patterns dotnet for database", "structural design patterns dotnet for testing", "structural design patterns dotnet for DevOps", "structural design patterns dotnet for senior developers", "structural design patterns dotnet for team", "structural design patterns dotnet for production", "structural design patterns dotnet for scale", "structural design patterns dotnet for refactoring", "structural design patterns dotnet for enterprise applications", "structural design patterns dotnet for startup", "structural design patterns dotnet in 2024", "structural design patterns dotnet in 2025", "structural design patterns dotnet in 2026", "structural design patterns dotnet code sample", "structural design patterns dotnet code example", "structural design patterns dotnet sample code", "structural design patterns dotnet full example", "structural design patterns dotnet working example", "structural design patterns dotnet practical structural design patterns dotnet", "structural design patterns dotnet real world example", "structural design patterns dotnet use case", "structural design patterns dotnet use cases", "structural design patterns dotnet scenario", "structural design patterns dotnet scenarios", "structural design patterns dotnet pattern", "structural design patterns dotnet approach", "structural design patterns dotnet approaches", "structural design patterns dotnet strategy", "structural design patterns dotnet strategies", "structural design patterns dotnet technique", "structural design patterns dotnet techniques", "structural design patterns dotnet method", "structural design patterns dotnet methods", "structural design patterns dotnet solution", "structural design patterns dotnet solutions", "structural design patterns dotnet implementation guide", "structural design patterns dotnet getting started", "structural design patterns dotnet quick start", "structural design patterns dotnet overview guide", "structural design patterns dotnet comprehensive guide", "structural design patterns dotnet detailed guide", "structural design patterns dotnet practical guide", "structural design patterns dotnet developer guide", "structural design patterns dotnet engineer guide", "structural design patterns dotnet architect guide", "structural design patterns dotnet for architects", "structural design patterns dotnet for backend", "structural design patterns dotnet for tech leads", "structural design patterns dotnet for senior devs", "benefits of structural design patterns dotnet", "advantages of structural design patterns dotnet", "alternatives to structural design patterns dotnet", "compared to structural design patterns dotnet", "intro to structural design patterns dotnet", "basics of structural design patterns dotnet", "structural design patterns dotnet tips and tricks", "structural design patterns dotnet production-ready", "structural design patterns dotnet enterprise-grade", "structural design patterns dotnet with Docker", "structural design patterns dotnet with Kubernetes", "structural design patterns dotnet in ASP.NET Core", "structural design patterns dotnet with Entity Framework", "structural design patterns dotnet with EF Core", "structural design patterns dotnet modern", "structural design patterns dotnet updated", "structural design patterns dotnet latest", "structural design patterns dotnet walkthrough", "structural design patterns dotnet hands-on", "structural design patterns dotnet practical examples", "structural design patterns dotnet real-world examples", "structural design patterns dotnet common pitfalls", "structural design patterns dotnet gotchas", "structural design patterns dotnet FAQ", "structural design patterns dotnet FAQs", "structural design patterns dotnet Q&A", "structural design patterns dotnet interview questions", "structural design patterns dotnet interview", "structural design patterns dotnet certification", "structural design patterns dotnet training", "structural design patterns dotnet video", "structural design patterns dotnet series", "structural design patterns dotnet part 1", "structural design patterns dotnet core concepts", "structural design patterns dotnet key concepts", "structural design patterns dotnet recap", "structural design patterns dotnet takeaways", "structural design patterns dotnet conclusion", "structural design patterns dotnet next steps", "structural design patterns dotnet further reading", "structural design patterns dotnet resources", "structural design patterns dotnet tools", "structural design patterns dotnet libraries", "structural design patterns dotnet frameworks", "structural design patterns dotnet NuGet", "structural design patterns dotnet package", "structural design patterns dotnet GitHub", "structural design patterns dotnet open source", "structural design patterns dotnet community", "structural design patterns dotnet Microsoft docs", "structural design patterns dotnet documentation", "structural design patterns dotnet official guide", "structural design patterns dotnet official tutorial", "structural design patterns with .NET Core", "structural design patterns dotnet ASP.NET Core", "Structural", "Structural guide", "Structural tutorial", "Structural best practices", "Structural in .NET", "Structural in C#", "Structural for developers", "Structural examples", "Structural patterns", "Structural overview", "Structural introduction", "Structural deep dive", "Structural explained", "Structural how to", "Structural what is", "Structural when to use", "Structural for enterprise", "Structural .NET Core", "Structural Azure", "Structural C#", "Structural with .NET", "Structural with C#", "Structural with Azure", "Structural with Angular", "Structural with Vue", "Structural with React", "Structural with Entity Framework", "Structural with SQL Server", "Structural step by step", "Structural complete guide", "Structural from scratch", "Structural 2024", "Structural 2025", "Structural 2026", "Structural code example", "Structural sample code", "Structural implementation", "Structural real world", "Structural production", "Structural for beginners", "Structural advanced", "Structural for architects", "Structural for backend", "Structural for API", "Structural in ASP.NET Core", "Structural with EF Core", "Structural tutorial 2024", "Structural guide 2025", "Structural best practices 2024", "Structural C# examples", "Structural .NET examples", "Structural implementation guide", "Structural how to implement", "Structural benefits", "Structural advantages", "Structural pitfalls", "Structural alternatives", "Structural compared", "Structural intro", "Structural basics", "Structural tips and tricks", "Structural production-ready", "Structural enterprise-grade", "Structural maintainable", "Structural testable", "Structural refactoring", "Structural modern", "Structural updated", "Structural latest", "Structural for tech leads", "Structural for senior devs", "Structural with Docker", "Structural with Kubernetes", "Structural in .NET 8", "Structural in .NET 7", "Structural in .NET 6", "Structural Design", "Structural Design guide", "Structural Design tutorial", "Structural Design best practices", "Structural Design in .NET", "Structural Design in C#", "Structural Design for developers", "Structural Design examples", "Structural Design patterns", "Structural Design overview", "Structural Design introduction", "Structural Design deep dive", "Structural Design explained", "Structural Design how to", "Structural Design what is", "Structural Design when to use", "Structural Design for enterprise", "Structural Design .NET Core", "Structural Design Azure", "Structural Design C#", "Structural Design with .NET", "Structural Design with C#", "Structural Design with Azure", "Structural Design with Angular", "Structural Design with Vue", "Structural Design with React", "Structural Design with Entity Framework", "Structural Design with SQL Server", "Structural Design step by step", "Structural Design complete guide", "Structural Design from scratch", "Structural Design 2024", "Structural Design 2025", "Structural Design 2026", "Structural Design code example", "Structural Design sample code", "Structural Design implementation", "Structural Design real world", "Structural Design production", "Structural Design for beginners", "Structural Design advanced", "Structural Design for architects", "Structural Design for backend", "Structural Design for API", "Structural Design in ASP.NET Core", "Structural Design with EF Core", "Structural Design tutorial 2024", "Structural Design guide 2025", "Structural Design best practices 2024", "Structural Design C# examples", "Structural Design .NET examples", "Structural Design implementation guide", "Structural Design how to implement", "Structural Design benefits", "Structural Design advantages", "Structural Design pitfalls", "Structural Design alternatives", "Structural Design compared", "Structural Design intro", "Structural Design basics", "Structural Design tips and tricks", "Structural Design production-ready", "Structural Design enterprise-grade", "Structural Design maintainable", "Structural Design testable", "Structural Design refactoring", "Structural Design modern", "Structural Design updated", "Structural Design latest", "Structural Design for tech leads", "Structural Design for senior devs", "Structural Design with Docker", "Structural Design with Kubernetes", "Structural Design in .NET 8", "Structural Design in .NET 7", "Structural Design in .NET 6", "Structural Design Patterns guide", "Structural Design Patterns tutorial", "Structural Design Patterns best practices", "Structural Design Patterns in .NET", "Structural Design Patterns in C#", "Structural Design Patterns for developers", "Structural Design Patterns examples", "Structural Design Patterns patterns", "Structural Design Patterns overview", "Structural Design Patterns introduction", "Structural Design Patterns deep dive", "Structural Design Patterns explained", "Structural Design Patterns how to", "Structural Design Patterns what is", "Structural Design Patterns when to use", "Structural Design Patterns for enterprise", "Structural Design Patterns .NET Core", "Structural Design Patterns Azure", "Structural Design Patterns C#", "Structural Design Patterns with .NET", "Structural Design Patterns with C#", "Structural Design Patterns with Azure", "Structural Design Patterns with Angular", "Structural Design Patterns with Vue", "Structural Design Patterns with React", "Structural Design Patterns with Entity Framework", "Structural Design Patterns with SQL Server", "Structural Design Patterns step by step", "Structural Design Patterns complete guide", "Structural Design Patterns from scratch", "Structural Design Patterns 2024", "Structural Design Patterns 2025", "Structural Design Patterns 2026", "Structural Design Patterns code example", "Structural Design Patterns sample code", "Structural Design Patterns implementation", "Structural Design Patterns real world", "Structural Design Patterns production", "Structural Design Patterns for beginners", "Structural Design Patterns advanced", "Structural Design Patterns for architects", "Structural Design Patterns for backend", "Structural Design Patterns for API", "Structural Design Patterns in ASP.NET Core", "Structural Design Patterns with EF Core", "Structural Design Patterns tutorial 2024", "Structural Design Patterns guide 2025", "Structural Design Patterns best practices 2024", "Structural Design Patterns C# examples", "Structural Design Patterns .NET examples", "Structural Design Patterns implementation guide", "Structural Design Patterns how to implement", "Structural Design Patterns benefits", "Structural Design Patterns advantages", "Structural Design Patterns pitfalls", "Structural Design Patterns alternatives", "Structural Design Patterns compared", "Structural Design Patterns intro", "Structural Design Patterns basics", "Structural Design Patterns tips and tricks", "Structural Design Patterns production-ready", "Structural Design Patterns enterprise-grade", "Structural Design Patterns maintainable", "Structural Design Patterns testable", "Structural Design Patterns refactoring", "Structural Design Patterns modern", "Structural Design Patterns updated", "Structural Design Patterns latest", "Structural Design Patterns for tech leads", "Structural Design Patterns for senior devs", "Structural Design Patterns with Docker", "Structural Design Patterns with Kubernetes", "Structural Design Patterns in .NET 8", "Structural Design Patterns in .NET 7", "Structural Design Patterns in .NET 6", "Structural Design Patterns Dotnet how to", "Structural Design Patterns Dotnet what is", "Structural Design Patterns Dotnet C#", "Structural Design Patterns Dotnet with .NET", "Structural Design Patterns Dotnet with C#", "Structural Design Patterns Dotnet with Azure", "Structural Design Patterns Dotnet with Angular", "Structural Design Patterns Dotnet with Vue", "Structural Design Patterns Dotnet with React", "Structural Design Patterns Dotnet with SQL Server", "Structural Design Patterns Dotnet 2026", "Structural Design Patterns Dotnet tutorial 2024", "Structural Design Patterns Dotnet guide 2025", "Structural Design Patterns Dotnet best practices 2024", "Structural Design Patterns Dotnet C# examples", "Structural Design Patterns Dotnet .NET examples", "Structural Design Patterns Dotnet how to implement", "Structural Design Patterns Dotnet benefits", "Structural Design Patterns Dotnet advantages", "Structural Design Patterns Dotnet alternatives", "Structural Design Patterns Dotnet compared", "Structural Design Patterns Dotnet intro", "Structural Design Patterns Dotnet basics", "Structural Design Patterns Dotnet maintainable", "Structural Design Patterns Dotnet testable", "Structural Design Patterns Dotnet refactoring", "Design", "Design guide", "Design tutorial", "Design best practices", "Design in .NET", "Design in C#", "Design for developers", "Design examples", "Design patterns", "Design overview", "Design introduction", "Design deep dive", "Design explained", "Design how to", "Design what is", "Design when to use", "Design for enterprise", "Design .NET Core", "Design Azure", "Design C#", "Design with .NET"],
  relatedServices: ["full-stack-development","technical-leadership"],
  relatedProjects: ["bat-inhouse-app"],
  relatedArticleSlugs: ["design-patterns-overview-creational-structural-behavioral","creational-design-patterns-dotnet","behavioral-design-patterns-dotnet","clean-architecture-dotnet"],
  author: "Waqas Ahmad",
  content: `## Introduction

This guidance is relevant when the topic of this article applies to your system or design choices; it breaks down when constraints or context differ. I've applied it in real projects and refined the takeaways over time (as of 2026).

**Structural design patterns** deal with how classes and objects are **composed** into larger structures. Unlike creational patterns (object creation) or behavioral patterns (communication), structural patterns are about **wrapping**, **simplifying**, and **sharing**—adapting interfaces, separating abstraction from implementation, building trees, adding behavior without subclassing, hiding subsystems, sharing state, and controlling access. The Gang of Four defines **seven** structural patterns; this article covers **all of them** with a clear definition, **when and why to use it**, a **class-structure diagram**, and **full working C# examples**. Each pattern section follows the same order: what it is, when to use it, class diagram with explanation, then complete code and "how it fits together." No backtracking—each pattern is presented in its correct form.

If you are new to structural patterns, start with [All structural patterns at a glance](#all-structural-patterns-at-a-glance) and jump to the pattern you need.

## Topics covered

- [Decision Context](#decision-context)
- [What are structural patterns?](#what-are-structural-patterns)
- [All structural patterns at a glance](#all-structural-patterns-at-a-glance)
- [Adapter pattern](#adapter-pattern)
- [Bridge pattern](#bridge-pattern)
- [Composite pattern](#composite-pattern)
- [Decorator pattern](#decorator-pattern)
- [Facade pattern](#facade-pattern)
- [Flyweight pattern](#flyweight-pattern)
- [Proxy pattern](#proxy-pattern)
- [Comparison: when to use which](#comparison-when-to-use-which)
- [Common pitfalls](#common-pitfalls)
- [Summary](#summary)
- [Position & Rationale](#position--rationale)
- [Trade-Offs & Failure Modes](#trade-offs--failure-modes)
- [What Most Guides Miss](#what-most-guides-miss)
- [Decision Framework](#decision-framework)
- [Key Takeaways](#key-takeaways)
- [When I Would Use This Again — and When I Wouldn't](#when-i-would-use-this-again--and-when-i-wouldnt)
- [Frequently Asked Questions](#frequently-asked-questions)

## What are structural patterns?

Structural patterns describe **recurring ways to compose** types and objects: wrapping one interface to match another, separating abstraction from implementation, treating trees uniformly, adding responsibilities dynamically, simplifying subsystems, sharing state to save memory, and providing placeholders or access control. There are **seven** structural patterns; the table below lists all of them.

| Pattern | Problem it solves | Typical .NET use |
|--------|--------------------|------------------|
| **Adapter** | Client expects interface A; you have interface B | Legacy/third-party wrappers, SDK adapters |
| **Bridge** | Abstraction and implementation should vary independently | Pluggable drivers, UI + platform |
| **Composite** | Treat tree of objects uniformly (part–whole) | UI trees, file systems, expressions |
| **Decorator** | Add behavior at runtime without subclassing | Logging, caching, retry wrappers |
| **Facade** | Simple interface to a complex subsystem | Service layers, workflow entry points |
| **Flyweight** | Many similar objects; share state to save memory | Character/icon caches, shared config |
| **Proxy** | Placeholder or control access to another object | Lazy load, access control, remoting |

------

## Decision Context

- **System scale:** Varies by context; the approach in this article applies to the scales and scenarios described in the body.
- **Team size:** Typically small to medium teams; ownership and clarity matter more than headcount.
- **Time / budget pressure:** Applicable under delivery pressure; I've used it in both greenfield and incremental refactors.
- **Technical constraints:** .NET and related stack where relevant; constraints are noted in the article where they affect the approach.
- **Non-goals:** This article does not optimize for every possible scenario; boundaries are stated where they matter.


## All structural patterns at a glance

- **Adapter:** Wrap an existing interface so it matches the interface the client expects. Use for legacy APIs, external SDKs, and different data shapes.
- **Bridge:** Separate abstraction from implementation so both can vary independently. Use when you have multiple dimensions (e.g. abstraction types × implementations).
- **Composite:** Compose objects into tree structures; treat individual objects and compositions uniformly. Use for UI hierarchies, file systems, and expression trees.
- **Decorator:** Add responsibilities to an object dynamically by wrapping it. Use for logging, caching, retries, and cross-cutting concerns.
- **Facade:** Provide a simple interface to a complex subsystem. Use for order placement, onboarding flows, and multi-step workflows.
- **Flyweight:** Share state between many similar objects to save memory. Use for character glyphs, repeated icons, and shared configuration.
- **Proxy:** Provide a surrogate or placeholder for another object. Use for lazy loading, access control, caching, and remoting.

---

## Adapter pattern

### What it is and when to use it

**Adapter** wraps an existing interface so it matches the interface the client expects. Use it when you have **legacy or third-party** code that does not match your domain interface—the adapter translates calls and data so the client stays unchanged. Typical uses: legacy APIs, external SDKs, DTO → domain mapping, and wrapping non-async code in async interfaces.

### Class structure

\`\`\`mermaid
classDiagram
    class ITarget {
        <<interface>>
        +Request()
    }
    class Adapter {
        -Adaptee _adaptee
        +Request()
    }
    class Adaptee {
        +SpecificRequest()
    }
    Adapter ..|> ITarget
    Adapter --> Adaptee : uses
    classDef interface fill:#e0e7ff,stroke:#6366f1,stroke-width:2,color:#4338ca
    classDef adapter fill:#d1fae5,stroke:#059669,stroke-width:2,color:#065f46
    classDef adaptee fill:#fef3c7,stroke:#d97706,stroke-width:2,color:#92400e
    class ITarget:::interface
    class Adapter:::adapter
    class Adaptee:::adaptee
\`\`\`

**Class structure explained:** The **client** depends on **ITarget** (the interface you want). The **Adaptee** is the existing type with a different interface (\`SpecificRequest\`). The **Adapter** implements ITarget, holds the Adaptee, and in \`Request()\` calls \`_adaptee.SpecificRequest()\` (and may map data). The client receives an ITarget and never sees the Adaptee.

### Full working example: Legacy order API adapter

**1. Target interface and domain model**

\`\`\`csharp
namespace AdapterExample;
public interface IOrderService { Task<Order> GetByIdAsync(string id, CancellationToken ct = default); }
public record Order(string Id, decimal Total);
\`\`\`

**2. Adaptee (legacy API)**

\`\`\`csharp
namespace AdapterExample;
public class LegacyOrderApi {
    public async Task<LegacyOrderDto> FetchOrder(string code) =>
        await Task.FromResult(new LegacyOrderDto(code, 0m));
}
public record LegacyOrderDto(string Code, decimal Amount);
\`\`\`

**3. Adapter**

\`\`\`csharp
namespace AdapterExample;
public class LegacyOrderAdapter : IOrderService {
    private readonly LegacyOrderApi _legacy;
    public LegacyOrderAdapter(LegacyOrderApi legacy) => _legacy = legacy;
    public async Task<Order> GetByIdAsync(string id, CancellationToken ct = default) {
        var dto = await _legacy.FetchOrder(id);
        return new Order(dto.Code, dto.Amount);
    }
}
\`\`\`

**How this code fits together:** The client depends only on \`IOrderService\`. You register \`LegacyOrderAdapter\` as the implementation; it holds \`LegacyOrderApi\` and translates \`GetByIdAsync(id)\` into \`FetchOrder(id)\` and maps the DTO to \`Order\`. The client never sees the legacy API.

**When to use Adapter:** Use when you must **integrate code that has a different interface** (legacy, third-party, another team's SDK) and you want the rest of your app to depend on your own interface. Avoid when you control both sides—prefer a single, consistent interface.

---

## Bridge pattern

### What it is and when to use it

**Bridge** separates **abstraction** from **implementation** so both can vary independently. Use it when you have multiple abstraction types and multiple implementations and you want to avoid a Cartesian explosion of subclasses (e.g. \`RedCircle\`, \`BlueCircle\`, \`RedSquare\`…). The abstraction holds a reference to the implementation interface; callers work with the abstraction, and the implementation can be swapped.

### Class structure

\`\`\`mermaid
classDiagram
    class Abstraction {
        #IImplementor impl
        +Operation()
    }
    class RefinedAbstraction {
        +Operation()
    }
    class IImplementor {
        <<interface>>
        +OperationImpl()
    }
    class ConcreteImplementorA {
        +OperationImpl()
    }
    class ConcreteImplementorB {
        +OperationImpl()
    }
    RefinedAbstraction --|> Abstraction
    Abstraction --> IImplementor : uses
    ConcreteImplementorA ..|> IImplementor
    ConcreteImplementorB ..|> IImplementor
    classDef interface fill:#e0e7ff,stroke:#6366f1,stroke-width:2,color:#4338ca
    classDef abstraction fill:#dbeafe,stroke:#3b82f6,stroke-width:2,color:#1e40af
    classDef implementor fill:#d1fae5,stroke:#059669,stroke-width:2,color:#065f46
    class IImplementor:::interface
    class Abstraction:::abstraction
    class RefinedAbstraction:::abstraction
    class ConcreteImplementorA:::implementor
    class ConcreteImplementorB:::implementor
\`\`\`

**Class structure explained:** **Abstraction** (or a refined subclass) holds an **IImplementor** and delegates implementation details to it. **ConcreteImplementorA/B** provide different implementations. The client uses the abstraction; you inject the implementor (e.g. via DI or config), so you can change implementation without changing abstraction hierarchy.

### Full working example: Renderer abstraction and platform implementations

**1. Implementor interface and concrete implementors**

\`\`\`csharp
namespace BridgeExample;
public interface IRenderer { string Render(string text); }
public class HtmlRenderer : IRenderer { public string Render(string text) => $"<p>{text}</p>"; }
public class PlainTextRenderer : IRenderer { public string Render(string text) => text; }
\`\`\`

**2. Abstraction**

\`\`\`csharp
namespace BridgeExample;
public abstract class Document {
    protected readonly IRenderer Renderer;
    protected Document(IRenderer renderer) => Renderer = renderer;
    public abstract string GetContent();
}
public class ReportDocument : Document {
    public ReportDocument(IRenderer r) : base(r) { }
    public override string GetContent() => Renderer.Render("Report: data");
}
\`\`\`

**3. Usage**

\`\`\`csharp
var htmlReport = new ReportDocument(new HtmlRenderer());
var plainReport = new ReportDocument(new PlainTextRenderer());
Console.WriteLine(htmlReport.GetContent());   // <p>Report: data</p>
Console.WriteLine(plainReport.GetContent());  // Report: data
\`\`\`

**How this code fits together:** **Document** (abstraction) holds an **IRenderer** (implementor). **ReportDocument** calls \`Renderer.Render(...)\` inside \`GetContent()\`. You compose at runtime: same \`ReportDocument\` with different renderers produces different output. Adding a new document type or a new renderer does not require a new class for every combination.

**When to use Bridge:** Use when you have **two independent dimensions** (e.g. document types × output formats, UI controls × platforms) and want to avoid a multiplication of subclasses. Avoid when you have only one implementation or one abstraction—simplify instead.

---

## Composite pattern

### What it is and when to use it

**Composite** composes objects into **tree structures** so clients can treat **individual objects and compositions uniformly**. Use it for UI hierarchies (controls containing controls), file systems (files and folders), expression trees, and any part–whole structure where you want a single interface for leaves and containers.

### Class structure

\`\`\`mermaid
classDiagram
    class IComponent {
        <<interface>>
        +Operation()
        +Add(c)
        +Remove(c)
        +GetChild(i)
    }
    class Leaf {
        +Operation()
    }
    class Composite {
        -List~IComponent~ children
        +Operation()
        +Add(c)
        +Remove(c)
        +GetChild(i)
    }
    Composite ..|> IComponent
    Leaf ..|> IComponent
    Composite --> IComponent : children
    classDef interface fill:#e0e7ff,stroke:#6366f1,stroke-width:2,color:#4338ca
    classDef component fill:#dbeafe,stroke:#3b82f6,stroke-width:2,color:#1e40af
    classDef leaf fill:#d1fae5,stroke:#059669,stroke-width:2,color:#065f46
    classDef composite fill:#d1fae5,stroke:#059669,stroke-width:2,color:#065f46
    class IComponent:::interface
    class Leaf:::leaf
    class Composite:::composite
\`\`\`

**Class structure explained:** **IComponent** defines the common interface (e.g. \`Operation()\`, and optionally \`Add\`/\`Remove\`/\`GetChild\`). **Leaf** implements \`Operation()\` and does nothing for add/remove (or throws). **Composite** holds a list of IComponent children, implements \`Operation()\` by delegating to each child, and implements \`Add\`/\`Remove\`/\`GetChild\`. The client treats IComponent uniformly; it can be a leaf or a composite.

### Full working example: File system (files and folders)

**1. Component interface**

\`\`\`csharp
namespace CompositeExample;
public interface IFileSystemNode {
    string Name { get; }
    int GetSize();
}
\`\`\`

**2. Leaf (file)**

\`\`\`csharp
namespace CompositeExample;
public class FileNode : IFileSystemNode {
    public string Name { get; }
    private readonly int _size;
    public FileNode(string name, int size) { Name = name; _size = size; }
    public int GetSize() => _size;
}
\`\`\`

**3. Composite (folder)**

\`\`\`csharp
namespace CompositeExample;
public class FolderNode : IFileSystemNode {
    public string Name { get; }
    private readonly List<IFileSystemNode> _children = new();
    public FolderNode(string name) => Name = name;
    public void Add(IFileSystemNode node) => _children.Add(node);
    public int GetSize() => _children.Sum(c => c.GetSize());
}
\`\`\`

**4. Usage**

\`\`\`csharp
var root = new FolderNode("root");
root.Add(new FileNode("a.txt", 100));
var sub = new FolderNode("sub");
sub.Add(new FileNode("b.txt", 200));
root.Add(sub);
Console.WriteLine(root.GetSize()); // 300
\`\`\`

**How this code fits together:** The client works with **IFileSystemNode**. A **FileNode** returns its size; a **FolderNode** sums the sizes of its children. You build the tree by adding nodes to folders. The same \`GetSize()\` call works on any node—uniform treatment of leaf and composite.

**When to use Composite:** Use when you have a **part–whole hierarchy** and want to treat leaves and containers the same way (single interface, recursive operations). Avoid when the tree is shallow or when leaves and composites have very different operations—consider separate types then.

---

## Decorator pattern

### What it is and when to use it

**Decorator** adds **responsibilities to an object dynamically** without subclassing. You wrap the object in a decorator that implements the same interface, delegates to the inner object, and adds behavior before/after. Use it for logging, caching, retries, validation, and cross-cutting concerns; compose at runtime via DI.

### Class structure

\`\`\`mermaid
classDiagram
    class IComponent {
        <<interface>>
        +Operation()
    }
    class ConcreteComponent {
        +Operation()
    }
    class Decorator {
        #IComponent _inner
        +Operation()
    }
    class ConcreteDecoratorA {
        +Operation()
    }
    ConcreteComponent ..|> IComponent
    Decorator ..|> IComponent
    ConcreteDecoratorA --|> Decorator
    Decorator --> IComponent : wraps
    classDef interface fill:#e0e7ff,stroke:#6366f1,stroke-width:2,color:#4338ca
    classDef concrete fill:#dbeafe,stroke:#3b82f6,stroke-width:2,color:#1e40af
    classDef decorator fill:#d1fae5,stroke:#059669,stroke-width:2,color:#065f46
    class IComponent:::interface
    class ConcreteComponent:::concrete
    class Decorator:::decorator
    class ConcreteDecoratorA:::decorator
\`\`\`

**Class structure explained:** **IComponent** is the common interface. **ConcreteComponent** is the core implementation. **Decorator** implements IComponent, holds an IComponent (\`_inner\`), and in \`Operation()\` typically calls \`_inner.Operation()\` and adds behavior (e.g. log before/after). **ConcreteDecoratorA** is a concrete decorator (e.g. logging). You can stack decorators (e.g. Logging(Caching(Core))).

### Full working example: Logging decorator for order service

**1. Interface and core implementation**

\`\`\`csharp
namespace DecoratorExample;
public interface IOrderService { Task<Order> GetByIdAsync(string id); }
public record Order(string Id, decimal Total);
public class OrderService : IOrderService {
    public async Task<Order> GetByIdAsync(string id) =>
        await Task.FromResult(new Order(id, 99m));
}
\`\`\`

**2. Logging decorator**

\`\`\`csharp
namespace DecoratorExample;
public class LoggingOrderService : IOrderService {
    private readonly IOrderService _inner;
    private readonly Action<string> _log;
    public LoggingOrderService(IOrderService inner, Action<string> log) { _inner = inner; _log = log; }
    public async Task<Order> GetByIdAsync(string id) {
        _log($"GetByIdAsync({id})");
        var order = await _inner.GetByIdAsync(id);
        _log("GetByIdAsync done");
        return order;
    }
}
\`\`\`

**3. Usage**

\`\`\`csharp
IOrderService svc = new LoggingOrderService(new OrderService(), Console.WriteLine);
var order = await svc.GetByIdAsync("O1");
\`\`\`

**How this code fits together:** The client depends on **IOrderService**. You wrap the core **OrderService** in **LoggingOrderService**; the decorator delegates to \`_inner.GetByIdAsync\` and logs. In DI you register the decorator wrapping the core so the same interface is used everywhere.

**When to use Decorator:** Use when you need to **add behavior at runtime** (logging, caching, retry, validation) without changing the core type and without a fixed inheritance tree. Avoid when you have only one fixed wrapper—a simple wrapper class may suffice.

---

## Facade pattern

### What it is and when to use it

**Facade** provides a **simple interface** to a complex subsystem. One entry point hides multiple dependencies and the order of operations. Use it for order placement (inventory + payment + shipping), onboarding flows, report generation, and any multi-step workflow where callers need one high-level operation.

### Class structure

\`\`\`mermaid
classDiagram
    class Facade {
        -SubsystemA _a
        -SubsystemB _b
        -SubsystemC _c
        +Operation()
    }
    class SubsystemA {
        +DoA()
    }
    class SubsystemB {
        +DoB()
    }
    class SubsystemC {
        +DoC()
    }
    Facade --> SubsystemA : uses
    Facade --> SubsystemB : uses
    Facade --> SubsystemC : uses
    classDef facade fill:#dbeafe,stroke:#3b82f6,stroke-width:2,color:#1e40af
    classDef concrete fill:#d1fae5,stroke:#059669,stroke-width:2,color:#065f46
    class Facade:::facade
    class SubsystemA:::concrete
    class SubsystemB:::concrete
    class SubsystemC:::concrete
\`\`\`

**Class structure explained:** The **Facade** holds references to **subsystem** types (A, B, C) and exposes one or a few high-level methods (e.g. \`PlaceOrder\`). Inside, it calls \`_a.DoA()\`, \`_b.DoB()\`, \`_c.DoC()\` in the right order and handles errors. Callers depend only on the Facade, not on the subsystems.

### Full working example: Order placement facade

**1. Subsystems**

\`\`\`csharp
namespace FacadeExample;
public interface IInventoryService { Task ReserveAsync(string sku, int qty); }
public interface IPaymentService { Task ChargeAsync(decimal amount); }
public interface IShippingService { Task ScheduleAsync(string address); }
\`\`\`

**2. Facade**

\`\`\`csharp
namespace FacadeExample;
public class OrderFacade {
    private readonly IInventoryService _inv;
    private readonly IPaymentService _pay;
    private readonly IShippingService _ship;
    public OrderFacade(IInventoryService inv, IPaymentService pay, IShippingService ship) {
        _inv = inv; _pay = pay; _ship = ship;
    }
    public async Task PlaceOrderAsync(string sku, int qty, decimal amount, string address) {
        await _inv.ReserveAsync(sku, qty);
        await _pay.ChargeAsync(amount);
        await _ship.ScheduleAsync(address);
    }
}
\`\`\`

**How this code fits together:** The client calls \`PlaceOrderAsync\` once. The **Facade** coordinates inventory, payment, and shipping in sequence. The client does not know about the three subsystems or the order of calls.

**When to use Facade:** Use when you want **one simple entry point** to a set of related types or steps. Avoid when callers need fine-grained control over each step—expose the subsystems or use a different abstraction.

---

## Flyweight pattern

### What it is and when to use it

**Flyweight** uses **sharing** to support large numbers of fine-grained objects efficiently. **Intrinsic state** (shared, immutable) is stored in the flyweight; **extrinsic state** (varying per use) is passed in by the client. Use it for character glyphs, repeated icons, shared configuration, or any time many objects share the same underlying data.

### Class structure

\`\`\`mermaid
classDiagram
    class Flyweight {
        <<interface>>
        +Operation(extrinsic)
    }
    class ConcreteFlyweight {
        -intrinsicState
        +Operation(extrinsic)
    }
    class FlyweightFactory {
        -cache
        +GetFlyweight(key)
    }
    FlyweightFactory --> ConcreteFlyweight : creates, caches
    ConcreteFlyweight ..|> Flyweight
    classDef interface fill:#e0e7ff,stroke:#6366f1,stroke-width:2,color:#4338ca
    classDef flyweight fill:#fef3c7,stroke:#d97706,stroke-width:2,color:#92400e
    classDef factory fill:#dbeafe,stroke:#3b82f6,stroke-width:2,color:#1e40af
    class Flyweight:::interface
    class ConcreteFlyweight:::flyweight
    class FlyweightFactory:::factory
\`\`\`

**Class structure explained:** **Flyweight** holds **intrinsic state** (shared, immutable). **FlyweightFactory** returns a flyweight for a given key (e.g. character code), creating and caching it. The client passes **extrinsic state** (e.g. position, color) into \`Operation\` each time. Many logical "objects" share few flyweight instances.

### Full working example: Character glyph cache

**1. Flyweight and factory**

\`\`\`csharp
namespace FlyweightExample;
public class CharGlyph {
    private readonly char _char;
    public CharGlyph(char c) => _char = c;
    public void Draw(int x, int y) { /* draw _char at (x,y) */ }
}
public class GlyphFactory {
    private readonly Dictionary<char, CharGlyph> _cache = new();
    public CharGlyph GetGlyph(char c) {
        if (!_cache.TryGetValue(c, out var g)) { g = new CharGlyph(c); _cache[c] = g; }
        return g;
    }
}
\`\`\`

**2. Usage**

\`\`\`csharp
var factory = new GlyphFactory();
factory.GetGlyph('A').Draw(0, 0);
factory.GetGlyph('A').Draw(10, 0);  // same instance reused
\`\`\`

**How this code fits together:** **GlyphFactory** ensures one **CharGlyph** per character. The client calls \`GetGlyph(c)\` and then \`Draw(x, y)\` with position (extrinsic). Many uses of 'A' share one CharGlyph instance.

**When to use Flyweight:** Use when you have **many objects** that share **large amounts of identical state** and you want to reduce memory. Avoid when objects do not share state or when the factory lookup cost outweighs savings.

---

## Proxy pattern

### What it is and when to use it

**Proxy** provides a **surrogate or placeholder** for another object. Use it for **lazy loading** (create real object on first use), **access control** (check permissions before delegating), **caching** (return cached result), **remoting** (local stub for remote object), or **logging** (log then delegate). The client uses the same interface as the real subject.

### Class structure

\`\`\`mermaid
classDiagram
    class ISubject {
        <<interface>>
        +Request()
    }
    class RealSubject {
        +Request()
    }
    class Proxy {
        -RealSubject _real
        -Func~RealSubject~ _factory
        +Request()
    }
    RealSubject ..|> ISubject
    Proxy ..|> ISubject
    Proxy --> RealSubject : uses or creates
    classDef interface fill:#e0e7ff,stroke:#6366f1,stroke-width:2,color:#4338ca
    classDef concrete fill:#dbeafe,stroke:#3b82f6,stroke-width:2,color:#1e40af
    classDef proxy fill:#d1fae5,stroke:#059669,stroke-width:2,color:#065f46
    class ISubject:::interface
    class RealSubject:::concrete
    class Proxy:::proxy
\`\`\`

**Class structure explained:** **ISubject** is the interface. **RealSubject** does the real work. **Proxy** implements ISubject, holds a reference to RealSubject (or a factory), and in \`Request()\` may create the real object (lazy), check access, cache, or log, then delegate to the real subject.

### Full working example: Lazy report proxy

**1. Subject and real implementation**

\`\`\`csharp
namespace ProxyExample;
public interface IReport { byte[] Generate(); }
public class HeavyReport : IReport {
    public byte[] Generate() => new byte[1000]; // expensive
}
\`\`\`

**2. Lazy proxy**

\`\`\`csharp
namespace ProxyExample;
public class LazyReportProxy : IReport {
    private IReport _real;
    private readonly Func<IReport> _factory;
    public LazyReportProxy(Func<IReport> factory) => _factory = factory;
    public byte[] Generate() => (_real ??= _factory()).Generate();
}
\`\`\`

**3. Usage**

\`\`\`csharp
var proxy = new LazyReportProxy(() => new HeavyReport());
// HeavyReport not created yet
byte[] data = proxy.Generate(); // creates HeavyReport, then generates
\`\`\`

**How this code fits together:** The client holds an **IReport**. **LazyReportProxy** defers creating **HeavyReport** until \`Generate()\` is first called; subsequent calls reuse the same instance. The client does not know whether it has the real object or the proxy.

**When to use Proxy:** Use when you need **lazy initialization**, **access control**, **caching**, or **remoting** while keeping the same interface as the real object. Avoid when you do not need indirection—use the real type directly.

---

## Comparison: when to use which

| Pattern | Use when | Avoid when |
|--------|----------|------------|
| **Adapter** | Legacy/third-party has different interface | You control both sides |
| **Bridge** | Abstraction and implementation vary independently | Single implementation or abstraction |
| **Composite** | Part–whole tree; uniform treatment of leaf and composite | Shallow tree or very different operations |
| **Decorator** | Add behavior at runtime without subclassing | Single fixed wrapper |
| **Facade** | One simple entry point to a subsystem | Callers need fine-grained control |
| **Flyweight** | Many objects share large identical state | No shared state or small object count |
| **Proxy** | Lazy load, access control, cache, remoting | No need for indirection |

---

## Common pitfalls

- **Adapter:** Making the adapter too thick (business logic). Keep it as a thin translation layer.
- **Bridge:** Confusing with Adapter. Bridge separates abstraction from implementation; Adapter changes an interface to match another.
- **Composite:** Letting leaves implement add/remove and throw, or forgetting to treat leaf and composite uniformly.
- **Decorator:** Forgetting to delegate to the inner object, or creating circular decorator chains.
- **Facade:** Letting the facade become a god object; keep it a thin coordinator.
- **Flyweight:** Storing extrinsic state in the flyweight; pass it in per call.
- **Proxy:** Proxying when a simple wrapper or lazy field would suffice.

---
---

## Position & Rationale

I apply **structural patterns** when they solve a concrete composition or interface problem—Adapter when I must integrate a type I can’t change, Decorator when I need to add behaviour without subclassing, Facade when I want a single entry point to a subsystem, Proxy when I need lazy loading or access control. I avoid using a pattern when a simple wrapper, interface, or helper would do; I don’t add Bridge or Composite for hypothetical future variation. I prefer **Decorator** over deep inheritance for cross-cutting behaviour (e.g. logging, caching). I use **Adapter** to wrap legacy or third-party APIs so the rest of the app depends on our interface. I keep **Facade** thin so it doesn’t become a god object. I reject applying Flyweight or Proxy when there’s no real sharing or access-control need—they add indirection without payoff.

---

## Trade-Offs & Failure Modes

- **What this sacrifices:** Each pattern adds types and indirection; over-use makes the codebase harder to follow. Adapter and Facade can hide design debt instead of fixing it.
- **Where it degrades:** When we use a pattern "because the book says so" without a clear problem—e.g. Bridge when we have one implementation, Composite when we never have a tree. Decorator chains can get deep and hard to debug.
- **How it fails when misapplied:** Adapter wrapping something we could refactor; Facade becoming a dump of all subsystem calls; Flyweight when there’s no meaningful shared state; Proxy when a lazy field or simple check would suffice.
- **Early warning signs:** "We added three layers and now we don’t know where the bug is"; "the facade has 50 methods"; "we use Proxy everywhere."

---

## What Most Guides Miss

Guides often show one pattern in isolation and don’t help you **choose**. In practice, Adapter vs Facade vs Decorator depends on whether you’re adapting an external type, simplifying a subsystem, or adding behaviour. **Composite** is easy to over-engineer when you don’t actually have a recursive structure. **Bridge** is rarely needed with one implementation—wait for a real abstraction/implementation split. **Flyweight** only pays off when you have many objects sharing significant intrinsic state; otherwise it’s ceremony. The "when not to use" and the cost of indirection are underplayed.

---

## Decision Framework

- **If you need to use a type you can’t change** → Adapter; expose the interface your app needs.
- **If you need to add behaviour without subclassing** → Decorator; keep the chain shallow and each decorator focused.
- **If you need a single entry point to a complex subsystem** → Facade; keep it thin, no business logic.
- **If you have a recursive part-whole structure** → Composite; otherwise avoid.
- **If you need lazy loading or access control** → Proxy; otherwise a lazy field or guard may be enough.
- **If you have many objects sharing heavy intrinsic state** → Flyweight; otherwise skip.
- **If abstraction and implementation vary independently** → Bridge; if only one implementation, wait.

---

## Key Takeaways

- Use structural patterns for real composition problems: Adapter for integration, Decorator for behaviour, Facade for subsystems, Proxy for lazy/access control.
- Avoid over-application: no Bridge with one implementation, no Composite without a tree, no Flyweight without shared state.
- Keep Facade thin; keep Decorator chains focused. Revisit when the problem shape changes.


## Summary

Structural patterns in .NET—**Adapter**, **Bridge**, **Composite**, **Decorator**, **Facade**, **Flyweight**, and **Proxy**—address how types and objects are composed. This article covered all seven with class diagrams, full C# examples, and when to use each. Use the definitions and code above in your solutions; combine with DI and your domain as needed.

---

## When I Would Use This Again — and When I Wouldn't

I would use structural patterns again when I have a clear composition or interface problem—integrating a legacy API (Adapter), adding cross-cutting behaviour without subclassing (Decorator), simplifying a subsystem (Facade), or controlling access or lazy loading (Proxy). I wouldn’t use Bridge until I have at least two implementation families; I wouldn’t use Composite without a real tree structure; I wouldn’t use Flyweight without many objects sharing significant state. For simple wrappers or one-off helpers, I’d skip the pattern. If the team finds the indirection confusing, I’d simplify to the minimal structure that solves the problem.


---

## Frequently Asked Questions

### What is Adapter?

Adapter wraps an existing interface so it matches the interface the client expects. Use when integrating legacy or third-party code.

### What is Bridge?

Bridge separates abstraction from implementation so both can vary independently. Use when you have multiple abstraction types and multiple implementations.

### What is Composite?

Composite composes objects into tree structures so you can treat individual objects and compositions uniformly. Use for UI trees, file systems, expression trees.

### What is Decorator?

Decorator adds responsibilities to an object dynamically without subclassing. Use for logging, caching, retries, validation.

### What is Facade?

Facade provides a simple interface to a complex subsystem. Use for order placement, onboarding, multi-step workflows.

### What is Flyweight?

Flyweight uses sharing to support many fine-grained objects efficiently. Intrinsic state is in the flyweight; extrinsic state is passed in. Use for character glyphs, repeated icons.

### What is Proxy?

Proxy provides a surrogate for another object. Use for lazy loading, access control, caching, remoting.

### When use Adapter vs Facade?

Adapter **converts** one interface to another. Facade **simplifies** a subsystem with one entry point. Both wrap; Adapter changes interface, Facade hides complexity.

### When use Decorator vs inheritance?

Decorator adds behavior at **runtime** by wrapping. Inheritance adds behavior at **compile time**. Use Decorator when you need to compose multiple behaviors (e.g. logging + caching).

### Adapter vs Decorator?

Adapter **changes** the interface of the wrapped object. Decorator **implements the same** interface and adds behavior. Both wrap; different goals.

### How implement Decorator in .NET?

Create a class that implements the same interface as the inner component, inject the inner via constructor, delegate calls to it, and add your behavior (e.g. log before/after). Register in DI: decorator wrapping core.

### Proxy: virtual vs protection?

**Virtual proxy** creates the real object on first use (lazy load). **Protection proxy** checks permissions before delegating. Same pattern, different intent.

### Flyweight: intrinsic vs extrinsic?

**Intrinsic** state is shared and stored in the flyweight (e.g. character code). **Extrinsic** state varies per use and is passed in by the client (e.g. position, color).`,
  faqs: [
  {
    "question": "What is Adapter?",
    "answer": "Wraps existing interface to match expected interface. Legacy/third-party integration."
  },
  {
    "question": "What is Bridge?",
    "answer": "Separates abstraction from implementation so both can vary independently."
  },
  {
    "question": "What is Composite?",
    "answer": "Composes objects into trees; treat leaf and composite uniformly."
  },
  {
    "question": "What is Decorator?",
    "answer": "Adds behavior dynamically without subclassing. Logging, caching, retries."
  },
  {
    "question": "What is Facade?",
    "answer": "Simple interface to complex subsystem. One entry point."
  },
  {
    "question": "What is Flyweight?",
    "answer": "Shares state between many similar objects to save memory."
  },
  {
    "question": "What is Proxy?",
    "answer": "Placeholder or control access. Lazy load, access control, caching."
  },
  {
    "question": "When use Adapter?",
    "answer": "Legacy APIs, external SDKs, different data shapes."
  },
  {
    "question": "When use Bridge?",
    "answer": "Multiple abstraction types and implementations; avoid subclass explosion."
  },
  {
    "question": "When use Composite?",
    "answer": "Part–whole trees: UI, file system, expression trees."
  },
  {
    "question": "When use Decorator?",
    "answer": "Add logging, caching, validation without changing core type."
  },
  {
    "question": "When use Facade?",
    "answer": "Order placement, onboarding, multi-step workflows."
  },
  {
    "question": "When use Flyweight?",
    "answer": "Many objects share large identical state (glyphs, icons)."
  },
  {
    "question": "When use Proxy?",
    "answer": "Lazy-loaded reports, access control, caching wrappers."
  },
  {
    "question": "Adapter vs Facade?",
    "answer": "Adapter converts interface. Facade simplifies subsystem."
  },
  {
    "question": "Adapter vs Decorator?",
    "answer": "Adapter changes interface. Decorator keeps same interface and adds behavior."
  },
  {
    "question": "Decorator vs inheritance?",
    "answer": "Decorator adds at runtime by wrapping. Inheritance at compile time."
  },
  {
    "question": "How implement Decorator in .NET?",
    "answer": "Wrapper class implementing same interface. Delegate to inner. Compose in DI."
  },
  {
    "question": "Proxy: virtual vs protection?",
    "answer": "Virtual proxy: lazy load. Protection proxy: access control."
  },
  {
    "question": "Flyweight: intrinsic vs extrinsic?",
    "answer": "Intrinsic = shared state in flyweight. Extrinsic = passed in per use."
  }
]
}
