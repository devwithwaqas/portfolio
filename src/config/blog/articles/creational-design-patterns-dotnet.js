/**
 * Blog article: creational-design-patterns-dotnet
 * Auto-generated by scripts/split-blog-articles.js. Do not edit the content here by hand if you run the split script again.
 */

export default {
  slug: "creational-design-patterns-dotnet",
  title: "Creational Design Patterns in .NET: All 5 Patterns with Full Working Code",
  excerpt: "All five GoF creational patterns in .NET: Factory Method, Abstract Factory, Builder, Prototype, Singleton. Class diagrams, full C# examples, and when to use each.",
  date: "2024-07-23",
  topic: "Architecture",
  keywords: ["Creational Design Patterns in .NET: All 5 Patterns with Full Working Code", "Creational Design Patterns Dotnet", "Creational Design Patterns Dotnet best practices", "how to creational design patterns dotnet", "creational design patterns dotnet in .NET", "creational design patterns dotnet guide", "creational design patterns dotnet for enterprise", "creational design patterns dotnet patterns", "when to use creational design patterns dotnet", "creational design patterns dotnet tutorial", "creational design patterns dotnet examples", "creational design patterns dotnet in C#", "creational design patterns dotnet overview", "creational design patterns dotnet implementation", "understanding creational design patterns dotnet", "creational design patterns dotnet for developers", "creational design patterns dotnet checklist", "creational design patterns dotnet tips", "creational design patterns dotnet deep dive", "creational design patterns dotnet comparison", "creational design patterns dotnet vs alternatives", "creational design patterns dotnet .NET Core", "creational design patterns dotnet Azure", "creational design patterns dotnet explained", "creational design patterns dotnet when to use", "creational design patterns dotnet enterprise", "creational design patterns dotnet .NET", "what is creational design patterns dotnet", "creational design patterns dotnet summary", "creational design patterns dotnet introduction", "creational design patterns dotnet fundamentals", "creational design patterns dotnet step by step", "creational design patterns dotnet complete guide", "creational design patterns dotnet for beginners", "creational design patterns dotnet advanced", "creational design patterns dotnet production", "creational design patterns dotnet real world", "creational design patterns dotnet example code", "creational design patterns dotnet C# example", "creational design patterns dotnet .NET example", "learn creational design patterns dotnet", "creational design patterns dotnet learn", "creational design patterns dotnet reference", "creational design patterns dotnet cheat sheet", "creational design patterns dotnet pitfalls", "creational design patterns dotnet common mistakes", "creational design patterns dotnet performance", "creational design patterns dotnet optimization", "creational design patterns dotnet security", "creational design patterns dotnet testing", "creational design patterns dotnet unit test", "creational design patterns dotnet integration", "creational design patterns dotnet migration", "creational design patterns dotnet from scratch", "creational design patterns dotnet 2024", "creational design patterns dotnet 2025", "best creational design patterns dotnet", "creational design patterns dotnet best", "pro creational design patterns dotnet", "creational design patterns dotnet expert", "creational design patterns dotnet consultant", "creational design patterns dotnet services", "creational design patterns dotnet course", "creational design patterns dotnet workshop", "creational design patterns dotnet webinar", "creational design patterns dotnet blog", "creational design patterns dotnet article", "creational design patterns dotnet post", "why creational design patterns dotnet", "when creational design patterns dotnet", "where creational design patterns dotnet", "creational design patterns dotnet in .NET 6", "creational design patterns dotnet in .NET 7", "creational design patterns dotnet in .NET 8", "creational design patterns dotnet for C#", "creational design patterns dotnet for Angular", "creational design patterns dotnet for Vue", "creational design patterns dotnet for React", "creational design patterns dotnet for Azure", "creational design patterns dotnet for microservices", "creational design patterns dotnet for API", "creational design patterns dotnet for database", "creational design patterns dotnet for testing", "creational design patterns dotnet for DevOps", "creational design patterns dotnet for senior developers", "creational design patterns dotnet for team", "creational design patterns dotnet for production", "creational design patterns dotnet for scale", "creational design patterns dotnet for refactoring", "creational design patterns dotnet for enterprise applications", "creational design patterns dotnet for startup", "creational design patterns dotnet in 2024", "creational design patterns dotnet in 2025", "creational design patterns dotnet in 2026", "creational design patterns dotnet code sample", "creational design patterns dotnet code example", "creational design patterns dotnet sample code", "creational design patterns dotnet full example", "creational design patterns dotnet working example", "creational design patterns dotnet practical creational design patterns dotnet", "creational design patterns dotnet real world example", "creational design patterns dotnet use case", "creational design patterns dotnet use cases", "creational design patterns dotnet scenario", "creational design patterns dotnet scenarios", "creational design patterns dotnet pattern", "creational design patterns dotnet approach", "creational design patterns dotnet approaches", "creational design patterns dotnet strategy", "creational design patterns dotnet strategies", "creational design patterns dotnet technique", "creational design patterns dotnet techniques", "creational design patterns dotnet method", "creational design patterns dotnet methods", "creational design patterns dotnet solution", "creational design patterns dotnet solutions", "creational design patterns dotnet implementation guide", "creational design patterns dotnet getting started", "creational design patterns dotnet quick start", "creational design patterns dotnet overview guide", "creational design patterns dotnet comprehensive guide", "creational design patterns dotnet detailed guide", "creational design patterns dotnet practical guide", "creational design patterns dotnet developer guide", "creational design patterns dotnet engineer guide", "creational design patterns dotnet architect guide", "creational design patterns dotnet for architects", "creational design patterns dotnet for backend", "creational design patterns dotnet for tech leads", "creational design patterns dotnet for senior devs", "benefits of creational design patterns dotnet", "advantages of creational design patterns dotnet", "alternatives to creational design patterns dotnet", "compared to creational design patterns dotnet", "intro to creational design patterns dotnet", "basics of creational design patterns dotnet", "creational design patterns dotnet tips and tricks", "creational design patterns dotnet production-ready", "creational design patterns dotnet enterprise-grade", "creational design patterns dotnet with Docker", "creational design patterns dotnet with Kubernetes", "creational design patterns dotnet in ASP.NET Core", "creational design patterns dotnet with Entity Framework", "creational design patterns dotnet with EF Core", "creational design patterns dotnet modern", "creational design patterns dotnet updated", "creational design patterns dotnet latest", "creational design patterns dotnet walkthrough", "creational design patterns dotnet hands-on", "creational design patterns dotnet practical examples", "creational design patterns dotnet real-world examples", "creational design patterns dotnet common pitfalls", "creational design patterns dotnet gotchas", "creational design patterns dotnet FAQ", "creational design patterns dotnet FAQs", "creational design patterns dotnet Q&A", "creational design patterns dotnet interview questions", "creational design patterns dotnet interview", "creational design patterns dotnet certification", "creational design patterns dotnet training", "creational design patterns dotnet video", "creational design patterns dotnet series", "creational design patterns dotnet part 1", "creational design patterns dotnet core concepts", "creational design patterns dotnet key concepts", "creational design patterns dotnet recap", "creational design patterns dotnet takeaways", "creational design patterns dotnet conclusion", "creational design patterns dotnet next steps", "creational design patterns dotnet further reading", "creational design patterns dotnet resources", "creational design patterns dotnet tools", "creational design patterns dotnet libraries", "creational design patterns dotnet frameworks", "creational design patterns dotnet NuGet", "creational design patterns dotnet package", "creational design patterns dotnet GitHub", "creational design patterns dotnet open source", "creational design patterns dotnet community", "creational design patterns dotnet Microsoft docs", "creational design patterns dotnet documentation", "creational design patterns dotnet official guide", "creational design patterns dotnet official tutorial", "creational design patterns with .NET Core", "creational design patterns dotnet ASP.NET Core", "Creational", "Creational guide", "Creational tutorial", "Creational best practices", "Creational in .NET", "Creational in C#", "Creational for developers", "Creational examples", "Creational patterns", "Creational overview", "Creational introduction", "Creational deep dive", "Creational explained", "Creational how to", "Creational what is", "Creational when to use", "Creational for enterprise", "Creational .NET Core", "Creational Azure", "Creational C#", "Creational with .NET", "Creational with C#", "Creational with Azure", "Creational with Angular", "Creational with Vue", "Creational with React", "Creational with Entity Framework", "Creational with SQL Server", "Creational step by step", "Creational complete guide", "Creational from scratch", "Creational 2024", "Creational 2025", "Creational 2026", "Creational code example", "Creational sample code", "Creational implementation", "Creational real world", "Creational production", "Creational for beginners", "Creational advanced", "Creational for architects", "Creational for backend", "Creational for API", "Creational in ASP.NET Core", "Creational with EF Core", "Creational tutorial 2024", "Creational guide 2025", "Creational best practices 2024", "Creational C# examples", "Creational .NET examples", "Creational implementation guide", "Creational how to implement", "Creational benefits", "Creational advantages", "Creational pitfalls", "Creational alternatives", "Creational compared", "Creational intro", "Creational basics", "Creational tips and tricks", "Creational production-ready", "Creational enterprise-grade", "Creational maintainable", "Creational testable", "Creational refactoring", "Creational modern", "Creational updated", "Creational latest", "Creational for tech leads", "Creational for senior devs", "Creational with Docker", "Creational with Kubernetes", "Creational in .NET 8", "Creational in .NET 7", "Creational in .NET 6", "Creational Design", "Creational Design guide", "Creational Design tutorial", "Creational Design best practices", "Creational Design in .NET", "Creational Design in C#", "Creational Design for developers", "Creational Design examples", "Creational Design patterns", "Creational Design overview", "Creational Design introduction", "Creational Design deep dive", "Creational Design explained", "Creational Design how to", "Creational Design what is", "Creational Design when to use", "Creational Design for enterprise", "Creational Design .NET Core", "Creational Design Azure", "Creational Design C#", "Creational Design with .NET", "Creational Design with C#", "Creational Design with Azure", "Creational Design with Angular", "Creational Design with Vue", "Creational Design with React", "Creational Design with Entity Framework", "Creational Design with SQL Server", "Creational Design step by step", "Creational Design complete guide", "Creational Design from scratch", "Creational Design 2024", "Creational Design 2025", "Creational Design 2026", "Creational Design code example", "Creational Design sample code", "Creational Design implementation", "Creational Design real world", "Creational Design production", "Creational Design for beginners", "Creational Design advanced", "Creational Design for architects", "Creational Design for backend", "Creational Design for API", "Creational Design in ASP.NET Core", "Creational Design with EF Core", "Creational Design tutorial 2024", "Creational Design guide 2025", "Creational Design best practices 2024", "Creational Design C# examples", "Creational Design .NET examples", "Creational Design implementation guide", "Creational Design how to implement", "Creational Design benefits", "Creational Design advantages", "Creational Design pitfalls", "Creational Design alternatives", "Creational Design compared", "Creational Design intro", "Creational Design basics", "Creational Design tips and tricks", "Creational Design production-ready", "Creational Design enterprise-grade", "Creational Design maintainable", "Creational Design testable", "Creational Design refactoring", "Creational Design modern", "Creational Design updated", "Creational Design latest", "Creational Design for tech leads", "Creational Design for senior devs", "Creational Design with Docker", "Creational Design with Kubernetes", "Creational Design in .NET 8", "Creational Design in .NET 7", "Creational Design in .NET 6", "Creational Design Patterns guide", "Creational Design Patterns tutorial", "Creational Design Patterns best practices", "Creational Design Patterns in .NET", "Creational Design Patterns in C#", "Creational Design Patterns for developers", "Creational Design Patterns examples", "Creational Design Patterns patterns", "Creational Design Patterns overview", "Creational Design Patterns introduction", "Creational Design Patterns deep dive", "Creational Design Patterns explained", "Creational Design Patterns how to", "Creational Design Patterns what is", "Creational Design Patterns when to use", "Creational Design Patterns for enterprise", "Creational Design Patterns .NET Core", "Creational Design Patterns Azure", "Creational Design Patterns C#", "Creational Design Patterns with .NET", "Creational Design Patterns with C#", "Creational Design Patterns with Azure", "Creational Design Patterns with Angular", "Creational Design Patterns with Vue", "Creational Design Patterns with React", "Creational Design Patterns with Entity Framework", "Creational Design Patterns with SQL Server", "Creational Design Patterns step by step", "Creational Design Patterns complete guide", "Creational Design Patterns from scratch", "Creational Design Patterns 2024", "Creational Design Patterns 2025", "Creational Design Patterns 2026", "Creational Design Patterns code example", "Creational Design Patterns sample code", "Creational Design Patterns implementation", "Creational Design Patterns real world", "Creational Design Patterns production", "Creational Design Patterns for beginners", "Creational Design Patterns advanced", "Creational Design Patterns for architects", "Creational Design Patterns for backend", "Creational Design Patterns for API", "Creational Design Patterns in ASP.NET Core", "Creational Design Patterns with EF Core", "Creational Design Patterns tutorial 2024", "Creational Design Patterns guide 2025", "Creational Design Patterns best practices 2024", "Creational Design Patterns C# examples", "Creational Design Patterns .NET examples", "Creational Design Patterns implementation guide", "Creational Design Patterns how to implement", "Creational Design Patterns benefits", "Creational Design Patterns advantages", "Creational Design Patterns pitfalls", "Creational Design Patterns alternatives", "Creational Design Patterns compared", "Creational Design Patterns intro", "Creational Design Patterns basics", "Creational Design Patterns tips and tricks", "Creational Design Patterns production-ready", "Creational Design Patterns enterprise-grade", "Creational Design Patterns maintainable", "Creational Design Patterns testable", "Creational Design Patterns refactoring", "Creational Design Patterns modern", "Creational Design Patterns updated", "Creational Design Patterns latest", "Creational Design Patterns for tech leads", "Creational Design Patterns for senior devs", "Creational Design Patterns with Docker", "Creational Design Patterns with Kubernetes", "Creational Design Patterns in .NET 8", "Creational Design Patterns in .NET 7", "Creational Design Patterns in .NET 6", "Creational Design Patterns Dotnet how to", "Creational Design Patterns Dotnet what is", "Creational Design Patterns Dotnet C#", "Creational Design Patterns Dotnet with .NET", "Creational Design Patterns Dotnet with C#", "Creational Design Patterns Dotnet with Azure", "Creational Design Patterns Dotnet with Angular", "Creational Design Patterns Dotnet with Vue", "Creational Design Patterns Dotnet with React", "Creational Design Patterns Dotnet with SQL Server", "Creational Design Patterns Dotnet 2026", "Creational Design Patterns Dotnet tutorial 2024", "Creational Design Patterns Dotnet guide 2025", "Creational Design Patterns Dotnet best practices 2024", "Creational Design Patterns Dotnet C# examples", "Creational Design Patterns Dotnet .NET examples", "Creational Design Patterns Dotnet how to implement", "Creational Design Patterns Dotnet benefits", "Creational Design Patterns Dotnet advantages"],
  relatedServices: ["full-stack-development","technical-leadership"],
  relatedProjects: ["bat-inhouse-app"],
  relatedArticleSlugs: ["design-patterns-overview-creational-structural-behavioral","structural-design-patterns-dotnet","behavioral-design-patterns-dotnet","solid-principles-in-practice"],
  author: "Waqas Ahmad",
  content: `## Introduction

This guidance is relevant when the topic of this article applies to your system or design choices; it breaks down when constraints or context differ. I've applied it in real projects and refined the takeaways over time (as of 2026).

**Creational design patterns** deal with **object creation**: how to create objects in a way that suits the situation. Unlike structural patterns (composition) or behavioral patterns (communication), creational patterns are about **deferring creation**, **abstracting construction**, **reusing instances**, and **controlling instantiation**—so client code stays decoupled from concrete types and creation logic. The Gang of Four defines **five** creational patterns; this article covers **all of them** with a clear definition, **when and why to use it**, a **class-structure diagram**, and **full working C# examples**. Each pattern section follows the same order: what it is, when to use it, class diagram with explanation, then complete code and "how it fits together." No backtracking—each pattern is presented in its correct form.

If you are new to creational patterns, start with [All creational patterns at a glance](#all-creational-patterns-at-a-glance) and jump to the pattern you need.

## Topics covered

- [Decision Context](#decision-context)
- [What are creational patterns?](#what-are-creational-patterns)
- [All creational patterns at a glance](#all-creational-patterns-at-a-glance)
- [Factory Method pattern](#factory-method-pattern)
- [Abstract Factory pattern](#abstract-factory-pattern)
- [Builder pattern](#builder-pattern)
- [Prototype pattern](#prototype-pattern)
- [Singleton pattern](#singleton-pattern)
- [Comparison: when to use which](#comparison-when-to-use-which)
- [Common pitfalls](#common-pitfalls)
- [Summary](#summary)
- [Position & Rationale](#position--rationale)
- [Trade-Offs & Failure Modes](#trade-offs--failure-modes)
- [What Most Guides Miss](#what-most-guides-miss)
- [Decision Framework](#decision-framework)
- [Key Takeaways](#key-takeaways)
- [When I Would Use This Again — and When I Wouldn't](#when-i-would-use-this-again--and-when-i-wouldnt)
- [Frequently Asked Questions](#frequently-asked-questions)

## What are creational patterns?

Creational patterns describe **recurring ways to create** objects: delegating creation to a method or subclass (Factory Method), to a family of factories (Abstract Factory), to a step-by-step builder (Builder), by cloning (Prototype), or by ensuring a single instance (Singleton). There are **five** creational patterns; the table below lists all of them.

| Pattern | Problem it solves | Typical .NET use |
|--------|--------------------|------------------|
| **Factory Method** | Client should not depend on concrete product type; creation varies by context | Override factory method in base creator class |
| **Abstract Factory** | Need a family of related products (e.g. Win vs Mac UI) | Interface + concrete factories, register in DI |
| **Builder** | Complex construction, many optional parameters | Fluent builder class with \`Build()\` |
| **Prototype** | Cloning cheaper or safer than \`new\` | \`ICloneable\`, copy constructor, or clone method |
| **Singleton** | Exactly one instance (logger, config, pool) | \`AddSingleton<T>\` in DI; avoid static |

------

## Decision Context

- **System scale:** Applies when object creation is non-trivial (e.g. multiple representations, families of objects, or controlled lifecycle); creational patterns (Singleton, Factory, Builder, Prototype, Abstract Factory) are applied per component or layer.
- **Team size:** One to several teams; someone must recognise when creation logic deserves a pattern so the codebase doesn't scatter \`new\` and construction logic.
- **Time / budget pressure:** Fits when you have time to introduce a factory or builder; overkill for trivial \`new\` in one place.
- **Technical constraints:** .NET and C#; patterns map to static factories, DI, and interfaces; no special framework required.
- **Non-goals:** This article does not optimize for "use every creational pattern everywhere"; it optimises for choosing the right pattern when creation is complex or must be abstracted.


## All creational patterns at a glance

- **Factory Method:** One method creates one product; subclasses override to create concrete products. Use when creation varies by subclass (e.g. PDF vs Word document).
- **Abstract Factory:** A family of factories for related products. Use when you need consistent families (e.g. all Win UI or all Mac UI).
- **Builder:** Separate construction from representation; fluent API with optional steps. Use for complex objects with many optional parameters.
- **Prototype:** Clone an existing instance instead of creating from scratch. Use when cloning is cheaper than \`new\` or you need copies with small variations.
- **Singleton:** Exactly one instance of a class. In .NET prefer DI \`AddSingleton<T>\` so tests can replace it.

---

## Factory Method pattern

### What it is and when to use it

**Factory Method** defines a method that creates an object; subclasses override the method to create **concrete products**. The client depends only on the **creator** abstraction and the **product** interface—never on concrete product types. Use it when **creation varies by context** (e.g. PDF vs Word document, DB vs HTTP connection) and you want to add new product types by adding new creator subclasses, not by changing client code. Typical uses: document/export pipelines, connection creators, serializers, and anywhere one product type is created but the concrete type depends on configuration or subclass.

### Class structure

\`\`\`mermaid
classDiagram
    class Creator {
        <<abstract>>
        +FactoryMethod() IProduct
        +SomeOperation()
    }
    class ConcreteCreatorA {
        +FactoryMethod() IProduct
    }
    class ConcreteCreatorB {
        +FactoryMethod() IProduct
    }
    class IProduct {
        <<interface>>
        +Operation()
    }
    class ConcreteProductA {
        +Operation()
    }
    class ConcreteProductB {
        +Operation()
    }
    Creator <|-- ConcreteCreatorA
    Creator <|-- ConcreteCreatorB
    Creator ..> IProduct : creates
    IProduct <|.. ConcreteProductA
    IProduct <|.. ConcreteProductB
    ConcreteCreatorA ..> ConcreteProductA : creates
    ConcreteCreatorB ..> ConcreteProductB : creates
    classDef interface fill:#e0e7ff,stroke:#6366f1,stroke-width:2,color:#4338ca
    classDef creator fill:#dbeafe,stroke:#2563eb,stroke-width:2,color:#1d4ed8
    classDef product fill:#d1fae5,stroke:#059669,stroke-width:2,color:#065f46
    class IProduct:::interface
    class Creator:::creator
    class ConcreteCreatorA:::creator
    class ConcreteCreatorB:::creator
    class ConcreteProductA:::product
    class ConcreteProductB:::product
\`\`\`

**Class structure explained:** The **Creator** (abstract base) declares \`FactoryMethod()\` returning **IProduct**; it may also call that method in \`SomeOperation()\`. **ConcreteCreatorA** and **ConcreteCreatorB** override \`FactoryMethod()\` to return **ConcreteProductA** and **ConcreteProductB** respectively. The client uses only Creator and IProduct—so adding a new product means adding a new creator subclass and new product class, without touching existing client code.

### Full working example: Document export pipeline

**1. Product interface and concrete products**

\`\`\`csharp
namespace FactoryMethodExample;
public interface IDocument { byte[] Export(); }
public class PdfDocument : IDocument { public byte[] Export() => /* render PDF */ Array.Empty<byte>(); }
public class WordDocument : IDocument { public byte[] Export() => /* render Word */ Array.Empty<byte>(); }
\`\`\`

**2. Creator (abstract) and concrete creators**

\`\`\`csharp
namespace FactoryMethodExample;
public abstract class DocumentCreator {
    public abstract IDocument CreateDocument();
    public byte[] Export(string data) {
        var doc = CreateDocument();
        return doc.Export();
    }
}
public class PdfCreator : DocumentCreator {
    public override IDocument CreateDocument() => new PdfDocument();
}
public class WordCreator : DocumentCreator {
    public override IDocument CreateDocument() => new WordDocument();
}
\`\`\`

**3. Client using only creator abstraction**

\`\`\`csharp
DocumentCreator creator = new PdfCreator();
byte[] bytes = creator.Export("data");
\`\`\`

**How this code fits together:** The client holds a **DocumentCreator** and calls \`Export\` (or \`CreateDocument\` directly). The creator’s **Factory Method** (\`CreateDocument\`) is overridden in **PdfCreator** and **WordCreator** to return the right **IDocument** implementation. The client never references PdfDocument or WordDocument—only the creator type and IDocument. Adding Excel is done by adding ExcelDocument and ExcelCreator.

**When to use Factory Method:** Use when you have **one product type** (e.g. IDocument) but **creation varies by context or subclass** and you want the client decoupled from concrete products. Avoid when you need families of related products (use Abstract Factory) or when construction is complex and stepwise (use Builder).

---

## Abstract Factory pattern

### What it is and when to use it

**Abstract Factory** provides an interface for creating **families of related products** (e.g. Win button + Win text box, or Mac button + Mac text box). Concrete factories implement that interface and produce consistent families. Use it when you have **multiple product types** that must be used together (e.g. UI theme: all Win or all Mac) and you want to avoid mixing products from different families. Typical uses: UI themes (Win/Mac/Linux), cross-platform widgets, database drivers (SQL Server vs PostgreSQL), and product families (modern vs legacy API clients).

### Class structure

\`\`\`mermaid
classDiagram
    class IAbstractFactory {
        <<interface>>
        +CreateProductA() IProductA
        +CreateProductB() IProductB
    }
    class ConcreteFactory1 {
        +CreateProductA() IProductA
        +CreateProductB() IProductB
    }
    class ConcreteFactory2 {
        +CreateProductA() IProductA
        +CreateProductB() IProductB
    }
    class IProductA {
        <<interface>>
    }
    class IProductB {
        <<interface>>
    }
    IAbstractFactory <|.. ConcreteFactory1
    IAbstractFactory <|.. ConcreteFactory2
    ConcreteFactory1 ..> IProductA : creates
    ConcreteFactory1 ..> IProductB : creates
    ConcreteFactory2 ..> IProductA : creates
    ConcreteFactory2 ..> IProductB : creates
    classDef interface fill:#e0e7ff,stroke:#6366f1,stroke-width:2,color:#4338ca
    classDef factory fill:#dbeafe,stroke:#2563eb,stroke-width:2,color:#1d4ed8
    classDef product fill:#d1fae5,stroke:#059669,stroke-width:2,color:#065f46
    class IAbstractFactory:::interface
    class IProductA:::interface
    class IProductB:::interface
    class ConcreteFactory1:::factory
    class ConcreteFactory2:::factory
\`\`\`

**Class structure explained:** **IAbstractFactory** declares methods that create **IProductA** and **IProductB**. **ConcreteFactory1** and **ConcreteFactory2** implement the interface and return concrete products from their respective families (e.g. Win vs Mac). The client receives an IAbstractFactory (e.g. via DI) and calls \`CreateProductA()\` and \`CreateProductB()\`; it never sees concrete product classes, and swapping the factory swaps the whole family.

### Full working example: UI factory (Win vs Mac)

**1. Product interfaces and concrete products**

\`\`\`csharp
namespace AbstractFactoryExample;
public interface IButton { string Render(); }
public interface ITextBox { string Render(); }
public class WinButton : IButton { public string Render() => "WinButton"; }
public class WinTextBox : ITextBox { public string Render() => "WinTextBox"; }
public class MacButton : IButton { public string Render() => "MacButton"; }
public class MacTextBox : ITextBox { public string Render() => "MacTextBox"; }
\`\`\`

**2. Abstract factory and concrete factories**

\`\`\`csharp
namespace AbstractFactoryExample;
public interface IUiFactory {
    IButton CreateButton();
    ITextBox CreateTextBox();
}
public class WinUiFactory : IUiFactory {
    public IButton CreateButton() => new WinButton();
    public ITextBox CreateTextBox() => new WinTextBox();
}
public class MacUiFactory : IUiFactory {
    public IButton CreateButton() => new MacButton();
    public ITextBox CreateTextBox() => new MacTextBox();
}
\`\`\`

**3. Client and registration**

\`\`\`csharp
IUiFactory factory = new WinUiFactory(); // or from DI: GetRequiredService<IUiFactory>()
var btn = factory.CreateButton();
var box = factory.CreateTextBox();
// btn and box are from same family (Win)
\`\`\`

**How this code fits together:** The client depends only on **IUiFactory**, **IButton**, and **ITextBox**. You register one concrete factory (e.g. WinUiFactory or MacUiFactory) in DI; that factory creates all UI widgets for one theme. Changing the registered factory changes the entire UI family without changing client code.

**When to use Abstract Factory:** Use when you need **families of related products** and callers must not mix products from different families. Avoid when you have only one product type (use Factory Method) or when products are independent (a simple factory or DI may suffice).

---

## Builder pattern

### What it is and when to use it

**Builder** separates the **construction** of a complex object from its **representation**, so the same construction process can create different representations. A **Director** (optional) orchestrates the builder; the **Builder** exposes fluent methods for each step and a \`Build()\` that returns the product. Use it when an object has **many optional parameters** or **stepwise construction** and you want readable, valid construction (e.g. require certain steps, validate as you go). Typical uses: complex DTOs, HTTP request builders, query builders, configuration objects, and any object with many optional or stepwise fields.

### Class structure

\`\`\`mermaid
classDiagram
    class IBuilder {
        <<interface>>
        +BuildPartA()
        +BuildPartB()
        +GetResult() Product
    }
    class ConcreteBuilder {
        -Product _product
        +BuildPartA()
        +BuildPartB()
        +GetResult() Product
    }
    class Director {
        -IBuilder _builder
        +Construct()
    }
    class Product {
        +PartA
        +PartB
    }
    Director --> IBuilder : uses
    ConcreteBuilder ..|> IBuilder
    ConcreteBuilder ..> Product : builds
    classDef interface fill:#e0e7ff,stroke:#6366f1,stroke-width:2,color:#4338ca
    classDef director fill:#dbeafe,stroke:#2563eb,stroke-width:2,color:#1d4ed8
    classDef builder fill:#d1fae5,stroke:#059669,stroke-width:2,color:#065f46
    classDef product fill:#fef3c7,stroke:#d97706,stroke-width:2,color:#92400e
    class IBuilder:::interface
    class Director:::director
    class ConcreteBuilder:::builder
    class Product:::product
\`\`\`

**Class structure explained:** **IBuilder** defines the construction steps and \`GetResult()\`. **ConcreteBuilder** implements those steps and builds a **Product** step by step. The **Director** holds an IBuilder and calls the steps in a fixed order in \`Construct()\`; the client can also call the builder directly for more control. The client gets the product only after calling \`GetResult()\` (or \`Build()\` in fluent style).

### Full working example: Order builder (fluent)

**1. Product (Order)**

\`\`\`csharp
namespace BuilderExample;
public class Order {
    public string Id { get; set; }
    public string Customer { get; set; }
    public List<LineItem> Items { get; set; } = new();
}
public class LineItem { public string Sku { get; set; } public int Qty { get; set; } }
\`\`\`

**2. Fluent builder**

\`\`\`csharp
namespace BuilderExample;
public class OrderBuilder {
    private string _id;
    private string _customer;
    private readonly List<LineItem> _items = new();
    public OrderBuilder WithId(string id) { _id = id; return this; }
    public OrderBuilder ForCustomer(string c) { _customer = c; return this; }
    public OrderBuilder WithItem(string sku, int qty) { _items.Add(new LineItem { Sku = sku, Qty = qty }); return this; }
    public Order Build() => new Order { Id = _id, Customer = _customer, Items = _items.ToList() };
}
\`\`\`

**3. Usage**

\`\`\`csharp
var order = new OrderBuilder()
    .WithId("O1")
    .ForCustomer("Alice")
    .WithItem("SKU1", 2)
    .WithItem("SKU2", 1)
    .Build();
\`\`\`

**How this code fits together:** The client uses **OrderBuilder**’s fluent API to set Id, Customer, and items step by step, then calls **Build()** to get an immutable **Order**. Construction logic and validation (if any) live in the builder; the Order class stays a simple data holder. No telescoping constructors and no optional parameters overload.

**When to use Builder:** Use when you have **complex construction** with **many optional parameters** or **stepwise setup** and want readable, valid object creation. Avoid when you have few required parameters—a constructor or object initializer is enough.

---

## Prototype pattern

### What it is and when to use it

**Prototype** creates new objects by **cloning** an existing instance (the prototype) instead of building from scratch. Use it when **cloning is cheaper or safer** than \`new\` (e.g. after expensive load from DB or file), or when you need **copies with small variations** (e.g. report template with different title). Typical uses: report templates, game entities (spawn from template), cached configurations, and any "copy and modify" scenario. In .NET you can use \`ICloneable\`, a copy constructor, or a custom \`Clone()\` method; be explicit about shallow vs deep copy.

### Class structure

\`\`\`mermaid
classDiagram
    class IPrototype {
        <<interface>>
        +Clone() IPrototype
    }
    class ConcretePrototypeA {
        -state
        +Clone() IPrototype
    }
    class ConcretePrototypeB {
        -state
        +Clone() IPrototype
    }
    ConcretePrototypeA ..|> IPrototype
    ConcretePrototypeB ..|> IPrototype
    ConcretePrototypeA ..> ConcretePrototypeA : clone
    ConcretePrototypeB ..> ConcretePrototypeB : clone
    classDef interface fill:#e0e7ff,stroke:#6366f1,stroke-width:2,color:#4338ca
    classDef prototype fill:#fef3c7,stroke:#d97706,stroke-width:2,color:#92400e
    class IPrototype:::interface
    class ConcretePrototypeA:::prototype
    class ConcretePrototypeB:::prototype
\`\`\`

**Class structure explained:** **IPrototype** (or a base type) declares \`Clone()\`. **ConcretePrototypeA** and **ConcretePrototypeB** implement cloning by creating a copy of their state (shallow or deep). The client obtains a prototype instance (e.g. from a registry or cache) and calls \`Clone()\` to get a new object without knowing concrete types or construction details.

### Full working example: Report template

**1. Prototype with clone**

\`\`\`csharp
namespace PrototypeExample;
public class ReportTemplate {
    public string Title { get; set; }
    public List<string> Sections { get; set; } = new();
    public ReportTemplate Clone() =>
        new ReportTemplate {
            Title = Title,
            Sections = new List<string>(Sections)
        };
}
\`\`\`

**2. Usage**

\`\`\`csharp
var original = new ReportTemplate { Title = "Q1", Sections = new List<string> { "Intro", "Data" } };
var copy = original.Clone();
copy.Title = "Q2 Report";
\`\`\`

**How this code fits together:** The client holds a **ReportTemplate** (e.g. loaded once from config or DB). Instead of building a new template from scratch, it calls **Clone()** to get a copy and then mutates the copy (e.g. title, sections). The prototype holds shared or default state; cloning avoids repeating expensive setup.

**When to use Prototype:** Use when **cloning is cheaper or safer** than full construction, or when you need **copies with small variations**. Be explicit about shallow vs deep: shallow copies share nested references; deep copies duplicate nested objects. Avoid when construction is simple and there is no shared default state.

---

## Singleton pattern

### What it is and when to use it

**Singleton** ensures a class has **exactly one instance** and provides a global access point to it. In .NET, prefer **dependency injection** with \`AddSingleton<T>\` so the same instance is shared wherever \`T\` is injected—and tests can replace it with a mock. Avoid static singleton fields when you need testability. Use it for loggers, application config, connection pools, cache managers, and thread pools. The "single instance" is managed by the DI container, not by a static property.

### Class structure

\`\`\`mermaid
classDiagram
    class IService {
        <<interface>>
        +DoWork()
    }
    class SingletonService {
        +DoWork()
    }
    IService <|.. SingletonService
    note for SingletonService "single instance via DI"
    classDef interface fill:#e0e7ff,stroke:#6366f1,stroke-width:2,color:#4338ca
    classDef singleton fill:#d1fae5,stroke:#059669,stroke-width:2,color:#065f46
    class IService:::interface
    class SingletonService:::singleton
\`\`\`

**Class structure explained:** The client depends on **IService** (interface). **SingletonService** implements it. The container registers \`AddSingleton<IService, SingletonService>()\`, so one instance of SingletonService is created and reused for all requests of IService. No static instance—the container owns the lifetime.

### Full working example: Logger via DI

**1. Interface and implementation**

\`\`\`csharp
namespace SingletonExample;
public interface IAppLogger { void Log(string message); }
public class FileLogger : IAppLogger {
    public void Log(string message) { /* write to file */ }
}
\`\`\`

**2. Registration and usage**

\`\`\`csharp
// Program.cs or Startup
services.AddSingleton<IAppLogger, FileLogger>();

// Consumer: same instance injected everywhere
public class OrderService {
    public OrderService(IAppLogger logger) { /* one shared logger */ }
}
\`\`\`

**How this code fits together:** The DI container creates **one** **FileLogger** and injects it wherever **IAppLogger** is requested. All consumers share the same instance. In tests you register a fake \`IAppLogger\` instead. Avoid \`private static readonly FileLogger _instance = new FileLogger();\`—it makes testing and replacement hard.

**When to use Singleton:** Use when you need **exactly one instance** of a service (logger, config, pool, cache) and you want it shared across the app. In .NET use **AddSingleton<T>** in DI. Avoid static singleton when testability or replacement matters.

---

## Comparison: when to use which

| Pattern | Use when | Avoid when |
|--------|----------|------------|
| **Factory Method** | One product type; creation varies by subclass | You need families of products (use Abstract Factory) |
| **Abstract Factory** | Families of related products (e.g. UI theme) | Single product type (use Factory Method) |
| **Builder** | Complex object, many optional params or steps | Few parameters; constructor suffices |
| **Prototype** | Cloning cheaper than \`new\`; copies with variations | Simple construction; no shared default state |
| **Singleton** | Exactly one instance (logger, config, pool) | You need testability without DI (prefer DI singleton) |

---

## Common pitfalls

- **Factory Method:** Letting the client depend on concrete creators or products; keep client code against the creator abstraction and product interface only.
- **Abstract Factory:** Mixing products from different families (e.g. Win button with Mac text box); ensure one factory instance per family.
- **Builder:** Forgetting to validate required fields before \`Build()\`, or making the product mutable in a way that breaks after \`Build()\`.
- **Prototype:** Shallow cloning when nested objects are mutable—clone nested structures too (deep copy) or document that clones share references.
- **Singleton:** Using static singleton instead of DI—hard to test and replace; prefer \`AddSingleton<T>\` and inject the interface.

---
---

## Position & Rationale

I use **Factory Method** when I need to defer object creation to a subclass or to keep creation out of the main flow; I use **Abstract Factory** when I have **families** of related products and want to swap the whole family. I use **Builder** when construction has many optional steps or the same steps in different orders; I avoid it for simple DTOs. I use **Prototype** when cloning is cheaper or more appropriate than creating from scratch (e.g. templates, copy). I use **Singleton** sparingly—only for true app-wide single instances (e.g. logger, config); I prefer DI and single registration over a static Singleton. I reject using Abstract Factory when I have only one product family; I reject Singleton when a scoped or transient service would do. I combine creational patterns with **DI** so the container owns lifetime and I don't hide dependencies.

---

## Trade-Offs & Failure Modes

- **What this sacrifices:** Each pattern adds types and indirection; over-use makes creation paths hard to follow. Singleton bypasses DI and makes testing and multi-instance scenarios harder.
- **Where it degrades:** Abstract Factory with one implementation—ceremony. Builder for three-field DTOs—overkill. Singleton for something that could be scoped (e.g. per-request)—bugs when concurrency or test isolation matter.
- **How it fails when misapplied:** Using Singleton for services that need to be replaced or tested in isolation. Using Abstract Factory when a single factory method would do. Using Builder when a constructor or object initialiser is enough.
- **Early warning signs:** "We need two instances but everything is Singleton"; "the builder has one optional field"; "we added Abstract Factory but we only ever use one family."

---

## What Most Guides Miss

Guides show each pattern in isolation and rarely help you **choose**. In practice, **Factory Method** vs **Abstract Factory** depends on whether you have one product or families; **Builder** pays off when there are many optional parameters or complex validation, not for every DTO. **Singleton** is widely overused; in .NET, **DI with single registration** (e.g. AddSingleton) gives the same single instance with testability and explicit dependency. **Prototype** is often skipped in C# because we have object initialisers and copy constructors; it's still useful when cloning is the natural operation (templates, undo). The "when not to use" and the cost of hiding creation behind too many layers are underplayed.

---

## Decision Framework

- **If you need to create one product and defer the concrete type** → Factory Method (or DI).
- **If you have families of related products and want to swap the family** → Abstract Factory.
- **If construction has many optional steps or complex validation** → Builder; otherwise constructor or initialiser.
- **If cloning is the natural operation (templates, copy)** → Prototype.
- **If you need exactly one instance app-wide and DI is not available** → Singleton; otherwise prefer AddSingleton and inject.
- **If you're not sure** → Start with simple construction and DI; add a pattern when you have a clear creation problem.

---

## Key Takeaways

- Factory Method for deferred creation; Abstract Factory for families of products; Builder for complex construction; Prototype for clone; Singleton sparingly, prefer DI.
- Don't use Abstract Factory for one family; don't use Builder for simple DTOs; don't use Singleton when scoped or transient would do.
- Combine with DI so the container owns lifetime; avoid hiding dependencies inside creational types.


## Summary

Creational patterns in .NET—**Factory Method**, **Abstract Factory**, **Builder**, **Prototype**, and **Singleton**—address how objects are created and who owns creation. This article covered all five with class diagrams, full C# examples, and when to use each. Use the definitions and code above in your solutions; combine with DI and your domain as needed.

---

## When I Would Use This Again — and When I Wouldn't

I would use creational patterns again when object creation is non-trivial (multiple representations, families, or controlled lifecycle) and I want testability or centralised construction. I wouldn't use Factory for a single \`new\` in one place—then a constructor is enough. I also wouldn't use Singleton (static) for services; use DI. Alternative: for simple DTOs or value objects, \`new\` and constructors are fine; introduce patterns when creation logic grows or when you need to swap implementations.


---

## Frequently Asked Questions

### What is Factory Method?

Factory Method is a creational pattern where a method in a class (or base class) is responsible for creating one product; subclasses override that method to create concrete products. The client depends only on the creator type and product interface.

### What is Abstract Factory?

Abstract Factory provides an interface for creating families of related products (e.g. Win UI or Mac UI). Concrete factories implement the interface and ensure all products come from the same family.

### What is Builder?

Builder separates construction of a complex object from its representation. A builder exposes fluent methods for each step and a \`Build()\` method that returns the product. Use when you have many optional parameters or stepwise construction.

### What is Prototype?

Prototype creates new objects by cloning an existing instance. Use when cloning is cheaper than \`new\` or when you need copies with small variations. Implement via \`ICloneable\`, copy constructor, or custom \`Clone()\`; be explicit about shallow vs deep.

### What is Singleton?

Singleton ensures exactly one instance of a class. In .NET prefer \`AddSingleton<T>\` in DI so the same instance is shared and tests can replace it. Avoid static singleton when testability matters.

### When use Factory Method vs Abstract Factory?

Factory Method: **one** product type; creation varies by subclass. Abstract Factory: **families** of related products; one factory produces all products in the family.

### When use Builder vs constructor?

Use Builder when you have **many optional parameters** or **stepwise construction** and want readable, valid creation. Use a constructor when you have a few required parameters.

### Deep vs shallow clone?

Shallow clone copies the object and its value-type fields but keeps references to nested objects—so nested state is shared. Deep clone duplicates nested objects too so the copy is fully independent.

### Why avoid static Singleton?

Static singleton is hard to test (you cannot replace it with a mock) and ties the app to one concrete type. DI singleton (\`AddSingleton<T>\`) lets you inject an interface and replace it in tests.
`,
  faqs: [
  {
    "question": "What is Factory Method?",
    "answer": "One method creates one product; subclasses override to create concrete products."
  },
  {
    "question": "What is Abstract Factory?",
    "answer": "Family of factories for related products (e.g. Win vs Mac UI)."
  },
  {
    "question": "What is Builder?",
    "answer": "Separates construction from representation. Fluent API with Build() method."
  },
  {
    "question": "What is Prototype?",
    "answer": "Clone existing instance instead of new. ICloneable or copy constructor."
  },
  {
    "question": "What is Singleton?",
    "answer": "Exactly one instance. Use AddSingleton<T> in DI."
  },
  {
    "question": "When use Factory Method?",
    "answer": "One product type, creation varies by subclass."
  },
  {
    "question": "When use Abstract Factory?",
    "answer": "Families of related products. UI themes, database drivers."
  },
  {
    "question": "When use Builder?",
    "answer": "Complex construction, many optional params."
  },
  {
    "question": "When use Prototype?",
    "answer": "Cloning cheaper than new. Report templates."
  },
  {
    "question": "When use Singleton?",
    "answer": "Logger, config, connection pool. Prefer DI singleton."
  },
  {
    "question": "Factory Method vs Abstract Factory?",
    "answer": "Factory Method = one product. Abstract Factory = family."
  },
  {
    "question": "How implement Singleton in .NET?",
    "answer": "services.AddSingleton<T>() in DI. Avoid static."
  },
  {
    "question": "Builder vs constructor?",
    "answer": "Builder for many optional params. Constructor for required."
  },
  {
    "question": "Deep vs shallow clone?",
    "answer": "Shallow copies references. Deep copies nested objects."
  },
  {
    "question": "Why avoid static Singleton?",
    "answer": "Hard to test. DI allows mocking."
  }
]
}
