/**
 * Blog article: microservices-resilience-circuit-breaker-retry
 * Auto-generated by scripts/split-blog-articles.js. Do not edit the content here by hand if you run the split script again.
 */

export default {
  slug: "microservices-resilience-circuit-breaker-retry",
  title: "Microservices Resilience: Circuit Breaker, Retry, Timeout, Bulkhead, and Fallback",
  excerpt: "In-depth resilience for microservices: all scenarios (transient, cascade, timeout, half-open), Retry, Circuit Breaker, Timeout, Bulkhead, Fallback, full Polly implementations in .NET, Program.cs and presentation, best practices, and FAQs.",
  date: "2025-04-16",
  topic: "Cloud",
  keywords: ["Microservices Resilience: Circuit Breaker, Retry, Timeout, Bulkhead, and Fallback", "Microservices Resilience Circuit Breaker Retry", "Microservices Resilience Circuit Breaker Retry best practices", "how to microservices resilience circuit breaker retry", "microservices resilience circuit breaker retry in .NET", "microservices resilience circuit breaker retry guide", "microservices resilience circuit breaker retry for enterprise", "microservices resilience circuit breaker retry patterns", "when to use microservices resilience circuit breaker retry", "microservices resilience circuit breaker retry tutorial", "microservices resilience circuit breaker retry examples", "microservices resilience circuit breaker retry in C#", "microservices resilience circuit breaker retry overview", "microservices resilience circuit breaker retry implementation", "understanding microservices resilience circuit breaker retry", "microservices resilience circuit breaker retry for developers", "microservices resilience circuit breaker retry checklist", "microservices resilience circuit breaker retry tips", "microservices resilience circuit breaker retry deep dive", "microservices resilience circuit breaker retry comparison", "microservices resilience circuit breaker retry vs alternatives", "microservices resilience circuit breaker retry .NET Core", "microservices resilience circuit breaker retry Azure", "microservices resilience circuit breaker retry explained", "microservices resilience circuit breaker retry when to use", "microservices resilience circuit breaker retry enterprise", "microservices resilience circuit breaker retry .NET", "what is microservices resilience circuit breaker retry", "microservices resilience circuit breaker retry summary", "microservices resilience circuit breaker retry introduction", "microservices resilience circuit breaker retry fundamentals", "microservices resilience circuit breaker retry step by step", "microservices resilience circuit breaker retry complete guide", "microservices resilience circuit breaker retry for beginners", "microservices resilience circuit breaker retry advanced", "microservices resilience circuit breaker retry production", "microservices resilience circuit breaker retry real world", "microservices resilience circuit breaker retry example code", "microservices resilience circuit breaker retry C# example", "microservices resilience circuit breaker retry .NET example", "learn microservices resilience circuit breaker retry", "microservices resilience circuit breaker retry learn", "microservices resilience circuit breaker retry reference", "microservices resilience circuit breaker retry cheat sheet", "microservices resilience circuit breaker retry pitfalls", "microservices resilience circuit breaker retry common mistakes", "microservices resilience circuit breaker retry performance", "microservices resilience circuit breaker retry optimization", "microservices resilience circuit breaker retry security", "microservices resilience circuit breaker retry testing", "microservices resilience circuit breaker retry unit test", "microservices resilience circuit breaker retry integration", "microservices resilience circuit breaker retry migration", "microservices resilience circuit breaker retry from scratch", "microservices resilience circuit breaker retry 2024", "microservices resilience circuit breaker retry 2025", "best microservices resilience circuit breaker retry", "microservices resilience circuit breaker retry best", "pro microservices resilience circuit breaker retry", "microservices resilience circuit breaker retry expert", "microservices resilience circuit breaker retry consultant", "microservices resilience circuit breaker retry services", "microservices resilience circuit breaker retry course", "microservices resilience circuit breaker retry workshop", "microservices resilience circuit breaker retry webinar", "microservices resilience circuit breaker retry blog", "microservices resilience circuit breaker retry article", "microservices resilience circuit breaker retry post", "why microservices resilience circuit breaker retry", "when microservices resilience circuit breaker retry", "where microservices resilience circuit breaker retry", "microservices resilience circuit breaker retry in .NET 6", "microservices resilience circuit breaker retry in .NET 7", "microservices resilience circuit breaker retry in .NET 8", "microservices resilience circuit breaker retry for C#", "microservices resilience circuit breaker retry for Angular", "microservices resilience circuit breaker retry for Vue", "microservices resilience circuit breaker retry for React", "microservices resilience circuit breaker retry for Azure", "microservices resilience circuit breaker retry for microservices", "microservices resilience circuit breaker retry for API", "microservices resilience circuit breaker retry for database", "microservices resilience circuit breaker retry for testing", "microservices resilience circuit breaker retry for DevOps", "microservices resilience circuit breaker retry for senior developers", "microservices resilience circuit breaker retry for team", "microservices resilience circuit breaker retry for production", "microservices resilience circuit breaker retry for scale", "microservices resilience circuit breaker retry for refactoring", "microservices resilience circuit breaker retry for enterprise applications", "microservices resilience circuit breaker retry for startup", "microservices resilience circuit breaker retry in 2024", "microservices resilience circuit breaker retry in 2025", "microservices resilience circuit breaker retry in 2026", "microservices resilience circuit breaker retry code sample", "microservices resilience circuit breaker retry code example", "microservices resilience circuit breaker retry sample code", "microservices resilience circuit breaker retry full example", "microservices resilience circuit breaker retry working example", "microservices resilience circuit breaker retry practical microservices resilience circuit breaker retry", "microservices resilience circuit breaker retry real world example", "microservices resilience circuit breaker retry use case", "microservices resilience circuit breaker retry use cases", "microservices resilience circuit breaker retry scenario", "microservices resilience circuit breaker retry scenarios", "microservices resilience circuit breaker retry pattern", "microservices resilience circuit breaker retry approach", "microservices resilience circuit breaker retry approaches", "microservices resilience circuit breaker retry strategy", "microservices resilience circuit breaker retry strategies", "microservices resilience circuit breaker retry technique", "microservices resilience circuit breaker retry techniques", "microservices resilience circuit breaker retry method", "microservices resilience circuit breaker retry methods", "microservices resilience circuit breaker retry solution", "microservices resilience circuit breaker retry solutions", "microservices resilience circuit breaker retry implementation guide", "microservices resilience circuit breaker retry getting started", "microservices resilience circuit breaker retry quick start", "microservices resilience circuit breaker retry overview guide", "microservices resilience circuit breaker retry comprehensive guide", "microservices resilience circuit breaker retry detailed guide", "microservices resilience circuit breaker retry practical guide", "microservices resilience circuit breaker retry developer guide", "microservices resilience circuit breaker retry engineer guide", "microservices resilience circuit breaker retry architect guide", "microservices resilience circuit breaker retry for architects", "microservices resilience circuit breaker retry for backend", "microservices resilience circuit breaker retry for tech leads", "microservices resilience circuit breaker retry for senior devs", "benefits of microservices resilience circuit breaker retry", "advantages of microservices resilience circuit breaker retry", "alternatives to microservices resilience circuit breaker retry", "compared to microservices resilience circuit breaker retry", "intro to microservices resilience circuit breaker retry", "basics of microservices resilience circuit breaker retry", "microservices resilience circuit breaker retry tips and tricks", "microservices resilience circuit breaker retry production-ready", "microservices resilience circuit breaker retry enterprise-grade", "microservices resilience circuit breaker retry with Docker", "microservices resilience circuit breaker retry with Kubernetes", "microservices resilience circuit breaker retry in ASP.NET Core", "microservices resilience circuit breaker retry with Entity Framework", "microservices resilience circuit breaker retry with EF Core", "microservices resilience circuit breaker retry modern", "microservices resilience circuit breaker retry updated", "microservices resilience circuit breaker retry latest", "microservices resilience circuit breaker retry walkthrough", "microservices resilience circuit breaker retry hands-on", "microservices resilience circuit breaker retry practical examples", "microservices resilience circuit breaker retry real-world examples", "microservices resilience circuit breaker retry common pitfalls", "microservices resilience circuit breaker retry gotchas", "microservices resilience circuit breaker retry FAQ", "microservices resilience circuit breaker retry FAQs", "microservices resilience circuit breaker retry Q&A", "microservices resilience circuit breaker retry interview questions", "microservices resilience circuit breaker retry interview", "microservices resilience circuit breaker retry certification", "microservices resilience circuit breaker retry training", "microservices resilience circuit breaker retry video", "microservices resilience circuit breaker retry series", "microservices resilience circuit breaker retry part 1", "microservices resilience circuit breaker retry core concepts", "microservices resilience circuit breaker retry key concepts", "microservices resilience circuit breaker retry recap", "microservices resilience circuit breaker retry takeaways", "microservices resilience circuit breaker retry conclusion", "microservices resilience circuit breaker retry next steps", "microservices resilience circuit breaker retry further reading", "microservices resilience circuit breaker retry resources", "microservices resilience circuit breaker retry tools", "microservices resilience circuit breaker retry libraries", "microservices resilience circuit breaker retry frameworks", "microservices resilience circuit breaker retry NuGet", "microservices resilience circuit breaker retry package", "microservices resilience circuit breaker retry GitHub", "microservices resilience circuit breaker retry open source", "microservices resilience circuit breaker retry community", "microservices resilience circuit breaker retry Microsoft docs", "microservices resilience circuit breaker retry documentation", "microservices resilience circuit breaker retry official guide", "microservices resilience circuit breaker retry official tutorial", "Microservices", "Microservices guide", "Microservices tutorial", "Microservices best practices", "Microservices in .NET", "Microservices in C#", "Microservices for developers", "Microservices examples", "Microservices patterns", "Microservices overview", "Microservices introduction", "Microservices deep dive", "Microservices explained", "Microservices how to", "Microservices what is", "Microservices when to use", "Microservices for enterprise", "Microservices .NET Core", "Microservices Azure", "Microservices C#", "Microservices with .NET", "Microservices with C#", "Microservices with Azure", "Microservices with Angular", "Microservices with Vue", "Microservices with React", "Microservices with Entity Framework", "Microservices with SQL Server", "Microservices step by step", "Microservices complete guide", "Microservices from scratch", "Microservices 2024", "Microservices 2025", "Microservices 2026", "Microservices code example", "Microservices sample code", "Microservices implementation", "Microservices real world", "Microservices production", "Microservices for beginners", "Microservices advanced", "Microservices for architects", "Microservices for backend", "Microservices for API", "Microservices in ASP.NET Core", "Microservices with EF Core", "Microservices tutorial 2024", "Microservices guide 2025", "Microservices best practices 2024", "Microservices C# examples", "Microservices .NET examples", "Microservices implementation guide", "Microservices how to implement", "Microservices benefits", "Microservices advantages", "Microservices pitfalls", "Microservices alternatives", "Microservices compared", "Microservices intro", "Microservices basics", "Microservices tips and tricks", "Microservices production-ready", "Microservices enterprise-grade", "Microservices maintainable", "Microservices testable", "Microservices refactoring", "Microservices modern", "Microservices updated", "Microservices latest", "Microservices for tech leads", "Microservices for senior devs", "Microservices with Docker", "Microservices with Kubernetes", "Microservices in .NET 8", "Microservices in .NET 7", "Microservices in .NET 6", "Microservices Resilience", "Microservices Resilience guide", "Microservices Resilience tutorial", "Microservices Resilience best practices", "Microservices Resilience in .NET", "Microservices Resilience in C#", "Microservices Resilience for developers", "Microservices Resilience examples", "Microservices Resilience patterns", "Microservices Resilience overview", "Microservices Resilience introduction", "Microservices Resilience deep dive", "Microservices Resilience explained", "Microservices Resilience how to", "Microservices Resilience what is", "Microservices Resilience when to use", "Microservices Resilience for enterprise", "Microservices Resilience .NET Core", "Microservices Resilience Azure", "Microservices Resilience C#", "Microservices Resilience with .NET", "Microservices Resilience with C#", "Microservices Resilience with Azure", "Microservices Resilience with Angular", "Microservices Resilience with Vue", "Microservices Resilience with React", "Microservices Resilience with Entity Framework", "Microservices Resilience with SQL Server", "Microservices Resilience step by step", "Microservices Resilience complete guide", "Microservices Resilience from scratch", "Microservices Resilience 2024", "Microservices Resilience 2025", "Microservices Resilience 2026", "Microservices Resilience code example", "Microservices Resilience sample code", "Microservices Resilience implementation", "Microservices Resilience real world", "Microservices Resilience production", "Microservices Resilience for beginners", "Microservices Resilience advanced", "Microservices Resilience for architects", "Microservices Resilience for backend", "Microservices Resilience for API", "Microservices Resilience in ASP.NET Core", "Microservices Resilience with EF Core", "Microservices Resilience tutorial 2024", "Microservices Resilience guide 2025", "Microservices Resilience best practices 2024", "Microservices Resilience C# examples", "Microservices Resilience .NET examples", "Microservices Resilience implementation guide", "Microservices Resilience how to implement", "Microservices Resilience benefits", "Microservices Resilience advantages", "Microservices Resilience pitfalls", "Microservices Resilience alternatives", "Microservices Resilience compared", "Microservices Resilience intro", "Microservices Resilience basics", "Microservices Resilience tips and tricks", "Microservices Resilience production-ready", "Microservices Resilience enterprise-grade", "Microservices Resilience maintainable", "Microservices Resilience testable", "Microservices Resilience refactoring", "Microservices Resilience modern", "Microservices Resilience updated", "Microservices Resilience latest", "Microservices Resilience for tech leads", "Microservices Resilience for senior devs", "Microservices Resilience with Docker", "Microservices Resilience with Kubernetes", "Microservices Resilience in .NET 8", "Microservices Resilience in .NET 7", "Microservices Resilience in .NET 6", "Microservices Resilience Circuit", "Microservices Resilience Circuit guide", "Microservices Resilience Circuit tutorial", "Microservices Resilience Circuit best practices", "Microservices Resilience Circuit in .NET", "Microservices Resilience Circuit in C#", "Microservices Resilience Circuit for developers", "Microservices Resilience Circuit examples", "Microservices Resilience Circuit patterns", "Microservices Resilience Circuit overview", "Microservices Resilience Circuit introduction", "Microservices Resilience Circuit deep dive", "Microservices Resilience Circuit explained", "Microservices Resilience Circuit how to", "Microservices Resilience Circuit what is", "Microservices Resilience Circuit when to use", "Microservices Resilience Circuit for enterprise", "Microservices Resilience Circuit .NET Core", "Microservices Resilience Circuit Azure", "Microservices Resilience Circuit C#", "Microservices Resilience Circuit with .NET", "Microservices Resilience Circuit with C#", "Microservices Resilience Circuit with Azure", "Microservices Resilience Circuit with Angular", "Microservices Resilience Circuit with Vue", "Microservices Resilience Circuit with React", "Microservices Resilience Circuit with Entity Framework", "Microservices Resilience Circuit with SQL Server", "Microservices Resilience Circuit step by step", "Microservices Resilience Circuit complete guide", "Microservices Resilience Circuit from scratch", "Microservices Resilience Circuit 2024", "Microservices Resilience Circuit 2025", "Microservices Resilience Circuit 2026", "Microservices Resilience Circuit code example"],
  relatedServices: ["microservices-architecture","azure-cloud-architecture"],
  relatedProjects: ["bat-inhouse-app"],
  relatedArticleSlugs: ["azure-microservices-best-practices","saga-pattern-orchestrator-vs-choreography"],
  author: "Waqas Ahmad",
  content: `## Introduction

This guidance is relevant when the topic of this article applies to your system or design choices; it breaks down when constraints or context differ. I've applied it in real projects and refined the takeaways over time (as of 2026).

When one microservice calls another (or an external API), **failures** and **latency** are inevitable. Without resilience patterns, a single slow or failing dependency can **cascade** and take down your system. **Retry**, **Circuit Breaker**, **Timeout**, **Bulkhead**, and **Fallback** are the core tools: **Retry** handles transient failures; **Circuit Breaker** stops calling a failing dependency so it can recover; **Timeout** prevents hanging; **Bulkhead** isolates failures; **Fallback** returns a safe default when all else fails.

If you are new: start with [Topics covered](#topics-covered) and [Resilience at a glance](#resilience-at-a-glance). This article covers **all scenarios** (transient failure, cascading failure, timeout, partial failure, dependency down, half-open), **every pattern** (retry, circuit breaker, timeout, bulkhead, fallback), **full Polly implementations** in .NET with **Program.cs** and **presentation**, **best practices**, and **FAQs**.

## Topics covered

- [Decision Context](#decision-context)
- [What is resilience and why it matters](#what-is-resilience-and-why-it-matters)
- [Resilience at a glance](#resilience-at-a-glance)
- [Retry: when, how, and all scenarios](#retry-when-how-and-all-scenarios)
- [Circuit Breaker: states, when it trips, when it resets](#circuit-breaker-states-when-it-trips-when-it-resets)
- [Timeout, Bulkhead, and Fallback](#timeout-bulkhead-and-fallback)
- [Combined policies: order and wrap](#combined-policies-order-and-wrap)
- [All failure scenarios and how to handle them](#all-failure-scenarios-and-how-to-handle-them)
- [Polly in .NET: full implementations](#polly-in-net-full-implementations)
- [Full code: Program.cs, policies, and presentation](#full-code-programcs-policies-and-presentation)
- [Best practices and pitfalls](#best-practices-and-pitfalls)
- [Summary](#summary)
- [Position & Rationale](#position--rationale)
- [Trade-Offs & Failure Modes](#trade-offs--failure-modes)
- [What Most Guides Miss](#what-most-guides-miss)
- [Decision Framework](#decision-framework)
- [Key Takeaways](#key-takeaways)
- [When I Would Use This Again — and When I Wouldn't](#when-i-would-use-this-again--and-when-i-wouldnt)
- [Frequently Asked Questions](#frequently-asked-questions)

------

## Decision Context

- **System scale:** Varies by context; the approach in this article applies to the scales and scenarios described in the body.
- **Team size:** Typically small to medium teams; ownership and clarity matter more than headcount.
- **Time / budget pressure:** Applicable under delivery pressure; I've used it in both greenfield and incremental refactors.
- **Technical constraints:** .NET and related stack where relevant; constraints are noted in the article where they affect the approach.
- **Non-goals:** This article does not optimize for every possible scenario; boundaries are stated where they matter.


## What is resilience and why it matters

**Resilience** means your system **continues to function** (or degrades gracefully) when **dependencies fail** or are **slow**. In microservices, dependencies are **remote**: another service, a database, or an external API. Failures can be **transient** (network blip, timeout, 503) or **permanent** (404, 400, dependency down). Without patterns:

- **Cascading failure** — One failing dependency causes your service to pile up requests, exhaust threads, and crash; then callers of your service fail too.
- **Wasted resources** — Retrying a dependency that is down burns CPU and threads.
- **Hanging** — A call that never returns blocks a thread and can exhaust the pool.

**Retry** handles **transient** failures by trying again (with backoff). **Circuit Breaker** stops calling a **failing** dependency after a threshold so it can recover and you stop wasting resources. **Timeout** cancels long-running calls. **Bulkhead** limits how many concurrent calls go to a dependency so one bad dependency does not consume all threads. **Fallback** returns a cached or default value when the dependency fails. Together they make your service **resilient**.

---

## Resilience at a glance

| Pattern | What it does | When to use |
|--------|--------------|-------------|
| **Retry** | Retries a failed call (with delay). | Transient failures: network blip, timeout, 5xx. |
| **Circuit Breaker** | Stops calling after N failures; opens circuit; after duration tries again (half-open). | Remote shared dependency; prevent cascade. |
| **Timeout** | Cancels the call after a duration. | Prevent hanging; fail fast. |
| **Bulkhead** | Limits concurrent calls (per dependency or global). | Isolate one dependency so it does not exhaust resources. |
| **Fallback** | Returns a default or cached value when the call fails. | Graceful degradation; avoid failing the whole request. |

---

## Retry: when, how, and all scenarios

**When to retry:** **Transient** failures only: \`HttpRequestException\`, \`TaskCanceledException\` (timeout), HTTP **5xx**, **408** Request Timeout. Do **not** retry **4xx** (except 408) or **permanent** errors (e.g. 404, 400).

**How:** Use **exponential backoff** (delay grows: 1s, 2s, 4s) so you do not hammer the dependency. Add **jitter** (random offset) so many clients do not retry at the same time. Set a **max retry count** (e.g. 3–5) and optionally a **per-call timeout** so you fail fast.

**Scenarios:**

| Scenario | What happens | Policy |
|----------|--------------|--------|
| **Transient network error** | First call fails; retry succeeds. | Retry with backoff. |
| **Dependency temporarily slow** | First call times out; retry succeeds. | Retry + timeout per attempt. |
| **Dependency returns 503** | Retry with backoff; stop after max retries. | Retry on 5xx only; do not retry 4xx. |
| **Dependency is down** | All retries fail; circuit breaker opens after threshold. | Retry then circuit breaker. |
| **Non-idempotent operation** | Retry can double-submit (e.g. payment). | Do not retry; or use idempotency key. |

**Polly: retry with exponential backoff and jitter**

\`\`\`csharp
Policy<HttpResponseMessage>
  .Handle<HttpRequestException>()
  .OrResult(r => (int)r.StatusCode >= 500 || r.StatusCode == HttpStatusCode.RequestTimeout)
  .WaitAndRetryAsync(
    retryCount: 3,
    sleepDurationProvider: (attempt, outcome, ctx) =>
    {
        var baseDelay = TimeSpan.FromSeconds(Math.Pow(2, attempt));
        var jitter = TimeSpan.FromMilliseconds(Random.Shared.Next(0, 500));
        return baseDelay + jitter;
    },
    onRetry: (outcome, timespan, attempt, ctx) => { /* log */ });
\`\`\`

---

## Circuit Breaker: states, when it trips, when it resets

**States:**

| State | Meaning | Behavior |
|-------|--------|----------|
| **Closed** | Normal. | Calls go through. Failures are counted. |
| **Open** | Too many failures. | Calls **fail immediately** (no call to dependency). After a **duration**, move to Half-Open. |
| **Half-Open** | Testing recovery. | **One** trial call is allowed. **Success** → Closed. **Failure** → Open again. |

**When it trips (Closed → Open):** After **N consecutive failures** or **N failures in a time window** (e.g. 5 failures in 30 seconds). Polly: \`CircuitBreakerAsync(failureThreshold, durationOfBreak)\` or \`AdvancedCircuitBreakerAsync(failureThreshold, samplingDuration, minimumThroughput)\`.

**When it resets (Open → Half-Open):** After \`durationOfBreak\` (e.g. 30 seconds). Polly automatically moves to Half-Open and allows one call.

**Half-Open:** One success → **Closed**. One failure → **Open** again (reset the break duration).

**Scenarios:**

| Scenario | What happens |
|----------|--------------|
| **Dependency down** | Retries exhaust; circuit opens; subsequent calls fail fast. |
| **Dependency recovers** | After break duration, one trial call succeeds; circuit closes. |
| **Trial call fails** | Circuit reopens; break duration starts again. |

---

## Timeout, Bulkhead, and Fallback

**Timeout:** Cancel the call after a duration (e.g. 10 seconds). Prevents one slow dependency from hanging your thread. Polly: \`Policy.TimeoutAsync(TimeSpan.FromSeconds(10))\` or \`TimeoutStrategy.Optimistic\` (CancellationToken).

**Bulkhead:** Limit **concurrent** calls (e.g. max 10 to OrderApi). If 10 are in flight, the 11th waits or fails. Isolates one dependency so it cannot exhaust all threads. Polly: \`Policy.BulkheadAsync(maxParallelization, maxQueuingActions)\`.

**Fallback:** When the call fails (after retries and/or circuit open), return a **default value** or **cached value**. Polly: \`Policy.Handle<...>().FallbackAsync(fallbackAction)\` or \`FallbackAsync(fallbackValue)\`.

**Example: fallback to cached or default**

\`\`\`csharp
Policy<Order?>
  .Handle<HttpRequestException>()
  .OrResult(r => r == null)
  .FallbackAsync((CancellationToken ct) => Task.FromResult<Order?>(GetCachedOrder() ?? DefaultOrder()));
\`\`\`

---

## Combined policies: order and wrap

**Recommended order (outer to inner):** **Fallback** (outer) → **Circuit Breaker** → **Retry** → **Timeout** → **Bulkhead** (inner, closest to the call). So: Bulkhead limits concurrency, Timeout cancels long calls, Retry retries transient failures, Circuit Breaker opens after repeated failure, Fallback returns default when circuit is open or all retries fail.

**Polly: PolicyWrap**

\`\`\`csharp
var bulkhead = Policy.BulkheadAsync<HttpResponseMessage>(10, 100);
var timeout = Policy.TimeoutAsync<HttpResponseMessage>(TimeSpan.FromSeconds(10));
var retry = Policy<HttpResponseMessage>.Handle<HttpRequestException>().OrResult(r => !r.IsSuccessStatusCode)
  .WaitAndRetryAsync(3, attempt => TimeSpan.FromSeconds(Math.Pow(2, attempt)));
var circuitBreaker = Policy<HttpResponseMessage>.Handle<HttpRequestException>().OrResult(r => !r.IsSuccessStatusCode)
  .CircuitBreakerAsync(5, TimeSpan.FromSeconds(30));
var fallback = Policy<HttpResponseMessage>.Handle<HttpRequestException>().OrResult(r => !r.IsSuccessStatusCode)
  .FallbackAsync((CancellationToken ct) => Task.FromResult(new HttpResponseMessage(HttpStatusCode.OK) { Content = ... }));

var pipeline = Policy.WrapAsync(fallback, circuitBreaker, retry, timeout, bulkhead);
\`\`\`

---

## All failure scenarios and how to handle them

| Scenario | What to do |
|----------|------------|
| **Transient network error** | Retry with backoff; circuit opens if many fail. |
| **Dependency timeout** | Per-call timeout + retry (next attempt may succeed). |
| **Dependency returns 5xx** | Retry; circuit breaker after threshold. |
| **Dependency returns 4xx** | Do **not** retry (client error). Fail fast. |
| **Dependency down (connection refused)** | Retry a few times; circuit opens; fallback or fail. |
| **Cascading failure** | Circuit breaker stops calling; bulkhead limits concurrency so one dependency does not exhaust threads. |
| **Partial failure (one instance down)** | Retry (next request may hit healthy instance); circuit breaker per dependency. |
| **Half-open: trial succeeds** | Circuit closes; normal operation. |
| **Half-open: trial fails** | Circuit reopens; break duration restarts. |
| **Non-idempotent call** | Do not retry; or use idempotency key and retry. |
| **Slow dependency** | Timeout per call; retry if timeout is transient. |

---

## Polly in .NET: full implementations

**Package:** \`Polly.Extensions.Http\` or \`Polly\` + \`Microsoft.Extensions.Http.Polly\`.

**Retry:** \`Handle<HttpRequestException>().OrResult(r => (int)r.StatusCode >= 500).WaitAndRetryAsync(3, attempt => TimeSpan.FromSeconds(Math.Pow(2, attempt)))\`.

**Circuit Breaker:** \`Handle<HttpRequestException>().OrResult(r => !r.IsSuccessStatusCode).CircuitBreakerAsync(5, TimeSpan.FromSeconds(30))\`. **Advanced:** \`AdvancedCircuitBreakerAsync(0.5, TimeSpan.FromSeconds(30), 10)\` — opens when 50% of at least 10 calls fail in 30 seconds.

**Timeout:** \`Policy.TimeoutAsync<HttpResponseMessage>(TimeSpan.FromSeconds(10))\`.

**Bulkhead:** \`Policy.BulkheadAsync<HttpResponseMessage>(10, 100)\` — 10 concurrent, 100 queued.

**Fallback:** \`Handle<HttpRequestException>().FallbackAsync(...)\`.

**Events:** \`OnRetry\`, \`OnCircuitBreak\`, \`OnBreak\`, \`OnReset\` for logging and metrics.

---

## Full code: Program.cs, policies, and presentation

**1. Policies (centralised)**

\`\`\`csharp
// MyApi/Policies/ResiliencePolicies.cs
using Polly;
using Polly.Extensions.Http;

namespace MyApi.Policies;

public static class ResiliencePolicies
{
    public static IAsyncPolicy<HttpResponseMessage> GetRetryPolicy()
    {
        return HttpPolicyExtensions
            .HandleTransientHttpError()
            .OrResult(r => (int)r.StatusCode >= 500 || r.StatusCode == HttpStatusCode.RequestTimeout)
            .WaitAndRetryAsync(3, attempt => TimeSpan.FromSeconds(Math.Pow(2, attempt)),
                onRetry: (outcome, span, attempt, ctx) => { /* log */ });
    }

    public static IAsyncPolicy<HttpResponseMessage> GetCircuitBreakerPolicy()
    {
        return HttpPolicyExtensions
            .HandleTransientHttpError()
            .OrResult(r => (int)r.StatusCode >= 500)
            .CircuitBreakerAsync(5, TimeSpan.FromSeconds(30),
                onBreak: (outcome, span) => { /* log */ },
                onReset: () => { /* log */ },
                onHalfOpen: () => { /* log */ });
    }

    public static IAsyncPolicy<HttpResponseMessage> GetTimeoutPolicy()
        => Policy.TimeoutAsync<HttpResponseMessage>(TimeSpan.FromSeconds(10));

    public static IAsyncPolicy<HttpResponseMessage> GetBulkheadPolicy()
        => Policy.BulkheadAsync<HttpResponseMessage>(10, 100);
}
\`\`\`

**2. Program.cs: register HttpClient with policies**

\`\`\`csharp
// Program.cs
using MyApi.Policies;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddHttpClient("OrderApi", client =>
{
    client.BaseAddress = new Uri(builder.Configuration["OrderApi:BaseUrl"]!);
    client.Timeout = TimeSpan.FromSeconds(30);
})
.AddPolicyHandler(ResiliencePolicies.GetRetryPolicy())
.AddPolicyHandler(ResiliencePolicies.GetCircuitBreakerPolicy())
.AddPolicyHandler(ResiliencePolicies.GetTimeoutPolicy());
// Optional: .AddPolicyHandler(ResiliencePolicies.GetBulkheadPolicy());

builder.Services.AddScoped<IOrderService, OrderService>();
builder.Services.AddControllers();

var app = builder.Build();
app.MapControllers();
app.Run();
\`\`\`

**3. Service and presentation**

\`\`\`csharp
// MyApi/Services/IOrderService.cs
public interface IOrderService
{
    Task<Order?> GetOrderAsync(Guid id, CancellationToken ct = default);
}

// MyApi/Services/OrderService.cs
public class OrderService : IOrderService
{
    private readonly IHttpClientFactory _factory;

    public OrderService(IHttpClientFactory factory) => _factory = factory;

    public async Task<Order?> GetOrderAsync(Guid id, CancellationToken ct)
    {
        var client = _factory.CreateClient("OrderApi");
        var response = await client.GetAsync($"/orders/{id}", ct).ConfigureAwait(false);
        response.EnsureSuccessStatusCode();
        return await response.Content.ReadFromJsonAsync<Order>(cancellationToken: ct).ConfigureAwait(false);
    }
}

// MyApi/Controllers/OrdersController.cs
[ApiController]
[Route("api/orders")]
public class OrdersController : ControllerBase
{
    private readonly IOrderService _orderService;

    public OrdersController(IOrderService orderService) => _orderService = orderService;

    [HttpGet("{id:guid}")]
    public async Task<ActionResult<Order>> Get(Guid id, CancellationToken ct)
    {
        var order = await _orderService.GetOrderAsync(id, ct).ConfigureAwait(false);
        return order == null ? NotFound() : Ok(order);
    }
}
\`\`\`

**Flow:** Client calls your API → **OrdersController** → **OrderService** → **HttpClient** (named \`OrderApi\`). Each \`GetAsync\` is wrapped by **Timeout** → **Retry** → **Circuit Breaker** (order is inner to outer when using \`AddPolicyHandler\`: first handler is outermost). So: timeout applies first, then retry, then circuit breaker. If the circuit is open, Polly throws \`BrokenCircuitException\`; you can catch and return 503 or use a **fallback** policy.

---

## Best practices and pitfalls

**Do:**

- Retry only **transient** failures (5xx, timeout, \`HttpRequestException\`). Do not retry 4xx (except 408).
- Use **exponential backoff** and **jitter** for retry.
- Use a **shared** circuit breaker per dependency (same \`HttpClient\` name = same policy instance in typical setup).
- Set **timeout** per call so one slow dependency does not hang.
- **Monitor** circuit state (Closed/Open/Half-Open) and log \`onBreak\`, \`onReset\`, \`onHalfOpen\`.
- Use **fallback** for read-only or optional data (cached or default); avoid fallback for non-idempotent writes unless you use idempotency keys.

**Pitfalls:**

- **Retrying non-idempotent operations** — Double payment, double order. Use idempotency key or do not retry.
- **Circuit too sensitive** — Opens on a small number of failures; tune threshold and sampling duration.
- **Circuit too slow** — Long break duration; dependency recovers but circuit stays open. Tune duration.
- **No timeout** — One hanging call can exhaust threads; always set timeout.
- **Ignoring half-open** — Ensure one failure in half-open reopens the circuit (Polly does this by default).

---
---

## Position & Rationale

I apply **retry** only for **transient** failures (5xx, timeout, \`HttpRequestException\`); I never retry 4xx (except 408) or non-idempotent operations without an idempotency key. I use **circuit breaker** on every outbound call to a shared dependency so we stop hammering it when it's down and fail fast. I always set a **per-call timeout** so a hanging dependency doesn't exhaust threads. I combine policies in a clear order: **Fallback** (outer) so we have a safe default, then **Circuit Breaker**, **Retry**, **Timeout**, **Bulkhead** (inner). I use **Polly** with \`IHttpClientFactory\` so each named client has its own policy and we don't share state across unrelated calls. I reject retrying non-idempotent operations (e.g. payment) unless we have idempotency keys and server-side deduplication.

---

## Trade-Offs & Failure Modes

- **What this sacrifices:** Retry adds latency on transient failure; circuit breaker adds "fail fast" when the circuit is open (users see errors until half-open succeeds). Fallback can hide real outages if overused.
- **Where it degrades:** Wrong policy order (e.g. retry outside circuit breaker) wastes calls on a down dependency. Retrying non-idempotent calls causes duplicate side effects. No timeout lets one slow dependency block the pool. Too many bulkhead partitions or too few can under- or over-isolate.
- **How it fails when misapplied:** Retrying 4xx (e.g. 400, 404) never helps and burns resources. Circuit breaker with too low a threshold opens on normal blips; too high and we cascade. Fallback that always returns success masks dependency failure and can corrupt data if the fallback is "return stale."
- **Early warning signs:** "We're still calling the failing service thousands of times"; "timeouts are piling up"; "circuit never closes" or "opens too easily"; duplicate payments or orders after retries.

---

## What Most Guides Miss

Docs often show retry and circuit breaker in isolation and skip **policy order** and **non-idempotent operations**. In practice, order matters: retry inside circuit breaker so we don't burn retries when the circuit is open; timeout inside retry so each attempt is bounded. Another gap: **idempotency**—if the operation is not idempotent (e.g. "create order"), retry can double-submit; you need idempotency keys and server-side deduplication or you must not retry. Many guides also don't stress **per-dependency** policies (e.g. one circuit breaker per downstream service) so one bad dependency doesn't share state with others.

---

## Decision Framework

- **If you call a remote dependency (HTTP, gRPC)** → Use timeout and retry (transient only); add circuit breaker so repeated failure stops calls; add fallback only when you have a safe default.
- **If the operation is non-idempotent** → Do not retry, or use idempotency key and server-side deduplication; otherwise retry can double-apply.
- **If you have multiple dependencies** → Use separate policies per dependency (named \`HttpClient\`, separate circuit breaker state) so one failure doesn't affect others.
- **If the dependency is slow or flaky** → Use bulkhead to limit concurrent calls; combine with timeout so one slow dependency doesn't exhaust the pool.
- **If the circuit opens too often or never** → Tune failure threshold and duration; add logging so you can see why it opened and when it half-opens.

---

## Key Takeaways

- Retry for transient failures only (5xx, timeout); circuit breaker to stop calling a failing dependency; timeout on every outbound call; bulkhead to isolate; fallback only when safe.
- Policy order: Fallback → Circuit Breaker → Retry → Timeout → Bulkhead (inner). Use Polly with \`IHttpClientFactory\` and per-client policies.
- Do not retry non-idempotent operations without idempotency; tune circuit breaker threshold and duration from real failure patterns.


## Summary

- **Resilience** = system keeps working or degrades gracefully when dependencies fail. **Retry** (transient), **Circuit Breaker** (stop calling failing dependency), **Timeout** (no hanging), **Bulkhead** (isolation), **Fallback** (default value).
- **Retry:** Exponential backoff + jitter; max count; only for 5xx/timeout/transient. **Circuit Breaker:** Closed → Open (after N failures) → Half-Open (after duration) → Closed if trial succeeds.
- **Order:** Fallback → Circuit Breaker → Retry → Timeout → Bulkhead (inner). **Polly** in .NET: \`AddPolicyHandler\` for \`HttpClient\`; use \`Policy.WrapAsync\` for custom order.
- **All scenarios:** Transient → retry; dependency down → circuit opens; timeout → per-call timeout; non-idempotent → do not retry or use idempotency key.
- **Full code:** Centralised policies (Retry, CircuitBreaker, Timeout, Bulkhead), \`Program.cs\` \`AddHttpClient\` + \`AddPolicyHandler\`, service uses \`IHttpClientFactory\`, controller calls service.

---

## When I Would Use This Again — and When I Wouldn't

I would use these resilience patterns again for any service that calls remote dependencies—HTTP APIs, gRPC, or queues. I'd apply retry, circuit breaker, and timeout as the baseline; add bulkhead when we have multiple dependencies or high concurrency; add fallback only when we have a defined safe default. I wouldn't retry non-idempotent operations (e.g. payment, order submit) without idempotency keys. I wouldn't skip circuit breaker to "simplify"—cascading failure is costlier than the extra config. If we're in a single process with no remote calls, resilience policies add little; once we have outbound dependencies, they're mandatory in my view.


---

## Frequently Asked Questions

### What is a Circuit Breaker?

Stops calling a failing dependency after a threshold of failures. States: **Closed** (normal), **Open** (no calls, fail fast), **Half-Open** (one trial). After a duration, circuit moves to Half-Open; one success closes it, one failure reopens it.

### What is Retry?

Retries a failed call with a delay. Use for **transient** failures (network, timeout, 5xx). Use **exponential backoff** and **jitter**; set max retry count.

### When use Retry vs Circuit Breaker?

Use **Retry** for transient failures (a few retries). Use **Circuit Breaker** for remote shared dependencies so that after many failures you stop calling and let the dependency recover. **Combine**: retry a few times, then let the circuit open if failures persist.

### Circuit Breaker states?

**Closed** — calls go through; failures counted. **Open** — no calls; fail immediately. **Half-Open** — one trial call; success → Closed, failure → Open.

### When use Timeout?

Always for outbound calls. Prevents one slow dependency from hanging your thread. Typical: 10–30 seconds per call.

### What is Bulkhead?

Limits **concurrent** calls to a dependency (e.g. max 10). Prevents one bad dependency from consuming all threads and causing cascading failure.

### What is Fallback?

Returns a **default** or **cached** value when the call fails (after retries or when circuit is open). Use for graceful degradation; avoid for non-idempotent writes.

### How combine Retry, Circuit Breaker, Timeout?

Order (outer to inner): **Fallback** → **Circuit Breaker** → **Retry** → **Timeout** → (Bulkhead). In Polly: \`AddPolicyHandler(Timeout)\`, \`AddPolicyHandler(Retry)\`, \`AddPolicyHandler(CircuitBreaker)\` — first added is outermost.

### How implement in .NET?

Use **Polly** and **IHttpClientFactory**. \`AddHttpClient("Name", ...).AddPolicyHandler(GetRetryPolicy()).AddPolicyHandler(GetCircuitBreakerPolicy())\`. All calls with that client share the same policies and (for circuit breaker) the same state.

### Retry on 5xx only?

Yes. Retry on **5xx** and **408** and \`HttpRequestException\`. Do **not** retry **4xx** (client error) except 408.

### What is exponential backoff?

Delay between retries **grows**: e.g. 1s, 2s, 4s. Prevents hammering the dependency. Add **jitter** (random offset) so many clients do not retry at once.

### What is jitter?

Random offset added to the retry delay. Prevents **thundering herd** when many clients retry at the same time.

### Circuit Breaker threshold?

Common: **5 failures** in a row or **50%** of at least 10 calls in **30 seconds**. Tune per dependency.

### Half-open behavior?

After the **break duration**, circuit moves to **Half-Open**. **One** trial call is allowed. **Success** → Closed. **Failure** → Open again (break duration restarts).

### Non-idempotent and retry?

**Do not** retry non-idempotent operations (e.g. payment) without an **idempotency key**. Otherwise retry can double-submit.
`,
  faqs: [
  {
    "question": "What is Circuit Breaker?",
    "answer": "Stops calling failing dependency after threshold. States: Closed, Open, Half-Open. Gives dependency time to recover."
  },
  {
    "question": "What is Retry?",
    "answer": "Retries failed calls with delay. Use exponential backoff and jitter for transient failures (5xx, timeout)."
  },
  {
    "question": "Circuit Breaker states?",
    "answer": "Closed (normal), Open (no calls, fail fast), Half-Open (one trial). Success in half-open closes; failure reopens."
  },
  {
    "question": "When use Circuit Breaker?",
    "answer": "Remote shared dependencies. Prevents cascade and wastes no resources when dependency is down."
  },
  {
    "question": "When use Retry?",
    "answer": "Transient failures: network blip, timeout, 5xx. Not for 4xx or permanent errors."
  },
  {
    "question": "What is Polly?",
    "answer": ".NET resilience library. Retry, Circuit Breaker, Timeout, Bulkhead, Fallback. Integrates with IHttpClientFactory."
  },
  {
    "question": "Exponential backoff?",
    "answer": "Delay grows between retries: 1s, 2s, 4s. Prevents hammering the dependency."
  },
  {
    "question": "What is jitter?",
    "answer": "Random offset on retry delay. Prevents thundering herd when many clients retry at once."
  },
  {
    "question": "What is Bulkhead?",
    "answer": "Limits concurrent calls per dependency. Isolates one bad dependency from exhausting threads."
  },
  {
    "question": "What is Timeout?",
    "answer": "Cancels call after duration. Prevents hanging and thread exhaustion."
  },
  {
    "question": "What is Fallback?",
    "answer": "Returns default or cached value when call fails. Graceful degradation."
  },
  {
    "question": "Combine Retry Circuit Breaker Timeout?",
    "answer": "Yes. Order: Fallback → Circuit Breaker → Retry → Timeout (inner). AddPolicyHandler for each."
  },
  {
    "question": "How implement in .NET?",
    "answer": "AddHttpClient(\"Name\", ...).AddPolicyHandler(Retry).AddPolicyHandler(CircuitBreaker).AddPolicyHandler(Timeout)."
  },
  {
    "question": "Retry on 5xx only?",
    "answer": "Yes. Retry on 5xx, 408, HttpRequestException. Do not retry 4xx (except 408)."
  },
  {
    "question": "Circuit Breaker threshold?",
    "answer": "Common: 5 failures or 50% of 10+ calls in 30 seconds. Tune per dependency."
  },
  {
    "question": "Half-open behavior?",
    "answer": "After break duration, one trial call. Success → Closed. Failure → Open again."
  },
  {
    "question": "Non-idempotent and retry?",
    "answer": "Do not retry without idempotency key. Retry can double-submit (e.g. payment)."
  },
  {
    "question": "All failure scenarios?",
    "answer": "Transient → retry. Dependency down → circuit opens. Timeout → per-call timeout. Non-idempotent → no retry or idempotency key."
  }
]
}
