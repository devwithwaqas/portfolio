/**
 * Blog article: domain-driven-design-basics
 * Auto-generated by scripts/split-blog-articles.js. Do not edit the content here by hand if you run the split script again.
 */

export default {
  slug: "domain-driven-design-basics",
  title: "Domain-Driven Design (DDD) Basics: Bounded Contexts and Aggregates",
  excerpt: "In-depth look at DDD basics: bounded contexts, aggregates, entities, value objects, and when to use DDD.",
  date: "2024-12-10",
  topic: "Architecture",
  keywords: ["Domain-Driven Design (DDD) Basics: Bounded Contexts and Aggregates", "Domain Driven Design Basics", "Domain Driven Design Basics best practices", "how to domain driven design basics", "domain driven design basics in .NET", "domain driven design basics guide", "domain driven design basics for enterprise", "domain driven design basics patterns", "when to use domain driven design basics", "domain driven design basics tutorial", "domain driven design basics examples", "domain driven design basics in C#", "domain driven design basics overview", "domain driven design basics implementation", "understanding domain driven design basics", "domain driven design basics for developers", "domain driven design basics checklist", "domain driven design basics tips", "domain driven design basics deep dive", "domain driven design basics comparison", "domain driven design basics vs alternatives", "domain driven design basics .NET Core", "domain driven design basics Azure", "domain driven design basics explained", "domain driven design basics when to use", "domain driven design basics enterprise", "domain driven design basics .NET", "what is domain driven design basics", "domain driven design basics summary", "domain driven design basics introduction", "domain driven design basics fundamentals", "domain driven design basics step by step", "domain driven design basics complete guide", "domain driven design basics for beginners", "domain driven design basics advanced", "domain driven design basics production", "domain driven design basics real world", "domain driven design basics example code", "domain driven design basics C# example", "domain driven design basics .NET example", "learn domain driven design basics", "domain driven design basics learn", "domain driven design basics reference", "domain driven design basics cheat sheet", "domain driven design basics pitfalls", "domain driven design basics common mistakes", "domain driven design basics performance", "domain driven design basics optimization", "domain driven design basics security", "domain driven design basics testing", "domain driven design basics unit test", "domain driven design basics integration", "domain driven design basics migration", "domain driven design basics from scratch", "domain driven design basics 2024", "domain driven design basics 2025", "best domain driven design basics", "domain driven design basics best", "pro domain driven design basics", "domain driven design basics expert", "domain driven design basics consultant", "domain driven design basics services", "domain driven design basics course", "domain driven design basics workshop", "domain driven design basics webinar", "domain driven design basics blog", "domain driven design basics article", "domain driven design basics post", "why domain driven design basics", "when domain driven design basics", "where domain driven design basics", "domain driven design basics in .NET 6", "domain driven design basics in .NET 7", "domain driven design basics in .NET 8", "domain driven design basics for C#", "domain driven design basics for Angular", "domain driven design basics for Vue", "domain driven design basics for React", "domain driven design basics for Azure", "domain driven design basics for microservices", "domain driven design basics for API", "domain driven design basics for database", "domain driven design basics for testing", "domain driven design basics for DevOps", "domain driven design basics for senior developers", "domain driven design basics for team", "domain driven design basics for production", "domain driven design basics for scale", "domain driven design basics for refactoring", "domain driven design basics for enterprise applications", "domain driven design basics for startup", "domain driven design basics in 2024", "domain driven design basics in 2025", "domain driven design basics in 2026", "domain driven design basics code sample", "domain driven design basics code example", "domain driven design basics sample code", "domain driven design basics full example", "domain driven design basics working example", "domain driven design basics practical domain driven design basics", "domain driven design basics real world example", "domain driven design basics use case", "domain driven design basics use cases", "domain driven design basics scenario", "domain driven design basics scenarios", "domain driven design basics pattern", "domain driven design basics approach", "domain driven design basics approaches", "domain driven design basics strategy", "domain driven design basics strategies", "domain driven design basics technique", "domain driven design basics techniques", "domain driven design basics method", "domain driven design basics methods", "domain driven design basics solution", "domain driven design basics solutions", "domain driven design basics implementation guide", "domain driven design basics getting started", "domain driven design basics quick start", "domain driven design basics overview guide", "domain driven design basics comprehensive guide", "domain driven design basics detailed guide", "domain driven design basics practical guide", "domain driven design basics developer guide", "domain driven design basics engineer guide", "domain driven design basics architect guide", "domain driven design basics for architects", "domain driven design basics for backend", "domain driven design basics for tech leads", "domain driven design basics for senior devs", "benefits of domain driven design basics", "advantages of domain driven design basics", "alternatives to domain driven design basics", "compared to domain driven design basics", "intro to domain driven design basics", "basics of domain driven design basics", "domain driven design basics tips and tricks", "domain driven design basics production-ready", "domain driven design basics enterprise-grade", "domain driven design basics with Docker", "domain driven design basics with Kubernetes", "domain driven design basics in ASP.NET Core", "domain driven design basics with Entity Framework", "domain driven design basics with EF Core", "domain driven design basics modern", "domain driven design basics updated", "domain driven design basics latest", "domain driven design basics walkthrough", "domain driven design basics hands-on", "domain driven design basics practical examples", "domain driven design basics real-world examples", "domain driven design basics common pitfalls", "domain driven design basics gotchas", "domain driven design basics FAQ", "domain driven design basics FAQs", "domain driven design basics Q&A", "domain driven design basics interview questions", "domain driven design basics interview", "domain driven design basics certification", "domain driven design basics training", "domain driven design basics video", "domain driven design basics series", "domain driven design basics part 1", "domain driven design basics core concepts", "domain driven design basics key concepts", "domain driven design basics recap", "domain driven design basics takeaways", "domain driven design basics conclusion", "domain driven design basics next steps", "domain driven design basics further reading", "domain driven design basics resources", "domain driven design basics tools", "domain driven design basics libraries", "domain driven design basics frameworks", "domain driven design basics NuGet", "domain driven design basics package", "domain driven design basics GitHub", "domain driven design basics open source", "domain driven design basics community", "domain driven design basics Microsoft docs", "domain driven design basics documentation", "domain driven design basics official guide", "domain driven design basics official tutorial", "Domain", "Domain guide", "Domain tutorial", "Domain best practices", "Domain in .NET", "Domain in C#", "Domain for developers", "Domain examples", "Domain patterns", "Domain overview", "Domain introduction", "Domain deep dive", "Domain explained", "Domain how to", "Domain what is", "Domain when to use", "Domain for enterprise"],
  relatedServices: ["microservices-architecture","full-stack-development","technical-leadership"],
  relatedProjects: ["bat-inhouse-app"],
  relatedArticleSlugs: ["azure-microservices-best-practices","clean-architecture-dotnet"],
  author: "Waqas Ahmad",
  content: `## Introduction

This guidance is relevant when the topic of this article applies to your system or design choices; it breaks down when constraints or context differ. I've applied it in real projects and refined the takeaways over time (as of 2026).

**Domain-Driven Design (DDD)** is an approach to software development that focuses on modeling complex business domains. Instead of starting with the database or UI, you start with understanding the business—its language, rules, and boundaries.

DDD was introduced by Eric Evans in 2003 and has become essential for building microservices and complex enterprise systems. This article covers the core concepts: bounded contexts, aggregates, entities, value objects, and when to use DDD.

## Topics covered

- [Decision Context](#decision-context)
- [What is DDD?](#what-is-ddd)
- [Strategic vs tactical DDD](#strategic-vs-tactical-ddd)
- [Bounded contexts](#bounded-contexts)
- [Ubiquitous language](#ubiquitous-language)
- [Aggregates](#aggregates)
- [Entities vs value objects](#entities-vs-value-objects)
- [Domain events](#domain-events)
- [When to use DDD](#when-to-use-ddd)
- [Enterprise best practices](#enterprise-best-practices)
- [Common issues](#common-issues)
- [Summary](#summary)
- [Position & Rationale](#position--rationale)
- [Trade-Offs & Failure Modes](#trade-offs--failure-modes)
- [What Most Guides Miss](#what-most-guides-miss)
- [Decision Framework](#decision-framework)
- [Key Takeaways](#key-takeaways)
- [When I Would Use This Again — and When I Wouldn't](#when-i-would-use-this-again--and-when-i-wouldnt)
- [Frequently Asked Questions](#frequently-asked-questions)

## Decision Context

- **System scale:** Systems with non-trivial domain logic and multiple subdomains; from medium to large applications. Applies when the domain is complex enough that a shared model and language pay off.
- **Team size:** Teams that can work with domain experts and maintain a shared vocabulary; someone must own bounded contexts and aggregate boundaries. Works when the business logic is not "simple CRUD."
- **Time / budget pressure:** Fits when you have time for discovery and iterative modelling; breaks down when the domain is trivial or when there's no access to domain experts—then a simpler model is better.
- **Technical constraints:** Any stack; DDD is about modelling and boundaries, not a specific technology. Assumes you can separate domain from infrastructure (e.g. repositories, persistence).
- **Non-goals:** This article does not optimise for "DDD everywhere"; it focuses on when DDD is justified and how to apply bounded contexts and aggregates.

## What is DDD?

**Domain-Driven Design** is an approach where:
- The **domain** (business problem) drives the design
- Code reflects **business language** and concepts
- Complex domains are split into **bounded contexts**
- **Aggregates** enforce business rules and consistency

| DDD Concept | Purpose |
|-------------|---------|
| **Bounded Context** | Boundary where a model is consistent |
| **Ubiquitous Language** | Shared vocabulary between devs and domain experts |
| **Aggregate** | Cluster of objects with consistency boundary |
| **Entity** | Object with identity (e.g. Order) |
| **Value Object** | Object without identity (e.g. Money, Address) |
| **Domain Event** | Something that happened in the domain |

## Strategic vs tactical DDD

**Strategic DDD** is about the big picture:
- Identifying bounded contexts
- Defining context relationships
- Aligning teams with contexts

**Tactical DDD** is about implementation:
- Aggregates, entities, value objects
- Domain services, repositories
- Domain events

Start with strategic to understand boundaries; use tactical for implementation.

## Bounded contexts

A **bounded context** is a boundary within which a domain model is consistent. The same term can mean different things in different contexts:

| Concept | Sales Context | Shipping Context |
|---------|---------------|------------------|
| **Order** | Quote, pricing, customer | Package, address, carrier |
| **Customer** | Billing info, credit | Delivery address only |
| **Product** | SKU, price | Weight, dimensions |

Each context has its own model. Do not force one model to fit all contexts.

**Context mapping** defines relationships between contexts:
- **Shared Kernel:** Shared code/model (tight coupling)
- **Customer-Supplier:** One context depends on another
- **Anti-Corruption Layer:** Translate between models

## Ubiquitous language

**Ubiquitous language** is a shared vocabulary between developers and domain experts. Everyone uses the same terms in code, docs, and conversations.

**Examples:**
- "Order" not "purchase_record"
- "Ship" not "update_status_to_shipped"
- "PlaceOrder" not "createOrderRecord"

Code should read like business language:

\`\`\`csharp
// Good: ubiquitous language
order.Place();
order.Ship();
order.Cancel();

// Bad: technical jargon
order.SetStatus(OrderStatus.Placed);
orderRepository.Update(order);
\`\`\`

## Aggregates

An **aggregate** is a cluster of entities and value objects with:
- A **root entity** (aggregate root)
- A **consistency boundary**
- **Invariants** (rules that must always be true)

**Rules:**
1. External references only to the root
2. Changes go through the root
3. One transaction = one aggregate

**Example: Order aggregate**

\`\`\`csharp
// Order is the aggregate root
public class Order
{
    public OrderId Id { get; }
    public CustomerId CustomerId { get; }
    private readonly List<OrderLine> _lines = new();
    public IReadOnlyList<OrderLine> Lines => _lines;
    
    // Invariant: order total cannot be negative
    public Money Total => _lines.Sum(l => l.Subtotal);
    
    // Changes go through the root
    public void AddLine(ProductId productId, int quantity, Money price)
    {
        if (quantity <= 0) throw new DomainException("Quantity must be positive");
        _lines.Add(new OrderLine(productId, quantity, price));
    }
    
    public void Place()
    {
        if (!_lines.Any()) throw new DomainException("Cannot place empty order");
        // Raise domain event
    }
}
\`\`\`

## Entities vs value objects

| Aspect | Entity | Value Object |
|--------|--------|--------------|
| **Identity** | Has unique ID | No identity |
| **Equality** | By ID | By value |
| **Mutability** | Can change | Immutable |
| **Examples** | Order, Customer, Product | Money, Address, DateRange |

**Entity example:**

\`\`\`csharp
public class Customer
{
    public CustomerId Id { get; }
    public string Name { get; private set; }
    
    // Two customers with same name are different entities
    public override bool Equals(object obj) =>
        obj is Customer c && c.Id == Id;
}
\`\`\`

**Value object example:**

\`\`\`csharp
public record Money(decimal Amount, string Currency)
{
    // Two Money with same amount and currency are equal
    public static Money operator +(Money a, Money b)
    {
        if (a.Currency != b.Currency) throw new InvalidOperationException();
        return new Money(a.Amount + b.Amount, a.Currency);
    }
}

public record Address(string Street, string City, string PostalCode, string Country);
\`\`\`

## Domain events

**Domain events** represent something that happened in the domain. They are past tense and immutable.

**Examples:**
- OrderPlaced
- PaymentReceived
- CustomerAddressChanged

\`\`\`csharp
public record OrderPlaced(OrderId OrderId, CustomerId CustomerId, DateTime OccurredAt);

public class Order
{
    private readonly List<IDomainEvent> _events = new();
    
    public void Place()
    {
        // Validate...
        _events.Add(new OrderPlaced(Id, CustomerId, DateTime.UtcNow));
    }
    
    public IEnumerable<IDomainEvent> GetDomainEvents() => _events;
}
\`\`\`

Events enable:
- Decoupling between aggregates
- Audit trails
- Event sourcing
- Integration between bounded contexts

## When to use DDD

**Use DDD when:**
- Domain is complex (many rules, edge cases)
- Business experts are available
- Long-term investment justifies upfront cost
- Microservices need clear boundaries

**Skip DDD when:**
- Simple CRUD application
- No domain complexity
- Tight deadlines, no domain expert access
- Small team, small scope

DDD adds complexity. Use it where the domain justifies it.

## Enterprise best practices

**1. Start with strategic DDD.** Identify bounded contexts before coding. Talk to domain experts.

**2. One aggregate = one transaction.** Do not span transactions across aggregates.

**3. Keep aggregates small.** Large aggregates have concurrency issues. Split if needed.

**4. Use domain events for cross-aggregate communication.** Do not reference other aggregates directly.

**5. Protect invariants.** Aggregates enforce business rules. Do not bypass with direct DB access.

**6. Align bounded contexts with teams.** One team owns one context. Conway's Law.

**7. Use anti-corruption layers.** When integrating with legacy or external systems, translate to your model.

**8. Iterate.** Domain models evolve. Refactor as understanding improves.

## Common issues

| Issue | Cause | Fix |
|-------|-------|-----|
| **Anemic domain model** | Logic in services, not entities | Move behavior into aggregates |
| **Giant aggregate** | Too much in one boundary | Split into smaller aggregates |
| **Cross-aggregate transactions** | Spanning multiple aggregates | Use eventual consistency, domain events |
| **Leaky abstraction** | DB concerns in domain | Use repository pattern; keep domain pure |
| **Wrong bounded contexts** | Misunderstood domain | Iterate with domain experts |
| **Over-engineering** | DDD for simple CRUD | Use DDD only where domain is complex |

## Summary

DDD aligns code with business domains. Use bounded contexts to split complexity, ubiquitous language for shared understanding, and aggregates for consistency. Apply DDD where domain complexity justifies it—not everywhere.

## Position & Rationale

I use **DDD** when the domain has real rules, multiple subdomains, and a need for a shared language between devs and business—so that the code and conversations use the same terms. I apply **bounded contexts** when the same concept means different things in different parts of the business (e.g. “order” in shipping vs billing); I avoid a single giant model. I use **aggregates** to enforce consistency boundaries and keep transactions small; I avoid cross-aggregate transactions and use domain events for eventual consistency. I skip DDD when the problem is simple CRUD or when there’s no domain complexity to capture—then a thin domain or anemic model is fine. I don’t do “DDD theatre” (ubiquitous language in name only, or aggregates that are just entity bags with no invariants).

## Trade-Offs & Failure Modes

**DDD** adds upfront modelling and discipline; you gain alignment with the business and clearer boundaries. **Bounded contexts** add coordination (context maps, contracts); you gain freedom to evolve each context. **Aggregates** limit transaction scope; you gain consistency within the aggregate but must design for eventual consistency across aggregates. Failure modes: one huge aggregate (hard to reason about and deploy); cross-aggregate transactions (distributed monolith); bounded contexts that don’t match how the business thinks; over-engineering simple domains with full DDD ceremony.

## What Most Guides Miss

Most guides explain entities and aggregates but don’t stress that **aggregate boundaries are the hard part**—too small and you have cross-aggregate consistency issues; too large and you have a monolith inside the boundary. Another gap: **strategic DDD** (bounded contexts, context mapping) is often skipped in favour of tactical (entities, value objects); without strategic DDD you get a single model that tries to be everything. **When not to use DDD** is underplayed—simple CRUD or thin domains don’t need aggregates and ubiquitous language; applying DDD there is overhead.

## Decision Framework

- **If the domain has distinct subdomains and the same term means different things in different areas** → Use bounded contexts; define context map and contracts.
- **If there are consistency rules that must hold within a boundary** → Model aggregates; keep transactions inside one aggregate; use events for cross-aggregate.
- **If the business and devs need a shared vocabulary** → Cultivate ubiquitous language; use it in code and in conversation.
- **If the problem is simple CRUD or no real domain logic** → Skip full DDD; use a simple model.
- **For existing systems** → Start with one bounded context or one aggregate; expand iteratively with domain experts.

## Key Takeaways

- Use **DDD** when domain complexity justifies it—bounded contexts, ubiquitous language, and aggregates.
- **Bounded contexts** split the model where the business splits; avoid one model to rule them all.
- **Aggregates** enforce invariants and limit transaction scope; use domain events for cross-aggregate.
- Skip DDD for simple CRUD; avoid giant aggregates and cross-aggregate transactions.
- Iterate with domain experts; strategic DDD (contexts) before tactical (entities, value objects).

## When I Would Use This Again — and When I Wouldn't

I’d use **DDD** again when the domain has real rules, multiple subdomains, and a need for a shared language—and when we have access to domain experts to refine bounded contexts and aggregates. I’d use **bounded contexts** when the same concept means different things in different parts of the system. I wouldn’t apply full DDD to simple CRUD or admin UIs where the domain is thin; the ceremony isn’t worth it. I also wouldn’t design one large aggregate “for simplicity”; small, well-defined aggregates with events are easier to evolve.

## Frequently Asked Questions

### What is DDD?

**Domain-Driven Design** is an approach where the business domain drives software design. Code reflects business language and rules.

### What is a bounded context?

A **bounded context** is a boundary within which a domain model is consistent. The same term can mean different things in different contexts.

### What is ubiquitous language?

A **shared vocabulary** between developers and domain experts. Everyone uses the same terms in code and conversation.

### What is an aggregate?

A **cluster of entities and value objects** with a root and consistency boundary. Changes go through the root; one transaction per aggregate.

### What is an entity?

An **object with identity**. Two entities with same data but different IDs are different (e.g. two Orders).

### What is a value object?

An **object without identity**. Two value objects with same data are equal (e.g. Money, Address).

### What is a domain event?

Something that **happened in the domain** (past tense). Used for decoupling, audit, and integration.

### When should I use DDD?

When the **domain is complex** and business experts are available. Not for simple CRUD.

### What is an aggregate root?

The **entry point** to an aggregate. External code references only the root; the root enforces invariants.

### How big should an aggregate be?

**Small enough** for one transaction; large enough to enforce invariants. Split if concurrency is an issue.

### What is strategic vs tactical DDD?

**Strategic:** Big picture (bounded contexts, teams). **Tactical:** Implementation (aggregates, entities, value objects).

### What is an anti-corruption layer?

A **translation layer** between your model and an external/legacy system. Protects your domain from foreign models.

### How do aggregates communicate?

Via **domain events**. One aggregate publishes; another subscribes. Eventual consistency.

### What is an anemic domain model?

Entities with **only data, no behavior**. Logic lives in services. Avoid by putting behavior in aggregates.

### How do I identify bounded contexts?

Talk to **domain experts**. Look for different meanings of the same term. Align with teams and business capabilities.`,
  faqs: [
  {
    "question": "What is DDD?",
    "answer": "Domain-Driven Design—approach where business domain drives software design. Code reflects business language and rules."
  },
  {
    "question": "What is a bounded context?",
    "answer": "Boundary within which a domain model is consistent. Same term can mean different things in different contexts."
  },
  {
    "question": "What is ubiquitous language?",
    "answer": "Shared vocabulary between developers and domain experts. Same terms in code and conversation."
  },
  {
    "question": "What is an aggregate?",
    "answer": "Cluster of entities and value objects with root and consistency boundary. One transaction per aggregate."
  },
  {
    "question": "What is an entity?",
    "answer": "Object with identity. Two entities with same data but different IDs are different."
  },
  {
    "question": "What is a value object?",
    "answer": "Object without identity. Two with same data are equal (e.g. Money, Address)."
  },
  {
    "question": "What is a domain event?",
    "answer": "Something that happened in the domain (past tense). Used for decoupling and integration."
  },
  {
    "question": "When use DDD?",
    "answer": "When domain is complex and business experts available. Not for simple CRUD."
  },
  {
    "question": "What is aggregate root?",
    "answer": "Entry point to aggregate. External code references only root; root enforces invariants."
  },
  {
    "question": "How big should aggregate be?",
    "answer": "Small for one transaction; large enough to enforce invariants. Split if concurrency issues."
  },
  {
    "question": "Strategic vs tactical DDD?",
    "answer": "Strategic: big picture (contexts, teams). Tactical: implementation (aggregates, entities)."
  },
  {
    "question": "What is anti-corruption layer?",
    "answer": "Translation layer between your model and external/legacy system. Protects your domain."
  },
  {
    "question": "How do aggregates communicate?",
    "answer": "Via domain events. One publishes; another subscribes. Eventual consistency."
  },
  {
    "question": "What is anemic domain model?",
    "answer": "Entities with only data, no behavior. Avoid by putting behavior in aggregates."
  },
  {
    "question": "How identify bounded contexts?",
    "answer": "Talk to domain experts. Look for different meanings of same term. Align with teams."
  }
]
}
